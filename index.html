<!DOCTYPE html>
<html>
  <head>
    <title>Kubernetes for administrators and operators </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="workshop.css">
  </head>
  <body>
    <!--
    <div style="position: absolute; left: 20%; right: 20%; top: 30%;">
      <h1 style="font-size: 3em;">Loading ...</h1>
      The slides should show up here. If they don't, it might be
      because you are accessing this file directly from your filesystem.
      It needs to be served from a web server. You can try this:
      <pre>
        docker-compose up -d
        open http://localhost:8888/workshop.html # on MacOS
        xdg-open http://localhost:8888/workshop.html # on Linux
      </pre>
      Once the slides are loaded, this notice disappears when you
      go full screen (e.g. by hitting "f").
    </div>
    -->
    <textarea id="source">

# Instructions de Navigation

## Comment naviguer dans les diapositives

- **Utilisez la barre d'espace :** Avancer à la diapositive suivante
- **Utilisez les touches fléchées :** 
  - Flèche droite → Diapositive suivante
  - Flèche gauche ← Diapositive précédente

.debug[
```
?? slides/containers/credit.md
?? slides/containers/introduction.md
?? slides/imie.yml
?? slides/shared/navigation.md

```

These slides have been built from commit: 6105b579


[shared/navigation.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/navigation.md)]
---
# Bienvenue à la formation Kubernetes !

## Rencontrez votre instructeur :  Achraf ELAFRIT

### Expert DevOps
- **Expérience :** Plus de 7 ans dans le développement d'infrastructure
- **Expertise :** Spécialisation en Kubernetes, CI/CD et technologies cloud

### Connectez-vous avec moi
- [LinkedIn](https://www.linkedin.com/in/achrafelafrit/)
- [GitHub](https://github.com/FractalDesigns)

.debug[[containers/introduction.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/introduction.md)]
---
class: title, self-paced

Kubernetes<br/>for administrators<br/>and operators<br/>

.nav[*Self-paced version*]

.debug[[shared/title.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/title.md)]
---

class: title, in-person

Administarion<br/>d'un système kubernetes <br/> on premise pour architectes, <br/> operationnels et developpeurs <br/><br/></br>

.footnote[
**Slides[:](https://www.youtube.com/watch?v=h16zyxiwDLY) **
]

<!--
WiFi: **Something**<br/>
Password: **Something**

**Be kind to the WiFi!**<br/>
*Use the 5G network.*
*Don't use your hotspot.*<br/>
*Don't stream videos or download big files during the workshop*<br/>
*Thank you!*
-->

.debug[[shared/title.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/title.md)]
---

name: toc-part-1

## Part 1

- [Docker 30,000ft overview](#toc-docker-ft-overview)
- [History of containers ... and Docker](#toc-history-of-containers--and-docker)
- [Our training environment](#toc-our-training-environment)
- [Installing Docker](#toc-installing-docker)
- [Our first containers](#toc-our-first-containers)
- [Background containers](#toc-background-containers)
- [Restarting and attaching to containers](#toc-restarting-and-attaching-to-containers)
- [Naming and inspecting containers](#toc-naming-and-inspecting-containers)
- [Labels](#toc-labels)
- [Getting inside a container](#toc-getting-inside-a-container)
- [Understanding Docker images](#toc-understanding-docker-images)

.debug[(auto-generated TOC)]
---
name: toc-part-2

## Part 2

- [Building images interactively](#toc-building-images-interactively)

- [Building Docker images with a Dockerfile](#toc-building-docker-images-with-a-dockerfile)

- [`CMD` and `ENTRYPOINT`](#toc-cmd-and-entrypoint)

- [Copying files during the build](#toc-copying-files-during-the-build)

- [Exercise — writing Dockerfiles](#toc-exercise--writing-dockerfiles)


.debug[(auto-generated TOC)]
---
name: toc-part-3

## Part 3

- [Container networking basics](#toc-container-networking-basics)

- [Container network drivers](#toc-container-network-drivers)

- [Local development workflow with Docker](#toc-local-development-workflow-with-docker)

- [The Container Network Model](#toc-the-container-network-model)

- [Service discovery with containers](#toc-service-discovery-with-containers)

- [Gentle introduction to YAML](#toc-gentle-introduction-to-yaml)

- [Compose for development stacks](#toc-compose-for-development-stacks)

- [Exercise — writing a Compose file](#toc-exercise--writing-a-compose-file)


.debug[(auto-generated TOC)]
---
name: toc-part-4

## Part 4

- [Reducing image size](#toc-reducing-image-size)
- [Multi-stage builds](#toc-multi-stage-builds)
- [Publishing images to the Docker Hub](#toc-publishing-images-to-the-docker-hub)
- [Tips for efficient Dockerfiles](#toc-tips-for-efficient-dockerfiles)
- [Dockerfile examples](#toc-dockerfile-examples)
- [Exercise — writing better Dockerfiles](#toc-exercise--writing-better-dockerfiles)
- [Managing hosts with Docker Machine](#toc-managing-hosts-with-docker-machine)
- [Advanced Dockerfile Syntax](#toc-advanced-dockerfile-syntax)
- [Buildkit](#toc-buildkit)
- [Init systems and PID 1](#toc-init-systems-and-pid-)
- [Application Configuration](#toc-application-configuration)

.debug[(auto-generated TOC)]
---
name: toc-part-5

## Part 5

- [Logging](#toc-logging)
- [Deep dive into container internals](#toc-deep-dive-into-container-internals)
- [Control groups](#toc-control-groups)
- [Namespaces](#toc-namespaces)
- [Security features](#toc-security-features)
- [Copy-on-write filesystems](#toc-copy-on-write-filesystems)
- [Building containers from scratch](#toc-building-containers-from-scratch)
- [Docker Engine and other container engines](#toc-docker-engine-and-other-container-engines)
- [Container Super-structure](#toc-container-super-structure)
- [The container ecosystem](#toc-the-container-ecosystem)
- [Orchestration, an overview](#toc-orchestration-an-overview)

.debug[(auto-generated TOC)]
---
name: toc-part-6

## Part 6

- [Pre-requirements](#toc-pre-requirements)

- [Kubernetes architecture](#toc-kubernetes-architecture)

- [The Kubernetes API](#toc-the-kubernetes-api)

- [Other control plane components](#toc-other-control-plane-components)

- [Kubernetes Internal APIs](#toc-kubernetes-internal-apis)

- [Building our own cluster (easy)](#toc-building-our-own-cluster-easy)


.debug[(auto-generated TOC)]
---
name: toc-part-7

## Part 7

- [Building our own cluster (medium)](#toc-building-our-own-cluster-medium)

- [Building our own cluster (hard)](#toc-building-our-own-cluster-hard)

- [Adding nodes to the cluster](#toc-adding-nodes-to-the-cluster)

- [The Container Network Interface](#toc-the-container-network-interface)

- [CNI internals](#toc-cni-internals)

- [Interconnecting clusters](#toc-interconnecting-clusters)


.debug[(auto-generated TOC)]
---
name: toc-part-8

## Part 8

- [API server availability](#toc-api-server-availability)

- [Setting up Kubernetes](#toc-setting-up-kubernetes)

- [Running a local development cluster](#toc-running-a-local-development-cluster)

- [Deploying a managed cluster](#toc-deploying-a-managed-cluster)

- [Kubernetes distributions and installers](#toc-kubernetes-distributions-and-installers)

- [Upgrading clusters](#toc-upgrading-clusters)

- [Static pods](#toc-static-pods)


.debug[(auto-generated TOC)]
---
name: toc-part-9

## Part 9

- [Backing up clusters](#toc-backing-up-clusters)

- [The Cloud Controller Manager](#toc-the-cloud-controller-manager)

- [Healthchecks](#toc-healthchecks)


.debug[(auto-generated TOC)]
---
name: toc-part-10

## Part 10

- [Deploying a sample application](#toc-deploying-a-sample-application)

- [Accessing logs from the CLI](#toc-accessing-logs-from-the-cli)

- [Centralized logging](#toc-centralized-logging)

- [Authentication and authorization](#toc-authentication-and-authorization)

- [Generating user certificates](#toc-generating-user-certificates)

- [The CSR API](#toc-the-csr-api)


.debug[(auto-generated TOC)]
---
name: toc-part-11

## Part 11

- [OpenID Connect](#toc-openid-connect)

- [Securing the control plane](#toc-securing-the-control-plane)

- [Network policies](#toc-network-policies)

- [Restricting Pod Permissions](#toc-restricting-pod-permissions)

- [Pod Security Policies](#toc-pod-security-policies)

- [Pod Security Admission](#toc-pod-security-admission)


.debug[(auto-generated TOC)]
---
name: toc-part-12

## Part 12

- [Resource Limits](#toc-resource-limits)

- [Defining min, max, and default resources](#toc-defining-min-max-and-default-resources)

- [Namespace quotas](#toc-namespace-quotas)

- [Limiting resources in practice](#toc-limiting-resources-in-practice)

- [Checking Node and Pod resource usage](#toc-checking-node-and-pod-resource-usage)

- [Cluster sizing](#toc-cluster-sizing)

- [Disruptions](#toc-disruptions)

- [The Horizontal Pod Autoscaler](#toc-the-horizontal-pod-autoscaler)


.debug[(auto-generated TOC)]
---
name: toc-part-13

## Part 13

- [Collecting metrics with Prometheus](#toc-collecting-metrics-with-prometheus)

- [Extending the Kubernetes API](#toc-extending-the-kubernetes-api)

- [Custom Resource Definitions](#toc-custom-resource-definitions)

- [Operators](#toc-operators)

- [An ElasticSearch Operator](#toc-an-elasticsearch-operator)

- [Designing an operator](#toc-designing-an-operator)

- [Writing a tiny operator](#toc-writing-a-tiny-operator)


.debug[(auto-generated TOC)]
---
name: toc-part-14

## Part 14

- [Last words](#toc-last-words)

- [Links and resources](#toc-links-and-resources)

- [(All content after this slide is bonus material)](#toc-all-content-after-this-slide-is-bonus-material)


.debug[(auto-generated TOC)]
---
name: toc-part-15

## Part 15

- [Volumes](#toc-volumes)

- [Managing configuration](#toc-managing-configuration)

- [Managing secrets](#toc-managing-secrets)

- [Stateful sets](#toc-stateful-sets)

- [Running a Consul cluster](#toc-running-a-consul-cluster)

- [PV, PVC, and Storage Classes](#toc-pv-pvc-and-storage-classes)

- [OpenEBS ](#toc-openebs-)

- [Stateful failover](#toc-stateful-failover)


.debug[(auto-generated TOC)]
---
name: toc-part-16

## Part 16

- [Resources](#toc-resources)


.debug[(auto-generated TOC)]



.debug[[shared/toc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/toc.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-docker-ft-overview
class: title

 Docker 30,000ft overview

.nav[
[Previous part](#toc-)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-history-of-containers--and-docker)
]

.debug[(automatically generated title slide)]

---
# Docker 30,000ft overview

In this lesson, we will learn about:

* Why containers (non-technical elevator pitch)

* Why containers (technical elevator pitch)

* How Docker helps us to build, ship, and run

* The history of containers

We won't actually run Docker or containers in this chapter (yet!).

Don't worry, we will get to that fast enough!

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

## Elevator pitch

### (for your manager, your boss...)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

## OK... Why the buzz around containers?

* The software industry has changed

* Before:
  * monolithic applications
  * long development cycles
  * single environment
  * slowly scaling up

* Now:
  * decoupled services
  * fast, iterative improvements
  * multiple environments
  * quickly scaling out

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

## Deployment becomes very complex

* Many different stacks:
  * languages
  * frameworks
  * databases

* Many different targets:
  * individual development environments
  * pre-production, QA, staging...
  * production: on prem, cloud, hybrid

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: pic

## The deployment problem

![problem](images/shipping-software-problem.png)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: pic

## The matrix from hell

![matrix](images/shipping-matrix-from-hell.png)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: pic

## The parallel with the shipping industry

![history](images/shipping-industry-problem.png)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: pic

## Intermodal shipping containers

![shipping](images/shipping-industry-solution.png)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: pic

## A new shipping ecosystem

![shipeco](images/shipping-indsutry-results.png)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: pic

## A shipping container system for applications

![shipapp](images/shipping-software-solution.png)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: pic

## Eliminate the matrix from hell

![elimatrix](images/shipping-matrix-solved.png)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

## Results

* [Dev-to-prod reduced from 9 months to 15 minutes (ING)](
  https://gallant-turing-d0d520.netlify.com/docker-case-studies/CS_ING_01.25.2015_1.pdf)

* [Continuous integration job time reduced by more than 60% (BBC)](
  https://gallant-turing-d0d520.netlify.com/docker-case-studies/CS_BBCNews_01.25.2015_1.pdf)

* [Deploy 100 times a day instead of once a week (GILT)](
  https://gallant-turing-d0d520.netlify.com/docker-case-studies/CS_Gilt_Groupe_03.18.2015_0.pdf)

* [70% infrastructure consolidation (MetLife)](
  https://www.youtube.com/watch?v=Bwt3xigvlj0)

* etc.

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

## Elevator pitch

### (for your fellow devs and ops)

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

## Escape dependency hell

1. Write installation instructions into an `INSTALL.txt` file

2. Using this file, write an `install.sh` script that works *for you*

3. Turn this file into a `Dockerfile`, test it on your machine

4. If the Dockerfile builds on your machine, it will build *anywhere*

5. Rejoice as you escape dependency hell and "works on my machine"

Never again "worked in dev - ops problem now!"

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

## On-board developers and contributors rapidly

1. Write Dockerfiles for your application components

2. Use pre-made images from the Docker Hub (mysql, redis...)

3. Describe your stack with a Compose file

4. On-board somebody with two commands:

```bash
git clone ...
docker-compose up
```

With this, you can create development, integration, QA environments in minutes!

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Implement reliable CI easily

1. Build test environment with a Dockerfile or Compose file

2. For each test run, stage up a new container or stack

3. Each run is now in a clean environment

4. No pollution from previous tests

Way faster and cheaper than creating VMs each time!

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Use container images as build artefacts

1. Build your app from Dockerfiles

2. Store the resulting images in a registry

3. Keep them forever (or as long as necessary)

4. Test those images in QA, CI, integration...

5. Run the same images in production

6. Something goes wrong? Rollback to previous image

7. Investigating old regression? Old image has your back!

Images contain all the libraries, dependencies, etc. needed to run the app.

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Decouple "plumbing" from application logic

1. Write your code to connect to named services ("db", "api"...)

2. Use Compose to start your stack

3. Docker will setup per-container DNS resolver for those names

4. You can now scale, add load balancers, replication ... without changing your code

Note: this is not covered in this intro level workshop!

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## What did Docker bring to the table?

### Docker before/after

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Formats and APIs, before Docker

* No standardized exchange format.
  <br/>(No, a rootfs tarball is *not* a format!)

* Containers are hard to use for developers.
  <br/>(Where's the equivalent of `docker run debian`?)

* As a result, they are *hidden* from the end users.

* No re-usable components, APIs, tools.
  <br/>(At best: VM abstractions, e.g. libvirt.)

Analogy: 

* Shipping containers are not just steel boxes.
* They are steel boxes that are a standard size, with the same hooks and holes.

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Formats and APIs, after Docker

* Standardize the container format, because containers were not portable.

* Make containers easy to use for developers.

* Emphasis on re-usable components, APIs, ecosystem of standard tools.

* Improvement over ad-hoc, in-house, specific tools.

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Shipping, before Docker

* Ship packages: deb, rpm, gem, jar, homebrew...

* Dependency hell.

* "Works on my machine."

* Base deployment often done from scratch (debootstrap...) and unreliable.

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Shipping, after Docker

* Ship container images with all their dependencies.

* Images are bigger, but they are broken down into layers.

* Only ship layers that have changed.

* Save disk, network, memory usage.

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Example

Layers:

* CentOS
* JRE
* Tomcat
* Dependencies
* Application JAR
* Configuration

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Devs vs Ops, before Docker

* Drop a tarball (or a commit hash) with instructions.

* Dev environment very different from production.

* Ops don't always have a dev environment themselves ...

* ... and when they do, it can differ from the devs'.

* Ops have to sort out differences and make it work ...

* ... or bounce it back to devs.

* Shipping code causes frictions and delays.

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Devs vs Ops, after Docker

* Drop a container image or a Compose file.

* Ops can always run that container image.

* Ops can always run that Compose file.

* Ops still have to adapt to prod environment,
  but at least they have a reference point.

* Ops have tools allowing to use the same image
  in dev and prod.

* Devs can be empowered to make releases themselves
  more easily.

.debug[[containers/Docker_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Overview.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-history-of-containers--and-docker
class: title

 History of containers ... and Docker

.nav[
[Previous part](#toc-docker-ft-overview)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-our-training-environment)
]

.debug[(automatically generated title slide)]

---
# History of containers ... and Docker

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## First experimentations

* [IBM VM/370 (1972)](https://en.wikipedia.org/wiki/VM_%28operating_system%29)

* [Linux VServers (2001)](http://www.solucorp.qc.ca/changes.hc?projet=vserver)

* [Solaris Containers (2004)](https://en.wikipedia.org/wiki/Solaris_Containers)

* [FreeBSD jails (1999-2000)](https://www.freebsd.org/cgi/man.cgi?query=jail&sektion=8&manpath=FreeBSD+4.0-RELEASE)

Containers have been around for a *very long time* indeed.

(See [this excellent blog post by Serge Hallyn](https://s3hh.wordpress.com/2018/03/22/history-of-containers/) for more historic details.)

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

class: pic

## The VPS age (until 2007-2008)

![lightcont](images/containers-as-lightweight-vms.png)

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## Containers = cheaper than VMs

* Users: hosting providers.

* Highly specialized audience with strong ops culture.

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

class: pic

## The PAAS period (2008-2013)

![heroku 2007](images/heroku-first-homepage.png)

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## Containers = easier than VMs

* I can't speak for Heroku, but containers were (one of) dotCloud's secret weapon

* dotCloud was operating a PaaS, using a custom container engine.

* This engine was based on OpenVZ (and later, LXC) and AUFS.

* It started (circa 2008) as a single Python script.

* By 2012, the engine had multiple (~10) Python components.
  <br/>(and ~100 other micro-services!)

* End of 2012, dotCloud refactors this container engine.

* The codename for this project is "Docker."

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## First public release of Docker

* March 2013, PyCon, Santa Clara:
  <br/>"Docker" is shown to a public audience for the first time.

* It is released with an open source license.

* Very positive reactions and feedback!

* The dotCloud team progressively shifts to Docker development.

* The same year, dotCloud changes name to Docker.

* In 2014, the PaaS activity is sold.

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## Docker early days (2013-2014)

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## First users of Docker

* PAAS builders (Flynn, Dokku, Tsuru, Deis...)

* PAAS users (those big enough to justify building their own)

* CI platforms

* developers, developers, developers, developers

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## Positive feedback loop

* In 2013, the technology under containers (cgroups, namespaces, copy-on-write storage...)
  had many blind spots.

* The growing popularity of Docker and containers exposed many bugs.

* As a result, those bugs were fixed, resulting in better stability for containers.

* Any decent hosting/cloud provider can run containers today.

* Containers become a great tool to deploy/move workloads to/from on-prem/cloud.

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## Maturity (2015-2016)

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## Docker becomes an industry standard

* Docker reaches the symbolic 1.0 milestone.

* Existing systems like Mesos and Cloud Foundry add Docker support.

* Standardization around the OCI (Open Containers Initiative).

* Other container engines are developed.

* Creation of the CNCF (Cloud Native Computing Foundation).

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

## Docker becomes a platform

* The initial container engine is now known as "Docker Engine."

* Other tools are added:
  * Docker Compose (formerly "Fig")
  * Docker Machine
  * Docker Swarm
  * Kitematic
  * Docker Cloud (formerly "Tutum")
  * Docker Datacenter
  * etc.

* Docker Inc. launches commercial offers.

.debug[[containers/Docker_History.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_History.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-our-training-environment
class: title

 Our training environment

.nav[
[Previous part](#toc-history-of-containers--and-docker)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-installing-docker)
]

.debug[(automatically generated title slide)]

---

class: title

# Our training environment

![SSH terminal](images/title-our-training-environment.jpg)

.debug[[containers/Training_Environment.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Training_Environment.md)]
---

## Our training environment

- If you are attending a tutorial or workshop:

  - a VM has been provisioned for each student

- If you are doing or re-doing this course on your own, you can:

  - install Docker locally (as explained in the chapter "Installing Docker")

  - install Docker on e.g. a cloud VM

  - use https://www.play-with-docker.com/ to instantly get a training environment

.debug[[containers/Training_Environment.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Training_Environment.md)]
---

## Our Docker VM

*This section assumes that you are following this course as part of
a tutorial, training or workshop, where each student is given an
individual Docker VM.*

- The VM is created just before the training.

- It will stay up during the whole training.

- It will be destroyed shortly after the training.

- It comes pre-loaded with Docker and some other useful tools.

.debug[[containers/Training_Environment.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Training_Environment.md)]
---

## What *is* Docker?

- "Installing Docker" really means "Installing the Docker Engine and CLI".

- The Docker Engine is a daemon (a service running in the background).

- This daemon manages containers, the same way that a hypervisor manages VMs.

- We interact with the Docker Engine by using the Docker CLI.

- The Docker CLI and the Docker Engine communicate through an API.

- There are many other programs and client libraries which use that API.

.debug[[containers/Training_Environment.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Training_Environment.md)]
---

## Why don't we run Docker locally?

- We are going to download container images and distribution packages.

- This could put a bit of stress on the local WiFi and slow us down.

- Instead, we use a remote VM that has a good connectivity

- In some rare cases, installing Docker locally is challenging:

  - no administrator/root access (computer managed by strict corp IT)

  - 32-bit CPU or OS

  - old OS version (e.g. CentOS 6, OSX pre-Yosemite, Windows 7)

- It's better to spend time learning containers than fiddling with the installer!

.debug[[containers/Training_Environment.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Training_Environment.md)]
---

## Connecting to your Virtual Machine

You need an SSH client.

* On OS X, Linux, and other UNIX systems, just use `ssh`:

```bash
$ ssh <login>@<ip-address>
```

* On Windows, if you don't have an SSH client, you can download:

  * Putty (www.putty.org)

  * Git BASH (https://git-for-windows.github.io/)

  * MobaXterm (https://mobaxterm.mobatek.net/)

.debug[[containers/Training_Environment.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Training_Environment.md)]
---

class: in-person

## `tailhist`

The shell history of the instructor is available online in real time.

Note the IP address of the instructor's virtual machine (A.B.C.D).

Open http://A.B.C.D:1088 in your browser and you should see the history.

The history is updated in real time (using a WebSocket connection).

It should be green when the WebSocket is connected.

If it turns red, reloading the page should fix it.

.debug[[containers/Training_Environment.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Training_Environment.md)]
---

## Checking your Virtual Machine

Once logged in, make sure that you can run a basic Docker command:

.small[
```bash
$ docker version
Client:
 Version:       18.03.0-ce
 API version:   1.37
 Go version:    go1.9.4
 Git commit:    0520e24
 Built:         Wed Mar 21 23:10:06 2018
 OS/Arch:       linux/amd64
 Experimental:  false
 Orchestrator:  swarm

Server:
 Engine:
  Version:      18.03.0-ce
  API version:  1.37 (minimum version 1.12)
  Go version:   go1.9.4
  Git commit:   0520e24
  Built:        Wed Mar 21 23:08:35 2018
  OS/Arch:      linux/amd64
  Experimental: false
```
]

If this doesn't work, raise your hand so that an instructor can assist you!

???

:EN:Container concepts
:FR:Premier contact avec les conteneurs

:EN:- What's a container engine?
:FR:- Qu'est-ce qu'un *container engine* ?

.debug[[containers/Training_Environment.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Training_Environment.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-installing-docker
class: title

 Installing Docker

.nav[
[Previous part](#toc-our-training-environment)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-our-first-containers)
]

.debug[(automatically generated title slide)]

---

class: title

# Installing Docker

![install](images/title-installing-docker.jpg)

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

## Objectives

At the end of this lesson, you will know:

* How to install Docker.

* When to use `sudo` when running Docker commands.

*Note:* if you were provided with a training VM for a hands-on
tutorial, you can skip this chapter, since that VM already
has Docker installed, and Docker has already been setup to run
without `sudo`.

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

## Installing Docker

There are many ways to install Docker.

We can arbitrarily distinguish:

* Installing Docker on an existing Linux machine (physical or VM)

* Installing Docker on macOS or Windows

* Installing Docker on a fleet of cloud VMs

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

## Installing Docker on Linux

* The recommended method is to install the packages supplied by Docker Inc :

  - add Docker Inc.'s package repositories to your system configuration

  - install the Docker Engine

* Detailed installation instructions (distro by distro) are available on:

  https://docs.docker.com/engine/installation/

* You can also install from binaries (if your distro is not supported):

  https://docs.docker.com/engine/installation/linux/docker-ce/binaries/

* To quickly setup a dev environment, Docker provides a convenience install script:

  ```bash
  curl -fsSL get.docker.com | sh
  ```

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

class: extra-details

## Docker Inc. packages vs distribution packages

* Docker Inc. releases new versions monthly (edge) and quarterly (stable)

* Releases are immediately available on Docker Inc.'s package repositories

* Linux distros don't always update to the latest Docker version

  (Sometimes, updating would break their guidelines for major/minor upgrades)

* Sometimes, some distros have carried packages with custom patches

* Sometimes, these patches added critical security bugs ☹

* Installing through Docker Inc.'s repositories is a bit of extra work …

  … but it is generally worth it!

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

## Installing Docker on macOS and Windows

* On macOS, the recommended method is to use Docker Desktop for Mac:

  https://docs.docker.com/docker-for-mac/install/

* On Windows 10 Pro, Enterprise, and Education, you can use Docker Desktop for Windows:

  https://docs.docker.com/docker-for-windows/install/

* On older versions of Windows, you can use the Docker Toolbox:

  https://docs.docker.com/toolbox/toolbox_install_windows/

* On Windows Server 2016, you can also install the native engine:

  https://docs.docker.com/install/windows/docker-ee/

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

## Docker Desktop

* Special Docker edition available for Mac and Windows

* Integrates well with the host OS:

  * installed like normal user applications on the host

  * provides user-friendly GUI to edit Docker configuration and settings

* Only support running one Docker VM at a time ...

  ... but we can use `docker-machine`, the Docker Toolbox, VirtualBox, etc. to get a cluster.

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

class: extra-details

## Docker Desktop internals

* Leverages the host OS virtualization subsystem

  (e.g. the [Hypervisor API](https://developer.apple.com/documentation/hypervisor) on macOS)

* Under the hood, runs a tiny VM

  (transparent to our daily use)

* Accesses network resources like normal applications

  (and therefore, plays better with enterprise VPNs and firewalls)

* Supports filesystem sharing through volumes

  (we'll talk about this later)

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

## Running Docker on macOS and Windows

When you execute `docker version` from the terminal:

* the CLI connects to the Docker Engine over a standard socket,
* the Docker Engine is, in fact, running in a VM,
* ... but the CLI doesn't know or care about that,
* the CLI sends a request using the REST API,
* the Docker Engine in the VM processes the request,
* the CLI gets the response and displays it to you.

All communication with the Docker Engine happens over the API.

This will also allow to use remote Engines exactly as if they were local.

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

## Important PSA about security

* If you have access to the Docker control socket, you can take over the machine

  (Because you can run containers that will access the machine's resources)

* Therefore, on Linux machines, the `docker` user is equivalent to `root`

* You should restrict access to it like you would protect `root`

* By default, the Docker control socket belongs to the `docker` group

* You can add trusted users to the `docker` group

* Otherwise, you will have to prefix every `docker` command with `sudo`, e.g.:

  ```bash
  sudo docker version
  ```

.debug[[containers/Installing_Docker.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Installing_Docker.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-our-first-containers
class: title

 Our first containers

.nav[
[Previous part](#toc-installing-docker)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-background-containers)
]

.debug[(automatically generated title slide)]

---

class: title

# Our first containers

![Colorful plastic tubs](images/title-our-first-containers.jpg)

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Objectives

At the end of this lesson, you will have:

* Seen Docker in action.

* Started your first containers.

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Hello World

In your Docker environment, just run the following command:

```bash
$ docker run busybox echo hello world
hello world
```

(If your Docker install is brand new, you will also see a few extra lines,
corresponding to the download of the `busybox` image.)

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## That was our first container!

* We used one of the smallest, simplest images available: `busybox`.

* `busybox` is typically used in embedded systems (phones, routers...)

* We ran a single process and echo'ed `hello world`.

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## A more useful container

Let's run a more exciting container:

```bash
$ docker run -it ubuntu
root@04c0bb0a6c07:/#
```

* This is a brand new container.

* It runs a bare-bones, no-frills `ubuntu` system.

* `-it` is shorthand for `-i -t`.

  * `-i` tells Docker to connect us to the container's stdin.

  * `-t` tells Docker that we want a pseudo-terminal.

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Do something in our container

Try to run `figlet` in our container.

```bash
root@04c0bb0a6c07:/# figlet hello
bash: figlet: command not found
```

Alright, we need to install it.

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Install a package in our container

We want `figlet`, so let's install it:

```bash
root@04c0bb0a6c07:/# apt-get update
...
Fetched 1514 kB in 14s (103 kB/s)
Reading package lists... Done
root@04c0bb0a6c07:/# apt-get install figlet
Reading package lists... Done
...
```

One minute later, `figlet` is installed!

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Try to run our freshly installed program

The `figlet` program takes a message as parameter.

```bash
root@04c0bb0a6c07:/# figlet hello
 _          _ _       
| |__   ___| | | ___  
| '_ \ / _ \ | |/ _ \ 
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/ 
```

Beautiful! 😍

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

class: in-person

## Counting packages in the container

Let's check how many packages are installed there.

```bash
root@04c0bb0a6c07:/# dpkg -l | wc -l
97
```

* `dpkg -l` lists the packages installed in our container

* `wc -l` counts them

How many packages do we have on our host?

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

class: in-person

## Counting packages on the host

Exit the container by logging out of the shell, like you would usually do.

(E.g. with `^D` or `exit`)

```bash
root@04c0bb0a6c07:/# exit
```

Now, try to:

* run `dpkg -l | wc -l`. How many packages are installed?

* run `figlet`. Does that work?

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

class: self-paced

## Comparing the container and the host

Exit the container by logging out of the shell, with `^D` or `exit`.

Now try to run `figlet`. Does that work?

(It shouldn't; except if, by coincidence, you are running on a machine where figlet was installed before.)

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Host and containers are independent things

* We ran an `ubuntu` container on an Linux/Windows/macOS host.

* They have different, independent packages.

* Installing something on the host doesn't expose it to the container.

* And vice-versa.

* Even if both the host and the container have the same Linux distro!

* We can run *any container* on *any host*.

  (One exception: Windows containers can only run on Windows hosts; at least for now.)

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Where's our container?

* Our container is now in a *stopped* state.

* It still exists on disk, but all compute resources have been freed up.

* We will see later how to get back to that container.

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Starting another container

What if we start a new container, and try to run `figlet` again?
 
```bash
$ docker run -it ubuntu
root@b13c164401fb:/# figlet
bash: figlet: command not found
```

* We started a *brand new container*.

* The basic Ubuntu image was used, and `figlet` is not here.

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Where's my container?

* Can we reuse that container that we took time to customize?

  *We can, but that's not the default workflow with Docker.*

* What's the default workflow, then?

  *Always start with a fresh container.*
  <br/>
  *If we need something installed in our container, build a custom image.*

* That seems complicated!

  *We'll see that it's actually pretty easy!*

* And what's the point?

  *This puts a strong emphasis on automation and repeatability. Let's see why ...*

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Pets vs. Cattle

* In the "pets vs. cattle" metaphor, there are two kinds of servers.

* Pets:

  * have distinctive names and unique configurations

  * when they have an outage, we do everything we can to fix them

* Cattle:

  * have generic names (e.g. with numbers) and generic configuration

  * configuration is enforced by configuration management, golden images ...

  * when they have an outage, we can replace them immediately with a new server

* What's the connection with Docker and containers?

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Local development environments

* When we use local VMs (with e.g. VirtualBox or VMware), our workflow looks like this:

  * create VM from base template (Ubuntu, CentOS...)

  * install packages, set up environment

  * work on project

  * when done, shut down VM

  * next time we need to work on project, restart VM as we left it

  * if we need to tweak the environment, we do it live

* Over time, the VM configuration evolves, diverges.

* We don't have a clean, reliable, deterministic way to provision that environment.

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

## Local development with Docker

* With Docker, the workflow looks like this:

  * create container image with our dev environment

  * run container with that image

  * work on project

  * when done, shut down container

  * next time we need to work on project, start a new container

  * if we need to tweak the environment, we create a new image

* We have a clear definition of our environment, and can share it reliably with others.

* Let's see in the next chapters how to bake a custom image with `figlet`!

???

:EN:- Running our first container
:FR:- Lancer nos premiers conteneurs

.debug[[containers/First_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/First_Containers.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-background-containers
class: title

 Background containers

.nav[
[Previous part](#toc-our-first-containers)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-restarting-and-attaching-to-containers)
]

.debug[(automatically generated title slide)]

---

class: title

# Background containers

![Background containers](images/title-background-containers.jpg)

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Objectives

Our first containers were *interactive*.

We will now see how to:

* Run a non-interactive container.
* Run a container in the background.
* List running containers.
* Check the logs of a container.
* Stop a container.
* List stopped containers.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## A non-interactive container

We will run a small custom container.

This container just displays the time every second.

```bash
$ docker run jpetazzo/clock
Fri Feb 20 00:28:53 UTC 2015
Fri Feb 20 00:28:54 UTC 2015
Fri Feb 20 00:28:55 UTC 2015
...
```

* This container will run forever.
* To stop it, press `^C`.
* Docker has automatically downloaded the image `jpetazzo/clock`.
* This image is a user image, created by `jpetazzo`.
* We will hear more about user images (and other types of images) later.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## When `^C` doesn't work...

Sometimes, `^C` won't be enough.

Why? And how can we stop the container in that case?

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## What happens when we hit `^C`

`SIGINT` gets sent to the container, which means:

- `SIGINT` gets sent to PID 1 (default case)

- `SIGINT` gets sent to *foreground processes* when running with `-ti`

But there is a special case for PID 1: it ignores all signals!

- except `SIGKILL` and `SIGSTOP`

- except signals handled explicitly

TL,DR: there are many circumstances when `^C` won't stop the container.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

class: extra-details

## Why is PID 1 special?

- PID 1 has some extra responsibilities:

  - it starts (directly or indirectly) every other process

  - when a process exits, its processes are "reparented" under PID 1

- When PID 1 exits, everything stops:

  - on a "regular" machine, it causes a kernel panic

  - in a container, it kills all the processes

- We don't want PID 1 to stop accidentally

- That's why it has these extra protections

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## How to stop these containers, then?

- Start another terminal and forget about them

  (for now!)

- We'll shortly learn about `docker kill`

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Run a container in the background

Containers can be started in the background, with the `-d` flag (daemon mode):

```bash
$ docker run -d jpetazzo/clock
47d677dcfba4277c6cc68fcaa51f932b544cab1a187c853b7d0caf4e8debe5ad
```

* We don't see the output of the container.
* But don't worry: Docker collects that output and logs it!
* Docker gives us the ID of the container.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## List running containers

How can we check that our container is still running?

With `docker ps`, just like the UNIX `ps` command, lists running processes.

```bash
$ docker ps
CONTAINER ID  IMAGE           ...  CREATED        STATUS        ...
47d677dcfba4  jpetazzo/clock  ...  2 minutes ago  Up 2 minutes  ...
```

Docker tells us:

* The (truncated) ID of our container.
* The image used to start the container.
* That our container has been running (`Up`) for a couple of minutes.
* Other information (COMMAND, PORTS, NAMES) that we will explain later.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Starting more containers

Let's start two more containers.

```bash
$ docker run -d jpetazzo/clock
57ad9bdfc06bb4407c47220cf59ce21585dce9a1298d7a67488359aeaea8ae2a
```

```bash
$ docker run -d jpetazzo/clock
068cc994ffd0190bbe025ba74e4c0771a5d8f14734af772ddee8dc1aaf20567d
```

Check that `docker ps` correctly reports all 3 containers.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Viewing only the last container started

When many containers are already running, it can be useful to
see only the last container that was started.

This can be achieved with the `-l` ("Last") flag:

```bash
$ docker ps -l
CONTAINER ID  IMAGE           ...  CREATED        STATUS        ...
068cc994ffd0  jpetazzo/clock  ...  2 minutes ago  Up 2 minutes  ...
```

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## View only the IDs of the containers

Many Docker commands will work on container IDs: `docker stop`, `docker rm`...

If we want to list only the IDs of our containers (without the other columns
or the header line),
we can use the `-q` ("Quiet", "Quick") flag:

```bash
$ docker ps -q
068cc994ffd0
57ad9bdfc06b
47d677dcfba4
```

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Combining flags

We can combine `-l` and `-q` to see only the ID of the last container started:

```bash
$ docker ps -lq
068cc994ffd0
```

At a first glance, it looks like this would be particularly useful in scripts.

However, if we want to start a container and get its ID in a reliable way,
it is better to use `docker run -d`, which we will cover in a bit.

(Using `docker ps -lq` is prone to race conditions: what happens if someone
else, or another program or script, starts another container just before
we run `docker ps -lq`?)

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## View the logs of a container

We told you that Docker was logging the container output.

Let's see that now.

```bash
$ docker logs 068
Fri Feb 20 00:39:52 UTC 2015
Fri Feb 20 00:39:53 UTC 2015
...
```

* We specified a *prefix* of the full container ID.
* You can, of course, specify the full ID.
* The `logs` command will output the *entire* logs of the container.
  <br/>(Sometimes, that will be too much. Let's see how to address that.)

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## View only the tail of the logs

To avoid being spammed with eleventy pages of output,
we can use the `--tail` option:

```bash
$ docker logs --tail 3 068
Fri Feb 20 00:55:35 UTC 2015
Fri Feb 20 00:55:36 UTC 2015
Fri Feb 20 00:55:37 UTC 2015
```

* The parameter is the number of lines that we want to see.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Follow the logs in real time

Just like with the standard UNIX command `tail -f`, we can
follow the logs of our container:

```bash
$ docker logs --tail 1 --follow 068
Fri Feb 20 00:57:12 UTC 2015
Fri Feb 20 00:57:13 UTC 2015
^C
```

* This will display the last line in the log file.
* Then, it will continue to display the logs in real time.
* Use `^C` to exit.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Stop our container

There are two ways we can terminate our detached container.

* Killing it using the `docker kill` command.
* Stopping it using the `docker stop` command.

The first one stops the container immediately, by using the
`KILL` signal.

The second one is more graceful. It sends a `TERM` signal,
and after 10 seconds, if the container has not stopped, it
sends `KILL.`

Reminder: the `KILL` signal cannot be intercepted, and will
forcibly terminate the container.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Stopping our containers

Let's stop one of those containers:

```bash
$ docker stop 47d6
47d6
```

This will take 10 seconds:

* Docker sends the TERM signal;
* the container doesn't react to this signal
  (it's a simple Shell script with no special
  signal handling);
* 10 seconds later, since the container is still
  running, Docker sends the KILL signal;
* this terminates the container.

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## Killing the remaining containers

Let's be less patient with the two other containers:

```bash
$ docker kill 068 57ad
068
57ad
```

The `stop` and `kill` commands can take multiple container IDs.

Those containers will be terminated immediately (without
the 10-second delay).

Let's check that our containers don't show up anymore:

```bash
$ docker ps
```

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

## List stopped containers

We can also see stopped containers, with the `-a` (`--all`) option.

```bash
$ docker ps -a
CONTAINER ID  IMAGE           ...  CREATED      STATUS
068cc994ffd0  jpetazzo/clock  ...  21 min. ago  Exited (137) 3 min. ago
57ad9bdfc06b  jpetazzo/clock  ...  21 min. ago  Exited (137) 3 min. ago
47d677dcfba4  jpetazzo/clock  ...  23 min. ago  Exited (137) 3 min. ago
5c1dfd4d81f1  jpetazzo/clock  ...  40 min. ago  Exited (0) 40 min. ago
b13c164401fb  ubuntu          ...  55 min. ago  Exited (130) 53 min. ago
```

???

:EN:- Foreground and background containers
:FR:- Exécution interactive ou en arrière-plan

.debug[[containers/Background_Containers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Background_Containers.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-restarting-and-attaching-to-containers
class: title

 Restarting and attaching to containers

.nav[
[Previous part](#toc-background-containers)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-naming-and-inspecting-containers)
]

.debug[(automatically generated title slide)]

---
# Restarting and attaching to containers

We have started containers in the foreground, and in the background.

In this chapter, we will see how to:

* Put a container in the background.
* Attach to a background container to bring it to the foreground.
* Restart a stopped container.

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

## Background and foreground

The distinction between foreground and background containers is arbitrary.

From Docker's point of view, all containers are the same.

All containers run the same way, whether there is a client attached to them or not.

It is always possible to detach from a container, and to reattach to a container.

Analogy: attaching to a container is like plugging a keyboard and screen to a physical server.

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

## Detaching from a container (Linux/macOS)

* If you have started an *interactive* container (with option `-it`), you can detach from it.

* The "detach" sequence is `^P^Q`.

* Otherwise you can detach by killing the Docker client.
  
  (But not by hitting `^C`, as this would deliver `SIGINT` to the container.)

What does `-it` stand for?

* `-t` means "allocate a terminal."
* `-i` means "connect stdin to the terminal."

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

## Detaching cont. (Win PowerShell and cmd.exe)

* Docker for Windows has a different detach experience due to shell features.

* `^P^Q` does not work.

* `^C` will detach, rather than stop the container.

* Using Bash, Subsystem for Linux, etc. on Windows behaves like Linux/macOS shells.

* Both PowerShell and Bash work well in Win 10; just be aware of differences.

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

class: extra-details

## Specifying a custom detach sequence

* You don't like `^P^Q`? No problem!
* You can change the sequence with `docker run --detach-keys`.
* This can also be passed as a global option to the engine.

Start a container with a custom detach command:

```bash
$ docker run -ti --detach-keys ctrl-x,x jpetazzo/clock
```

Detach by hitting `^X x`. (This is ctrl-x then x, not ctrl-x twice!)

Check that our container is still running:

```bash
$ docker ps -l
```

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

class: extra-details

## Attaching to a container

You can attach to a container:

```bash
$ docker attach <containerID>
```

* The container must be running.
* There *can* be multiple clients attached to the same container.
* If you don't specify `--detach-keys` when attaching, it defaults back to `^P^Q`.

Try it on our previous container:

```bash
$ docker attach $(docker ps -lq)
```

Check that `^X x` doesn't work, but `^P ^Q` does.

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

## Detaching from non-interactive containers

* **Warning:** if the container was started without `-it`...

  * You won't be able to detach with `^P^Q`.
  * If you hit `^C`, the signal will be proxied to the container.

* Remember: you can always detach by killing the Docker client.

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

## Checking container output

* Use `docker attach` if you intend to send input to the container.

* If you just want to see the output of a container, use `docker logs`.

```bash
$ docker logs --tail 1 --follow <containerID>
```

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

## Restarting a container

When a container has exited, it is in stopped state.

It can then be restarted with the `start` command.

```bash
$ docker start <yourContainerID>
```

The container will be restarted using the same options you launched it
with.

You can re-attach to it if you want to interact with it:

```bash
$ docker attach <yourContainerID>
```

Use `docker ps -a` to identify the container ID of a previous `jpetazzo/clock` container,
and try those commands.

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

## Attaching to a REPL

* REPL = Read Eval Print Loop

* Shells, interpreters, TUI ...

* Symptom: you `docker attach`, and see nothing

* The REPL doesn't know that you just attached, and doesn't print anything

* Try hitting `^L` or `Enter`

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

class: extra-details

## SIGWINCH

* When you `docker attach`, the Docker Engine sends SIGWINCH signals to the container.

* SIGWINCH = WINdow CHange; indicates a change in window size.

* This will cause some CLI and TUI programs to redraw the screen.

* But not all of them.

???

:EN:- Restarting old containers
:EN:- Detaching and reattaching to container
:FR:- Redémarrer des anciens conteneurs
:FR:- Se détacher et rattacher à des conteneurs

.debug[[containers/Start_And_Attach.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Start_And_Attach.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-naming-and-inspecting-containers
class: title

 Naming and inspecting containers

.nav[
[Previous part](#toc-restarting-and-attaching-to-containers)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-labels)
]

.debug[(automatically generated title slide)]

---

class: title

# Naming and inspecting containers

![Markings on container door](images/title-naming-and-inspecting-containers.jpg)

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

## Objectives

In this lesson, we will learn about an important
Docker concept: container *naming*.

Naming allows us to:

* Reference easily a container.

* Ensure unicity of a specific container.

We will also see the `inspect` command, which gives a lot of details about a container.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

## Naming our containers

So far, we have referenced containers with their ID.

We have copy-pasted the ID, or used a shortened prefix.

But each container can also be referenced by its name.

If a container is named `thumbnail-worker`, I can do:

```bash
$ docker logs thumbnail-worker
$ docker stop thumbnail-worker
etc.
```

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

## Default names

When we create a container, if we don't give a specific
name, Docker will pick one for us.

It will be the concatenation of:

* A mood (furious, goofy, suspicious, boring...)

* The name of a famous inventor (tesla, darwin, wozniak...)

Examples: `happy_curie`, `clever_hopper`, `jovial_lovelace` ...

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

## Specifying a name

You can set the name of the container when you create it.

```bash
$ docker run --name ticktock jpetazzo/clock
```

If you specify a name that already exists, Docker will refuse
to create the container.

This lets us enforce unicity of a given resource.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

## Renaming containers

* You can rename containers with `docker rename`.

* This allows you to "free up" a name without destroying the associated container.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

## Inspecting a container

The `docker inspect` command will output a very detailed JSON map.

```bash
$ docker inspect <containerID>
[{
...
(many pages of JSON here)
...
```

There are multiple ways to consume that information.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

## Parsing JSON with the Shell

* You *could* grep and cut or awk the output of `docker inspect`.

* Please, don't.

* It's painful.

* If you really must parse JSON from the Shell, use JQ! (It's great.)

```bash
$ docker inspect <containerID> | jq .
```

* We will see a better solution which doesn't require extra tools.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

## Using `--format`

You can specify a format string, which will be parsed by 
Go's text/template package.

```bash
$ docker inspect --format '{{ json .Created }}' <containerID>
"2015-02-24T07:21:11.712240394Z"
```

* The generic syntax is to wrap the expression with double curly braces.

* The expression starts with a dot representing the JSON object.

* Then each field or member can be accessed in dotted notation syntax.

* The optional `json` keyword asks for valid JSON output.
  <br/>(e.g. here it adds the surrounding double-quotes.)

???

:EN:Managing container lifecycle
:EN:- Naming and inspecting containers

:FR:Suivre ses conteneurs à la loupe
:FR:- Obtenir des informations détaillées sur un conteneur
:FR:- Associer un identifiant unique à un conteneur

.debug[[containers/Naming_And_Inspecting.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Naming_And_Inspecting.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-labels
class: title

 Labels

.nav[
[Previous part](#toc-naming-and-inspecting-containers)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-getting-inside-a-container)
]

.debug[(automatically generated title slide)]

---
# Labels

* Labels allow to attach arbitrary metadata to containers.

* Labels are key/value pairs.

* They are specified at container creation.

* You can query them with `docker inspect`.

* They can also be used as filters with some commands (e.g. `docker ps`).

.debug[[containers/Labels.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Labels.md)]
---

## Using labels

Let's create a few containers with a label `owner`.

```bash
docker run -d -l owner=alice nginx
docker run -d -l owner=bob nginx
docker run -d -l owner nginx
```

We didn't specify a value for the `owner` label in the last example.

This is equivalent to setting the value to be an empty string.

.debug[[containers/Labels.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Labels.md)]
---

## Querying labels

We can view the labels with `docker inspect`.

```bash
$ docker inspect $(docker ps -lq) | grep -A3 Labels
            "Labels": {
                "maintainer": "NGINX Docker Maintainers <docker-maint@nginx.com>",
                "owner": ""
            },
```

We can use the `--format` flag to list the value of a label.

```bash
$ docker inspect $(docker ps -q) --format 'OWNER={{.Config.Labels.owner}}'
```

.debug[[containers/Labels.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Labels.md)]
---

## Using labels to select containers

We can list containers having a specific label.

```bash
$ docker ps --filter label=owner
```

Or we can list containers having a specific label with a specific value.

```bash
$ docker ps --filter label=owner=alice
```

.debug[[containers/Labels.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Labels.md)]
---

## Use-cases for labels


* HTTP vhost of a web app or web service.

  (The label is used to generate the configuration for NGINX, HAProxy, etc.)

* Backup schedule for a stateful service.

  (The label is used by a cron job to determine if/when to backup container data.)

* Service ownership.

  (To determine internal cross-billing, or who to page in case of outage.)

* etc.

???

:EN:- Using labels to identify containers
:FR:- Étiqueter ses conteneurs avec des méta-données

.debug[[containers/Labels.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Labels.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-getting-inside-a-container
class: title

 Getting inside a container

.nav[
[Previous part](#toc-labels)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-understanding-docker-images)
]

.debug[(automatically generated title slide)]

---

class: title

# Getting inside a container

![Person standing inside a container](images/getting-inside.png)

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Objectives

On a traditional server or VM, we sometimes need to:

* log into the machine (with SSH or on the console),

* analyze the disks (by removing them or rebooting with a rescue system).

In this chapter, we will see how to do that with containers.

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Getting a shell

Every once in a while, we want to log into a machine.

In an perfect world, this shouldn't be necessary.

* You need to install or update packages (and their configuration)?

  Use configuration management. (e.g. Ansible, Chef, Puppet, Salt...)

* You need to view logs and metrics?

  Collect and access them through a centralized platform.

In the real world, though ... we often need shell access!

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Not getting a shell

Even without a perfect deployment system, we can do many operations without getting a shell.

* Installing packages can (and should) be done in the container image.

* Configuration can be done at the image level, or when the container starts.

* Dynamic configuration can be stored in a volume (shared with another container).

* Logs written to stdout are automatically collected by the Docker Engine.

* Other logs can be written to a shared volume.

* Process information and metrics are visible from the host.

_Let's save logging, volumes ... for later, but let's have a look at process information!_

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Viewing container processes from the host

If you run Docker on Linux, container processes are visible on the host.

```bash
$ ps faux | less
```

* Scroll around the output of this command.

* You should see the `jpetazzo/clock` container.

* A containerized process is just like any other process on the host.

* We can use tools like `lsof`, `strace`, `gdb` ... To analyze them.

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

class: extra-details

## What's the difference between a container process and a host process?

* Each process (containerized or not) belongs to *namespaces* and *cgroups*.

* The namespaces and cgroups determine what a process can "see" and "do".

* Analogy: each process (containerized or not) runs with a specific UID (user ID).

* UID=0 is root, and has elevated privileges. Other UIDs are normal users.

_We will give more details about namespaces and cgroups later._

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Getting a shell in a running container

* Sometimes, we need to get a shell anyway.

* We _could_ run some SSH server in the container ...

* But it is easier to use `docker exec`.

```bash
$ docker exec -ti ticktock sh
```

* This creates a new process (running `sh`) _inside_ the container.

* This can also be done "manually" with the tool `nsenter`.

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Caveats

* The tool that you want to run needs to exist in the container.

* Some tools (like `ip netns exec`) let you attach to _one_ namespace at a time.

  (This lets you e.g. setup network interfaces, even if you don't have `ifconfig` or `ip` in the container.)

* Most importantly: the container needs to be running.

* What if the container is stopped or crashed?

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Getting a shell in a stopped container

* A stopped container is only _storage_ (like a disk drive).

* We cannot SSH into a disk drive or USB stick!

* We need to connect the disk to a running machine.

* How does that translate into the container world?

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Analyzing a stopped container

As an exercise, we are going to try to find out what's wrong with `jpetazzo/crashtest`.

```bash
docker run jpetazzo/crashtest
```

The container starts, but then stops immediately, without any output.

What would MacGyver&trade; do?

First, let's check the status of that container.

```bash
docker ps -l
```

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Viewing filesystem changes

* We can use `docker diff` to see files that were added / changed / removed.

```bash
docker diff <container_id>
```

* The container ID was shown by `docker ps -l`.

* We can also see it with `docker ps -lq`.

* The output of `docker diff` shows some interesting log files!

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Accessing files

* We can extract files with `docker cp`.

```bash
docker cp <container_id>:/var/log/nginx/error.log .
```

* Then we can look at that log file.

```bash
cat error.log
```

(The directory `/run/nginx` doesn't exist.)

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

## Exploring a crashed container

* We can restart a container with `docker start` ...

* ... But it will probably crash again immediately!

* We cannot specify a different program to run with `docker start`

* But we can create a new image from the crashed container

```bash
docker commit <container_id> debugimage
```

* Then we can run a new container from that image, with a custom entrypoint

```bash
docker run -ti --entrypoint sh debugimage
```

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

class: extra-details

## Obtaining a complete dump

* We can also dump the entire filesystem of a container.

* This is done with `docker export`.

* It generates a tar archive.

```bash
docker export <container_id> | tar tv
```

This will give a detailed listing of the content of the container.

???

:EN:- Troubleshooting and getting inside a container
:FR:- Inspecter un conteneur en détail, en *live* ou *post-mortem*

.debug[[containers/Getting_Inside.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Getting_Inside.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-understanding-docker-images
class: title

 Understanding Docker images

.nav[
[Previous part](#toc-getting-inside-a-container)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-building-images-interactively)
]

.debug[(automatically generated title slide)]

---

class: title

# Understanding Docker images

![image](images/title-understanding-docker-images.png)

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Objectives

In this section, we will explain:

* What is an image.

* What is a layer.

* The various image namespaces.

* How to search and download images.

* Image tags and when to use them.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## What is an image?

* Image = files + metadata

* These files form the root filesystem of our container.

* The metadata can indicate a number of things, e.g.:

  * the author of the image
  * the command to execute in the container when starting it
  * environment variables to be set
  * etc.

* Images are made of *layers*, conceptually stacked on top of each other.

* Each layer can add, change, and remove files and/or metadata.

* Images can share layers to optimize disk usage, transfer times, and memory use.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Example for a Java webapp

Each of the following items will correspond to one layer:

* CentOS base layer
* Packages and configuration files added by our local IT
* JRE
* Tomcat
* Our application's dependencies
* Our application code and assets
* Our application configuration

(Note: app config is generally added by orchestration facilities.)

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

class: pic

## The read-write layer

![layers](images/container-layers.jpg)

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Differences between containers and images

* An image is a read-only filesystem.

* A container is an encapsulated set of processes,

  running in a read-write copy of that filesystem.

* To optimize container boot time, *copy-on-write* is used
  instead of regular copy.

* `docker run` starts a container from a given image.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

class: pic

## Multiple containers sharing the same image

![layers](images/sharing-layers.jpg)

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Comparison with object-oriented programming

* Images are conceptually similar to *classes*.

* Layers are conceptually similar to *inheritance*.

* Containers are conceptually similar to *instances*.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Wait a minute...

If an image is read-only, how do we change it?

* We don't.

* We create a new container from that image.

* Then we make changes to that container.

* When we are satisfied with those changes, we transform them into a new layer.

* A new image is created by stacking the new layer on top of the old image.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## A chicken-and-egg problem

* The only way to create an image is by "freezing" a container.

* The only way to create a container is by instantiating an image.

* Help!

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Creating the first images

There is a special empty image called `scratch`.

* It allows to *build from scratch*.

The `docker import` command loads a tarball into Docker.

* The imported tarball becomes a standalone image.
* That new image has a single layer.

Note: you will probably never have to do this yourself.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Creating other images

`docker commit`

* Saves all the changes made to a container into a new layer.
* Creates a new image (effectively a copy of the container).

`docker build` **(used 99% of the time)**

* Performs a repeatable build sequence.
* This is the preferred method!

We will explain both methods in a moment.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Images namespaces

There are three namespaces:

* Official images

    e.g. `ubuntu`, `busybox` ...

* User (and organizations) images

    e.g. `jpetazzo/clock`

* Self-hosted images

    e.g. `registry.example.com:5000/my-private/image`

Let's explain each of them.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Root namespace

The root namespace is for official images.

They are gated by Docker Inc.

They are generally authored and maintained by third parties.

Those images include:

* Small, "swiss-army-knife" images like busybox.

* Distro images to be used as bases for your builds, like ubuntu, fedora...

* Ready-to-use components and services, like redis, postgresql...

* Over 150 at this point!

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## User namespace

The user namespace holds images for Docker Hub users and organizations.

For example:

```bash
jpetazzo/clock
```

The Docker Hub user is:

```bash
jpetazzo
```

The image name is:

```bash
clock
```

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Self-hosted namespace

This namespace holds images which are not hosted on Docker Hub, but on third
party registries.

They contain the hostname (or IP address), and optionally the port, of the
registry server.

For example:

```bash
localhost:5000/wordpress
```

* `localhost:5000` is the host and port of the registry
* `wordpress` is the name of the image

Other examples:

```bash
quay.io/coreos/etcd
gcr.io/google-containers/hugo
```

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## How do you store and manage images?

Images can be stored:

* On your Docker host.
* In a Docker registry.

You can use the Docker client to download (pull) or upload (push) images.

To be more accurate: you can use the Docker client to tell a Docker Engine
to push and pull images to and from a registry.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Showing current images

Let's look at what images are on our host now.

```bash
$ docker images
REPOSITORY       TAG       IMAGE ID       CREATED         SIZE
fedora           latest    ddd5c9c1d0f2   3 days ago      204.7 MB
centos           latest    d0e7f81ca65c   3 days ago      196.6 MB
ubuntu           latest    07c86167cdc4   4 days ago      188 MB
redis            latest    4f5f397d4b7c   5 days ago      177.6 MB
postgres         latest    afe2b5e1859b   5 days ago      264.5 MB
alpine           latest    70c557e50ed6   5 days ago      4.798 MB
debian           latest    f50f9524513f   6 days ago      125.1 MB
busybox          latest    3240943c9ea3   2 weeks ago     1.114 MB
training/namer   latest    902673acc741   9 months ago    289.3 MB
jpetazzo/clock   latest    12068b93616f   12 months ago   2.433 MB
```

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Searching for images

We cannot list *all* images on a remote registry, but
we can search for a specific keyword:

```bash
$ docker search marathon
NAME                     DESCRIPTION                     STARS  OFFICIAL  AUTOMATED
mesosphere/marathon      A cluster-wide init and co...   105              [OK]
mesoscloud/marathon      Marathon                        31               [OK]
mesosphere/marathon-lb   Script to update haproxy b...   22               [OK]
tobilg/mongodb-marathon  A Docker image to start a ...   4                [OK]
```


* "Stars" indicate the popularity of the image.

* "Official" images are those in the root namespace.

* "Automated" images are built automatically by the Docker Hub.
  <br/>(This means that their build recipe is always available.)

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Downloading images

There are two ways to download images.

* Explicitly, with `docker pull`.

* Implicitly, when executing `docker run` and the image is not found locally.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Pulling an image

```bash
$ docker pull debian:jessie
Pulling repository debian
b164861940b8: Download complete
b164861940b8: Pulling image (jessie) from debian
d1881793a057: Download complete
```

* As seen previously, images are made up of layers.

* Docker has downloaded all the necessary layers.

* In this example, `:jessie` indicates which exact version of Debian
  we would like.

  It is a *version tag*.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Image and tags

* Images can have tags.

* Tags define image versions or variants.

* `docker pull ubuntu` will refer to `ubuntu:latest`.

* The `:latest` tag is generally updated often.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## When to (not) use tags

Don't specify tags:

* When doing rapid testing and prototyping.
* When experimenting.
* When you want the latest version.

Do specify tags:

* When recording a procedure into a script.
* When going to production.
* To ensure that the same version will be used everywhere.
* To ensure repeatability later.

This is similar to what we would do with `pip install`, `npm install`, etc.

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

class: extra-details

## Multi-arch images

- An image can support multiple architectures

- More precisely, a specific *tag* in a given *repository* can have either:

  - a single *manifest* referencing an image for a single architecture

  - a *manifest list* (or *fat manifest*) referencing multiple images

- In a *manifest list*, each image is identified by a combination of:

  - `os` (linux, windows)

  - `architecture` (amd64, arm, arm64...)

  - optional fields like `variant` (for arm and arm64), `os.version` (for windows)

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

class: extra-details

## Working with multi-arch images

- The Docker Engine will pull "native" images when available

  (images matching its own os/architecture/variant)

- We can ask for a specific image platform with `--platform`

- The Docker Engine can run non-native images thanks to QEMU+binfmt

  (automatically on Docker Desktop; with a bit of setup on Linux)

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

## Section summary

We've learned how to:

* Understand images and layers.
* Understand Docker image namespacing.
* Search and download images.

???

:EN:Building images
:EN:- Containers, images, and layers
:EN:- Image addresses and tags
:EN:- Finding and transferring images

:FR:Construire des images
:FR:- La différence entre un conteneur et une image
:FR:- La notion de *layer* partagé entre images

.debug[[containers/Initial_Images.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Initial_Images.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-1.jpg)]

---

name: toc-building-images-interactively
class: title

 Building images interactively

.nav[
[Previous part](#toc-understanding-docker-images)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-building-docker-images-with-a-dockerfile)
]

.debug[(automatically generated title slide)]

---
# Building images interactively

In this section, we will create our first container image.

It will be a basic distribution image, but we will pre-install
the package `figlet`.

We will: 

* Create a container from a base image.

* Install software manually in the container, and turn it
  into a new image.

* Learn about new commands: `docker commit`, `docker tag`, and `docker diff`.

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

## The plan

1. Create a container (with `docker run`) using our base distro of choice.

2. Run a bunch of commands to install and set up our software in the container.

3. (Optionally) review changes in the container with `docker diff`.

4. Turn the container into a new image with `docker commit`.

5. (Optionally) add tags to the image with `docker tag`.

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

## Setting up our container

Start an Ubuntu container:

```bash
$ docker run -it ubuntu
root@<yourContainerId>:#/
```

Run the command `apt-get update` to refresh the list of packages available to install.

Then run the command `apt-get install figlet` to install the program we are interested in.

```bash
root@<yourContainerId>:#/ apt-get update && apt-get install figlet
.... OUTPUT OF APT-GET COMMANDS ....
```

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

## Inspect the changes

Type `exit` at the container prompt to leave the interactive session.

Now let's run `docker diff` to see the difference between the base image
and our container.

```bash
$ docker diff <yourContainerId>
C /root
A /root/.bash_history
C /tmp
C /usr
C /usr/bin
A /usr/bin/figlet
...
```

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

class: x-extra-details

## Docker tracks filesystem changes

As explained before:

* An image is read-only.

* When we make changes, they happen in a copy of the image.

* Docker can show the difference between the image, and its copy.

* For performance, Docker uses copy-on-write systems.
  <br/>(i.e. starting a container based on a big image
  doesn't incur a huge copy.)

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

## Copy-on-write security benefits

* `docker diff` gives us an easy way to audit changes

  (à la Tripwire)

* Containers can also be started in read-only mode

  (their root filesystem will be read-only, but they can still have read-write data volumes)


.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

## Commit our changes into a new image

The `docker commit` command will create a new layer with those changes,
and a new image using this new layer.

```bash
$ docker commit <yourContainerId>
<newImageId>
```

The output of the `docker commit` command will be the ID for your newly created image.

We can use it as an argument to `docker run`.

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

## Testing our new image

Let's run this image:

```bash
$ docker run -it <newImageId>
root@fcfb62f0bfde:/# figlet hello
 _          _ _       
| |__   ___| | | ___  
| '_ \ / _ \ | |/ _ \ 
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/ 
```

It works! 🎉

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

## Tagging images

Referring to an image by its ID is not convenient. Let's tag it instead.

We can use the `tag` command:

```bash
$ docker tag <newImageId> figlet
```

But we can also specify the tag as an extra argument to `commit`:

```bash
$ docker commit <containerId> figlet
```

And then run it using its tag:

```bash
$ docker run -it figlet
```

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

## What's next?

Manual process = bad.

Automated process = good.

In the next chapter, we will learn how to automate the build
process by writing a `Dockerfile`.

???

:EN:- Building our first images interactively
:FR:- Fabriquer nos premières images à la main

.debug[[containers/Building_Images_Interactively.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_Interactively.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-2.jpg)]

---

name: toc-building-docker-images-with-a-dockerfile
class: title

 Building Docker images with a Dockerfile

.nav[
[Previous part](#toc-building-images-interactively)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-cmd-and-entrypoint)
]

.debug[(automatically generated title slide)]

---

class: title

# Building Docker images with a Dockerfile

![Construction site with containers](images/title-building-docker-images-with-a-dockerfile.jpg)

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Objectives

We will build a container image automatically, with a `Dockerfile`.

At the end of this lesson, you will be able to:

* Write a `Dockerfile`.

* Build an image from a `Dockerfile`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## `Dockerfile` overview

* A `Dockerfile` is a build recipe for a Docker image.

* It contains a series of instructions telling Docker how an image is constructed.

* The `docker build` command builds an image from a `Dockerfile`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Writing our first `Dockerfile`

Our Dockerfile must be in a **new, empty directory**.

1. Create a directory to hold our `Dockerfile`.

```bash
$ mkdir myimage
```

2. Create a `Dockerfile` inside this directory.

```bash
$ cd myimage
$ vim Dockerfile
```

Of course, you can use any other editor of your choice.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Type this into our Dockerfile...

```dockerfile
FROM ubuntu
RUN apt-get update
RUN apt-get install figlet
```

* `FROM` indicates the base image for our build.

* Each `RUN` line will be executed by Docker during the build.

* Our `RUN` commands **must be non-interactive.**
  <br/>(No input can be provided to Docker during the build.)

* In many cases, we will add the `-y` flag to `apt-get`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Build it!

Save our file, then execute:

```bash
$ docker build -t figlet .
```

* `-t` indicates the tag to apply to the image.

* `.` indicates the location of the *build context*.

We will talk more about the build context later.

To keep things simple for now: this is the directory where our Dockerfile is located.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## What happens when we build the image?

It depends if we're using BuildKit or not!

If there are lots of blue lines and the first line looks like this:
```
[+] Building 1.8s (4/6)
```
... then we're using BuildKit.

If the output is mostly black-and-white and the first line looks like this:
```
Sending build context to Docker daemon  2.048kB
```
... then we're using the "classic" or "old-style" builder.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## To BuildKit or Not To BuildKit

Classic builder:

- copies the whole "build context" to the Docker Engine

- linear (processes lines one after the other)

- requires a full Docker Engine

BuildKit:

- only transfers parts of the "build context" when needed

- will parallelize operations (when possible)

- can run in non-privileged containers (e.g. on Kubernetes)

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## With the classic builder

The output of `docker build` looks like this:

.small[
```bash
docker build -t figlet .
Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu
 ---> f975c5035748
Step 2/3 : RUN apt-get update
 ---> Running in e01b294dbffd
(...output of the RUN command...)
Removing intermediate container e01b294dbffd
 ---> eb8d9b561b37
Step 3/3 : RUN apt-get install figlet
 ---> Running in c29230d70f9b
(...output of the RUN command...)
Removing intermediate container c29230d70f9b
 ---> 0dfd7a253f21
Successfully built 0dfd7a253f21
Successfully tagged figlet:latest
```
]

* The output of the `RUN` commands has been omitted.
* Let's explain what this output means.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Sending the build context to Docker

```bash
Sending build context to Docker daemon 2.048 kB
```

* The build context is the `.` directory given to `docker build`.

* It is sent (as an archive) by the Docker client to the Docker daemon.

* This allows to use a remote machine to build using local files.

* Be careful (or patient) if that directory is big and your link is slow.

* You can speed up the process with a [`.dockerignore`](https://docs.docker.com/engine/reference/builder/#dockerignore-file) file

  * It tells docker to ignore specific files in the directory

  * Only ignore files that you won't need in the build context!

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Executing each step

```bash
Step 2/3 : RUN apt-get update
 ---> Running in e01b294dbffd
(...output of the RUN command...)
Removing intermediate container e01b294dbffd
 ---> eb8d9b561b37
```

* A container (`e01b294dbffd`) is created from the base image.

* The `RUN` command is executed in this container.

* The container is committed into an image (`eb8d9b561b37`).

* The build container (`e01b294dbffd`) is removed.

* The output of this step will be the base image for the next one.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## With BuildKit

.small[
```bash
[+] Building 7.9s (7/7) FINISHED
 => [internal] load build definition from Dockerfile                                                 0.0s
 => => transferring dockerfile: 98B                                                                  0.0s
 => [internal] load .dockerignore                                                                    0.0s
 => => transferring context: 2B                                                                      0.0s
 => [internal] load metadata for docker.io/library/ubuntu:latest                                     1.2s
 => [1/3] FROM docker.io/library/ubuntu@sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386  3.2s
 => => resolve docker.io/library/ubuntu@sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386  0.0s
 => => sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386da88eb681d93 1.20kB / 1.20kB       0.0s
 => => sha256:1de4c5e2d8954bf5fa9855f8b4c9d3c3b97d1d380efe19f60f3e4107a66f5cae 943B / 943B           0.0s
 => => sha256:6a98cbe39225dadebcaa04e21dbe5900ad604739b07a9fa351dd10a6ebad4c1b 3.31kB / 3.31kB       0.0s
 => => sha256:80bc30679ac1fd798f3241208c14accd6a364cb8a6224d1127dfb1577d10554f 27.14MB / 27.14MB     2.3s
 => => sha256:9bf18fab4cfbf479fa9f8409ad47e2702c63241304c2cdd4c33f2a1633c5f85e 850B / 850B           0.5s
 => => sha256:5979309c983a2adeff352538937475cf961d49c34194fa2aab142effe19ed9c1 189B / 189B           0.4s
 => => extracting sha256:80bc30679ac1fd798f3241208c14accd6a364cb8a6224d1127dfb1577d10554f            0.7s
 => => extracting sha256:9bf18fab4cfbf479fa9f8409ad47e2702c63241304c2cdd4c33f2a1633c5f85e            0.0s
 => => extracting sha256:5979309c983a2adeff352538937475cf961d49c34194fa2aab142effe19ed9c1            0.0s
 => [2/3] RUN apt-get update                                                                         2.5s
 => [3/3] RUN apt-get install figlet                                                                 0.9s
 => exporting to image                                                                               0.1s
 => => exporting layers                                                                              0.1s
 => => writing image sha256:3b8aee7b444ab775975dfba691a72d8ac24af2756e0a024e056e3858d5a23f7c         0.0s
 => => naming to docker.io/library/figlet                                                            0.0s
 ```
 ]

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Understanding BuildKit output

- BuildKit transfers the Dockerfile and the *build context*

  (these are the first two `[internal]` stages)

- Then it executes the steps defined in the Dockerfile

  (`[1/3]`, `[2/3]`, `[3/3]`)

- Finally, it exports the result of the build

  (image definition + collection of layers)

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

class: extra-details

## BuildKit plain output

- When running BuildKit in e.g. a CI pipeline, its output will be different

- We can see the same output format by using `--progress=plain`

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## The caching system

If you run the same build again, it will be instantaneous. Why?

* After each build step, Docker takes a snapshot of the resulting image.

* Before executing a step, Docker checks if it has already built the same sequence.

* Docker uses the exact strings defined in your Dockerfile, so:

  * `RUN apt-get install figlet cowsay`
    <br/> is different from
    <br/> `RUN apt-get install cowsay figlet`

  * `RUN apt-get update` is not re-executed when the mirrors are updated

You can force a rebuild with `docker build --no-cache ...`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Running the image

The resulting image is not different from the one produced manually.

```bash
$ docker run -ti figlet
root@91f3c974c9a1:/# figlet hello
 _          _ _       
| |__   ___| | | ___  
| '_ \ / _ \ | |/ _ \ 
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/ 
```


Yay! 🎉

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Using image and viewing history

The `history` command lists all the layers composing an image.

For each layer, it shows its creation time, size, and creation command.

When an image was built with a Dockerfile, each layer corresponds to
a line of the Dockerfile.

```bash
$ docker history figlet
IMAGE         CREATED            CREATED BY                     SIZE
f9e8f1642759  About an hour ago  /bin/sh -c apt-get install fi  1.627 MB
7257c37726a1  About an hour ago  /bin/sh -c apt-get update      21.58 MB
07c86167cdc4  4 days ago         /bin/sh -c #(nop) CMD ["/bin   0 B
<missing>     4 days ago         /bin/sh -c sed -i 's/^#\s*\(   1.895 kB
<missing>     4 days ago         /bin/sh -c echo '#!/bin/sh'    194.5 kB
<missing>     4 days ago         /bin/sh -c #(nop) ADD file:b   187.8 MB
```

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

class: extra-details

## Why `sh -c`?

* On UNIX, to start a new program, we need two system calls:

  - `fork()`, to create a new child process;

  - `execve()`, to replace the new child process with the program to run.

* Conceptually, `execve()` works like this:

  `execve(program, [list, of, arguments])`

* When we run a command, e.g. `ls -l /tmp`, something needs to parse the command.

  (i.e. split the program and its arguments into a list.)

* The shell is usually doing that.

  (It also takes care of expanding environment variables and special things like `~`.)

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

class: extra-details

## Why `sh -c`?

* When we do `RUN ls -l /tmp`, the Docker builder needs to parse the command.

* Instead of implementing its own parser, it outsources the job to the shell.

* That's why we see `sh -c ls -l /tmp` in that case.

* But we can also do the parsing jobs ourselves.

* This means passing `RUN` a list of arguments.

* This is called the *exec syntax*.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Shell syntax vs exec syntax

Dockerfile commands that execute something can have two forms:

* plain string, or *shell syntax*:
  <br/>`RUN apt-get install figlet`

* JSON list, or *exec syntax*:
  <br/>`RUN ["apt-get", "install", "figlet"]`

We are going to change our Dockerfile to see how it affects the resulting image.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Using exec syntax in our Dockerfile

Let's change our Dockerfile as follows!

```dockerfile
FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]
```

Then build the new Dockerfile.

```bash
$ docker build -t figlet .
```

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## History with exec syntax

Compare the new history:

```bash
$ docker history figlet
IMAGE         CREATED            CREATED BY                     SIZE
27954bb5faaf  10 seconds ago     apt-get install figlet         1.627 MB
7257c37726a1  About an hour ago  /bin/sh -c apt-get update      21.58 MB
07c86167cdc4  4 days ago         /bin/sh -c #(nop) CMD ["/bin   0 B
<missing>     4 days ago         /bin/sh -c sed -i 's/^#\s*\(   1.895 kB
<missing>     4 days ago         /bin/sh -c echo '#!/bin/sh'    194.5 kB
<missing>     4 days ago         /bin/sh -c #(nop) ADD file:b   187.8 MB
```

* Exec syntax specifies an *exact* command to execute.

* Shell syntax specifies a command to be wrapped within `/bin/sh -c "..."`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## When to use exec syntax and shell syntax

* shell syntax:

  * is easier to write
  * interpolates environment variables and other shell expressions
  * creates an extra process (`/bin/sh -c ...`) to parse the string
  * requires `/bin/sh` to exist in the container

* exec syntax:

  * is harder to write (and read!)
  * passes all arguments without extra processing
  * doesn't create an extra process
  * doesn't require `/bin/sh` to exist in the container

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Pro-tip: the `exec` shell built-in

POSIX shells have a built-in command named `exec`.

`exec` should be followed by a program and its arguments.

From a user perspective:

- it looks like the shell exits right away after the command execution,

- in fact, the shell exits just *before* command execution;

- or rather, the shell gets *replaced* by the command.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Example using `exec`

```dockerfile
CMD exec figlet -f script hello
```

In this example, `sh -c` will still be used, but
`figlet` will be PID 1 in the container.

The shell gets replaced by `figlet` when `figlet` starts execution.

This allows to run processes as PID 1 without using JSON.

???

:EN:- Towards automated, reproducible builds
:EN:- Writing our first Dockerfile
:FR:- Rendre le processus automatique et reproductible
:FR:- Écrire son premier Dockerfile

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Building_Images_With_Dockerfiles.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/two-containers-on-a-truck.jpg)]

---

name: toc-cmd-and-entrypoint
class: title

 `CMD` and `ENTRYPOINT`

.nav[
[Previous part](#toc-building-docker-images-with-a-dockerfile)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-copying-files-during-the-build)
]

.debug[(automatically generated title slide)]

---

class: title

# `CMD` and `ENTRYPOINT`

![Container entry doors](images/entrypoint.jpg)

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Objectives

In this lesson, we will learn about two important
Dockerfile commands:

`CMD` and `ENTRYPOINT`.

These commands allow us to set the default command
to run in a container.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Defining a default command

When people run our container, we want to greet them with a nice hello message, and using a custom font.

For that, we will execute:

```bash
figlet -f script hello
```

* `-f script` tells figlet to use a fancy font.

* `hello` is the message that we want it to display.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Adding `CMD` to our Dockerfile

Our new Dockerfile will look like this:

```dockerfile
FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]
CMD figlet -f script hello
```

* `CMD` defines a default command to run when none is given.

* It can appear at any point in the file.

* Each `CMD` will replace and override the previous one.

* As a result, while you can have multiple `CMD` lines, it is useless.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Build and test our image

Let's build it:

```bash
$ docker build -t figlet .
...
Successfully built 042dff3b4a8d
Successfully tagged figlet:latest
```

And run it:

```bash
$ docker run figlet
 _          _   _       
| |        | | | |      
| |     _  | | | |  __  
|/ \   |/  |/  |/  /  \_
|   |_/|__/|__/|__/\__/ 
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Overriding `CMD`

If we want to get a shell into our container (instead of running
`figlet`), we just have to specify a different program to run:

```bash
$ docker run -it figlet bash
root@7ac86a641116:/# 
```

* We specified `bash`.

* It replaced the value of `CMD`.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Using `ENTRYPOINT`

We want to be able to specify a different message on the command line,
while retaining `figlet` and some default parameters.

In other words, we would like to be able to do this:

```bash
$ docker run figlet salut
           _            
          | |           
 ,   __,  | |       _|_ 
/ \_/  |  |/  |   |  |  
 \/ \_/|_/|__/ \_/|_/|_/
```


We will use the `ENTRYPOINT` verb in Dockerfile.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Adding `ENTRYPOINT` to our Dockerfile

Our new Dockerfile will look like this:

```dockerfile
FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]
ENTRYPOINT ["figlet", "-f", "script"]
```

* `ENTRYPOINT` defines a base command (and its parameters) for the container.

* The command line arguments are appended to those parameters.

* Like `CMD`, `ENTRYPOINT` can appear anywhere, and replaces the previous value.

Why did we use JSON syntax for our `ENTRYPOINT`?

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Implications of JSON vs string syntax

* When CMD or ENTRYPOINT use string syntax, they get wrapped in `sh -c`.

* To avoid this wrapping, we can use JSON syntax.

What if we used `ENTRYPOINT` with string syntax?

```bash
$ docker run figlet salut
```

This would run the following command in the `figlet` image:

```bash
sh -c "figlet -f script" salut
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Build and test our image

Let's build it:

```bash
$ docker build -t figlet .
...
Successfully built 36f588918d73
Successfully tagged figlet:latest
```

And run it:

```bash
$ docker run figlet salut
           _            
          | |           
 ,   __,  | |       _|_ 
/ \_/  |  |/  |   |  |  
 \/ \_/|_/|__/ \_/|_/|_/
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Using `CMD` and `ENTRYPOINT` together

What if we want to define a default message for our container?

Then we will use `ENTRYPOINT` and `CMD` together.

* `ENTRYPOINT` will define the base command for our container.

* `CMD` will define the default parameter(s) for this command.

* They *both* have to use JSON syntax.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## `CMD` and `ENTRYPOINT` together

Our new Dockerfile will look like this:

```dockerfile
FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]
ENTRYPOINT ["figlet", "-f", "script"]
CMD ["hello world"]
```

* `ENTRYPOINT` defines a base command (and its parameters) for the container.

* If we don't specify extra command-line arguments when starting the container,
  the value of `CMD` is appended.

* Otherwise, our extra command-line arguments are used instead of `CMD`.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Build and test our image

Let's build it:

```bash
$ docker build -t myfiglet .
...
Successfully built 6e0b6a048a07
Successfully tagged myfiglet:latest
```

Run it without parameters:

```bash
$ docker run myfiglet
 _          _   _                             _        
| |        | | | |                           | |    |  
| |     _  | | | |  __             __   ,_   | |  __|  
|/ \   |/  |/  |/  /  \_  |  |  |_/  \_/  |  |/  /  |  
|   |_/|__/|__/|__/\__/    \/ \/  \__/    |_/|__/\_/|_/
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Overriding the image default parameters

Now let's pass extra arguments to the image.

```bash
$ docker run myfiglet hola mundo
 _           _                                               
| |         | |                                      |       
| |     __  | |  __,     _  _  _           _  _    __|   __  
|/ \   /  \_|/  /  |    / |/ |/ |  |   |  / |/ |  /  |  /  \_
|   |_/\__/ |__/\_/|_/    |  |  |_/ \_/|_/  |  |_/\_/|_/\__/ 
```

We overrode `CMD` but still used `ENTRYPOINT`.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## Overriding `ENTRYPOINT`

What if we want to run a shell in our container?

We cannot just do `docker run myfiglet bash` because
that would just tell figlet to display the word "bash."

We use the `--entrypoint` parameter:

```bash
$ docker run -it --entrypoint bash myfiglet
root@6027e44e2955:/# 
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## `CMD` and `ENTRYPOINT` recap

- `docker run myimage` executes `ENTRYPOINT` + `CMD`

- `docker run myimage args` executes `ENTRYPOINT` + `args` (overriding `CMD`)

- `docker run --entrypoint prog myimage` executes `prog` (overriding both)

.small[
| Command                         | `ENTRYPOINT`       | `CMD`   | Result
|---------------------------------|--------------------|---------|-------
| `docker run figlet`             | none               | none    | Use values from base image (`bash`)
| `docker run figlet hola`        | none               | none    | Error (executable `hola` not found)
| `docker run figlet`             | `figlet -f script` | none    | `figlet -f script`
| `docker run figlet hola`        | `figlet -f script` | none    | `figlet -f script hola`
| `docker run figlet`             | none    | `figlet -f script` | `figlet -f script`
| `docker run figlet hola`        | none    | `figlet -f script` | Error (executable `hola` not found)
| `docker run figlet`             | `figlet -f script` | `hello` | `figlet -f script hello`
| `docker run figlet hola`        | `figlet -f script` | `hello` | `figlet -f script hola`
]

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

## When to use `ENTRYPOINT` vs `CMD`

`ENTRYPOINT` is great for "containerized binaries".

Example: `docker run consul --help`

(Pretend that the `docker run` part isn't there!)

`CMD` is great for images with multiple binaries.

Example: `docker run busybox ifconfig`

(It makes sense to indicate *which* program we want to run!)

???

:EN:- CMD and ENTRYPOINT
:FR:- CMD et ENTRYPOINT

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Cmd_And_Entrypoint.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/wall-of-containers.jpeg)]

---

name: toc-copying-files-during-the-build
class: title

 Copying files during the build

.nav[
[Previous part](#toc-cmd-and-entrypoint)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-exercise--writing-dockerfiles)
]

.debug[(automatically generated title slide)]

---

class: title

# Copying files during the build

![Monks copying books](images/title-copying-files-during-build.jpg)

.debug[[containers/Copying_Files_During_Build.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copying_Files_During_Build.md)]
---

## Objectives

So far, we have installed things in our container images
by downloading packages.

We can also copy files from the *build context* to the
container that we are building.

Remember: the *build context* is the directory containing
the Dockerfile.

In this chapter, we will learn a new Dockerfile keyword: `COPY`.

.debug[[containers/Copying_Files_During_Build.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copying_Files_During_Build.md)]
---

## Build some C code

We want to build a container that compiles a basic "Hello world" program in C.

Here is the program, `hello.c`:

```bash
int main () {
  puts("Hello, world!");
  return 0;
}
```

Let's create a new directory, and put this file in there.

Then we will write the Dockerfile.

.debug[[containers/Copying_Files_During_Build.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copying_Files_During_Build.md)]
---

## The Dockerfile

On Debian and Ubuntu, the package `build-essential` will get us a compiler.

When installing it, don't forget to specify the `-y` flag, otherwise the build will fail (since the build cannot be interactive).

Then we will use `COPY` to place the source file into the container.

```bash
FROM ubuntu
RUN apt-get update
RUN apt-get install -y build-essential
COPY hello.c /
RUN make hello
CMD /hello
```

Create this Dockerfile.

.debug[[containers/Copying_Files_During_Build.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copying_Files_During_Build.md)]
---

## Testing our C program

* Create `hello.c` and `Dockerfile` in the same directory.

* Run `docker build -t hello .` in this directory.

* Run `docker run hello`, you should see `Hello, world!`.

Success!

.debug[[containers/Copying_Files_During_Build.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copying_Files_During_Build.md)]
---

## `COPY` and the build cache

* Run the build again.

* Now, modify `hello.c` and run the build again.

* Docker can cache steps involving `COPY`.

* Those steps will not be executed again if the files haven't been changed.

.debug[[containers/Copying_Files_During_Build.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copying_Files_During_Build.md)]
---

## Details

* We can `COPY` whole directories recursively

* It is possible to do e.g. `COPY . .`

  (but it might require some extra precautions to avoid copying too much)
 
* In older Dockerfiles, you might see the `ADD` command; consider it deprecated

  (it is similar to `COPY` but can automatically extract archives)

* If we really wanted to compile C code in a container, we would:

  * place it in a different directory, with the `WORKDIR` instruction

  * even better, use the `gcc` official image

.debug[[containers/Copying_Files_During_Build.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copying_Files_During_Build.md)]
---

class: extra-details

## `.dockerignore`

- We can create a file named `.dockerignore`

  (at the top-level of the build context)

- It can contain file names and globs to ignore

- They won't be sent to the builder

  (and won't end up in the resulting image)

- See the [documentation] for the little details

  (exceptions can be made with `!`, multiple directory levels with `**`...)

[documentation]: https://docs.docker.com/engine/reference/builder/#dockerignore-file

???

:EN:- Leveraging the build cache for faster builds
:FR:- Tirer parti du cache afin d'optimiser la vitesse de *build*

.debug[[containers/Copying_Files_During_Build.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copying_Files_During_Build.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/catene-de-conteneurs.jpg)]

---

name: toc-exercise--writing-dockerfiles
class: title

 Exercise — writing Dockerfiles

.nav[
[Previous part](#toc-copying-files-during-the-build)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-container-networking-basics)
]

.debug[(automatically generated title slide)]

---
# Exercise — writing Dockerfiles

Let's write Dockerfiles for an existing application!

1. Check out the code repository

2. Read all the instructions

3. Write Dockerfiles

4. Build and test them individually

<!--
5. Test them together with the provided Compose file
-->

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Code repository

Clone the repository available at:

https://github.com/jpetazzo/wordsmith

It should look like this:
```
├── LICENSE
├── README
├── db/
│   └── words.sql
├── web/
│   ├── dispatcher.go
│   └── static/
└── words/
    ├── pom.xml
    └── src/
```

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Instructions

The repository contains instructions in English and French.
<br/>
For now, we only care about the first part (about writing Dockerfiles).
<br/>
Place each Dockerfile in its own directory, like this:
```
├── LICENSE
├── README
├── db/
│   ├── `Dockerfile`
│   └── words.sql
├── web/
│   ├── `Dockerfile`
│   ├── dispatcher.go
│   └── static/
└── words/
    ├── `Dockerfile`
    ├── pom.xml
    └── src/
```

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Build and test

Build and run each Dockerfile individually.

For `db`, we should be able to see some messages confirming that the data set
was loaded successfully (some `INSERT` lines in the container output).

For `web` and `words`, we should be able to see some message looking like
"server started successfully".

That's all we care about for now!

Bonus question: make sure that each container stops correctly when hitting Ctrl-C.

???

## Test with a Compose file

Place the following Compose file at the root of the repository:


```yaml
version: "3"
services:
  db:
    build: db
  words:
    build: words
  web:
    build: web
    ports:
    - 8888:80
```

Test the whole app by bringin up the stack and connecting to port 8888.

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Exercise_Dockerfile_Basic.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-container-networking-basics
class: title

 Container networking basics

.nav[
[Previous part](#toc-exercise--writing-dockerfiles)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-container-network-drivers)
]

.debug[(automatically generated title slide)]

---

class: title

# Container networking basics

![A dense graph network](images/title-container-networking-basics.jpg)

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Objectives

We will now run network services (accepting requests) in containers.

At the end of this section, you will be able to:

* Run a network service in a container.

* Connect to that network service.

* Find a container's IP address.

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Running a very simple service

- We need something small, simple, easy to configure

  (or, even better, that doesn't require any configuration at all)

- Let's use the official NGINX image (named `nginx`)

- It runs a static web server listening on port 80

- It serves a default "Welcome to nginx!" page

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Running an NGINX server

```bash
$ docker run -d -P nginx
66b1ce719198711292c8f34f84a7b68c3876cf9f67015e752b94e189d35a204e
```

- Docker will automatically pull the `nginx` image from the Docker Hub

- `-d` / `--detach` tells Docker to run it in the background

- `P` / `--publish-all` tells Docker to publish all ports

  (publish = make them reachable from other computers)

- ...OK, how do we connect to our web server now?

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Finding our web server port

- First, we need to find the *port number* used by Docker

  (the NGINX container listens on port 80, but this port will be *mapped*)

- We can use `docker ps`:
  ```bash
  $ docker ps
  CONTAINER ID  IMAGE  ...  PORTS                  ...
  e40ffb406c9e  nginx  ...  0.0.0.0:`12345`->80/tcp  ...
  ```

- This means:

  *port 12345 on the Docker host is mapped to port 80 in the container*

- Now we need to connect to the Docker host!

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Finding the address of the Docker host

- When running Docker on your Linux workstation:

  *use `localhost`, or any IP address of your machine*

- When running Docker on a remote Linux server:

  *use any IP address of the remote machine*

- When running Docker Desktop on Mac or Windows:

  *use `localhost`*

- In other scenarios (`docker-machine`, local VM...):

  *use the IP address of the Docker VM*
  
.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Connecting to our web server (GUI)

Point your browser to the IP address of your Docker host, on the port
shown by `docker ps` for container port 80.

![Screenshot](images/welcome-to-nginx.png)

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Connecting to our web server (CLI)

You can also use `curl` directly from the Docker host.

Make sure to use the right port number if it is different
from the example below:

```bash
$ curl localhost:12345
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
...
```

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## How does Docker know which port to map?

* There is metadata in the image telling "this image has something on port 80".

* We can see that metadata with `docker inspect`:

```bash
$ docker inspect --format '{{.Config.ExposedPorts}}' nginx
map[80/tcp:{}]
```

* This metadata was set in the Dockerfile, with the `EXPOSE` keyword.

* We can see that with `docker history`:

```bash
$ docker history nginx
IMAGE               CREATED             CREATED BY
7f70b30f2cc6        11 days ago         /bin/sh -c #(nop)  CMD ["nginx" "-g" "…
<missing>           11 days ago         /bin/sh -c #(nop)  STOPSIGNAL [SIGTERM]
<missing>           11 days ago         /bin/sh -c #(nop)  EXPOSE 80/tcp
```

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Why can't we just connect to port 80?

- Our Docker host has only one port 80

- Therefore, we can only have one container at a time on port 80

- Therefore, if multiple containers want port 80, only one can get it

- By default, containers *do not* get "their" port number, but a random one

  (not "random" as "crypto random", but as "it depends on various factors")

- We'll see later how to force a port number (including port 80!)

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

class: extra-details

## Using multiple IP addresses

*Hey, my network-fu is strong, and I have questions...*

- Can I publish one container on 127.0.0.2:80, and another on 127.0.0.3:80?

- My machine has multiple (public) IP addresses, let's say A.A.A.A and B.B.B.B.
  <br/>
  Can I have one container on A.A.A.A:80 and another on B.B.B.B:80?

- I have a whole IPV4 subnet, can I allocate it to my containers?

- What about IPV6?

You can do all these things when running Docker directly on Linux.

(On other platforms, *generally not*, but there are some exceptions.)

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Finding the web server port in a script

Parsing the output of `docker ps` would be painful.

There is a command to help us:

```bash
$ docker port <containerID> 80
0.0.0.0:12345
```

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Manual allocation of port numbers

If you want to set port numbers yourself, no problem:

```bash
$ docker run -d -p 80:80 nginx
$ docker run -d -p 8000:80 nginx
$ docker run -d -p 8080:80 -p 8888:80 nginx
```

* We are running three NGINX web servers.
* The first one is exposed on port 80.
* The second one is exposed on port 8000.
* The third one is exposed on ports 8080 and 8888.

Note: the convention is `port-on-host:port-on-container`.

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Plumbing containers into your infrastructure

There are many ways to integrate containers in your network.

* Start the container, letting Docker allocate a public port for it.
  <br/>Then retrieve that port number and feed it to your configuration.

* Pick a fixed port number in advance, when you generate your configuration.
  <br/>Then start your container by setting the port numbers manually.

* Use an orchestrator like Kubernetes or Swarm.
  <br/>The orchestrator will provide its own networking facilities.

Orchestrators typically provide mechanisms to enable direct container-to-container
communication across hosts, and publishing/load balancing for inbound traffic.

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Finding the container's IP address

We can use the `docker inspect` command to find the IP address of the
container.

```bash
$ docker inspect --format '{{ .NetworkSettings.IPAddress }}' <yourContainerID>
172.17.0.3
```

* `docker inspect` is an advanced command, that can retrieve a ton
  of information about our containers.

* Here, we provide it with a format string to extract exactly the
  private IP address of the container.

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Pinging our container

Let's try to ping our container *from another container.*

```bash
docker run alpine ping `<ipaddress>`
PING 172.17.0.X (172.17.0.X): 56 data bytes
64 bytes from 172.17.0.X: seq=0 ttl=64 time=0.106 ms
64 bytes from 172.17.0.X: seq=1 ttl=64 time=0.250 ms
64 bytes from 172.17.0.X: seq=2 ttl=64 time=0.188 ms
```

When running on Linux, we can even ping that IP address directly!

(And connect to a container's ports even if they aren't published.)

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## How often do we use `-p` and `-P` ?

- When running a stack of containers, we will often use Compose

- Compose will take care of exposing containers

  (through a `ports:` section in the `docker-compose.yml` file)

- It is, however, fairly common to use `docker run -P` for a quick test

- Or `docker run -p ...` when an image doesn't `EXPOSE` a port correctly

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

## Section summary

We've learned how to:

* Expose a network port.

* Connect to an application running in a container.

* Find a container's IP address.

???

:EN:- Exposing single containers
:FR:- Exposer un conteneur isolé

.debug[[containers/Container_Networking_Basics.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Networking_Basics.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-container-network-drivers
class: title

 Container network drivers

.nav[
[Previous part](#toc-container-networking-basics)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-local-development-workflow-with-docker)
]

.debug[(automatically generated title slide)]

---
# Container network drivers

The Docker Engine supports different network drivers.

The built-in drivers include:

* `bridge` (default)

* `null` (for the special network called `none`)

* `host` (for the special network called `host`)

* `container` (that one is a bit magic!)

The network is selected with `docker run --net ...`.

Each network is managed by a driver.

The different drivers are explained with more details on the following slides.

.debug[[containers/Network_Drivers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Network_Drivers.md)]
---

## The default bridge

* By default, the container gets a virtual `eth0` interface.
  <br/>(In addition to its own private `lo` loopback interface.)

* That interface is provided by a `veth` pair.

* It is connected to the Docker bridge.
  <br/>(Named `docker0` by default; configurable with `--bridge`.)

* Addresses are allocated on a private, internal subnet.
  <br/>(Docker uses 172.17.0.0/16 by default; configurable with `--bip`.)

* Outbound traffic goes through an iptables MASQUERADE rule.

* Inbound traffic goes through an iptables DNAT rule.

* The container can have its own routes, iptables rules, etc.

.debug[[containers/Network_Drivers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Network_Drivers.md)]
---

## The null driver

* Container is started with `docker run --net none ...`

* It only gets the `lo` loopback interface. No `eth0`.

* It can't send or receive network traffic.

* Useful for isolated/untrusted workloads.

.debug[[containers/Network_Drivers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Network_Drivers.md)]
---

## The host driver

* Container is started with `docker run --net host ...`

* It sees (and can access) the network interfaces of the host.

* It can bind any address, any port (for ill and for good).

* Network traffic doesn't have to go through NAT, bridge, or veth.

* Performance = native!

Use cases:

* Performance sensitive applications (VOIP, gaming, streaming...)

* Peer discovery (e.g. Erlang port mapper, Raft, Serf...)

.debug[[containers/Network_Drivers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Network_Drivers.md)]
---

## The container driver

* Container is started with `docker run --net container:id ...`

* It re-uses the network stack of another container.

* It shares with this other container the same interfaces, IP address(es), routes, iptables rules, etc.

* Those containers can communicate over their `lo` interface.
  <br/>(i.e. one can bind to 127.0.0.1 and the others can connect to it.)

???

:EN:Advanced container networking
:EN:- Transparent network access with the "host" driver
:EN:- Sharing is caring with the "container" driver

:FR:Paramétrage réseau avancé
:FR:- Accès transparent au réseau avec le mode "host"
:FR:- Partage de la pile réseau avece le mode "container"

.debug[[containers/Network_Drivers.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Network_Drivers.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-local-development-workflow-with-docker
class: title

 Local development workflow with Docker

.nav[
[Previous part](#toc-container-network-drivers)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-the-container-network-model)
]

.debug[(automatically generated title slide)]

---

class: title

# Local development workflow with Docker

![Construction site](images/title-local-development-workflow-with-docker.jpg)

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Objectives

At the end of this section, you will be able to:

* Share code between container and host.

* Use a simple local development workflow.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Local development in a container

We want to solve the following issues:

- "Works on my machine"

- "Not the same version"

- "Missing dependency"

By using Docker containers, we will get a consistent development environment.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Working on the "namer" application

* We have to work on some application whose code is at:

  https://github.com/jpetazzo/namer.

* What is it? We don't know yet!

* Let's download the code.

```bash
$ git clone https://github.com/jpetazzo/namer
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Looking at the code

```bash
$ cd namer
$ ls -1
company_name_generator.rb
config.ru
docker-compose.yml
Dockerfile
Gemfile
```

--

Aha, a `Gemfile`! This is Ruby. Probably. We know this. Maybe?

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Looking at the `Dockerfile`

```dockerfile
FROM ruby

COPY . /src
WORKDIR /src
RUN bundler install

CMD ["rackup", "--host", "0.0.0.0"]
EXPOSE 9292
```

* This application is using a base `ruby` image.
* The code is copied in `/src`.
* Dependencies are installed with `bundler`.
* The application is started with `rackup`.
* It is listening on port 9292.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Building and running the "namer" application

* Let's build the application with the `Dockerfile`!

--

```bash
$ docker build -t namer .
```

--

* Then run it. *We need to expose its ports.*

--

```bash
$ docker run -dP namer
```

--

* Check on which port the container is listening.

--

```bash
$ docker ps -l
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Connecting to our application

* Point our browser to our Docker node, on the port allocated to the container.

--

* Hit "reload" a few times.

--

* This is an enterprise-class, carrier-grade, ISO-compliant company name generator!

  (With 50% more bullshit than the average competition!)

  (Wait, was that 50% more, or 50% less? *Anyway!*)

  ![web application 1](images/webapp-in-blue.png)

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Making changes to the code

Option 1:

* Edit the code locally
* Rebuild the image
* Re-run the container

Option 2:

* Enter the container (with `docker exec`)
* Install an editor
* Make changes from within the container

Option 3:

* Use a *bind mount* to share local files with the container
* Make changes locally
* Changes are reflected in the container

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Our first volume

We will tell Docker to map the current directory to `/src` in the container.

```bash
$ docker run -d -v $(pwd):/src -P namer
```

* `-d`: the container should run in detached mode (in the background).

* `-v`: the following host directory should be mounted inside the container.

* `-P`: publish all the ports exposed by this image.

* `namer` is the name of the image we will run.

* We don't specify a command to run because it is already set in the Dockerfile via `CMD`.

Note: on Windows, replace `$(pwd)` with `%cd%` (or `${pwd}` if you use PowerShell).

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Mounting volumes inside containers

The `-v` flag mounts a directory from your host into your Docker container.

The flag structure is:

```bash
[host-path]:[container-path]:[rw|ro]
```

* `[host-path]` and `[container-path]` are created if they don't exist.

* You can control the write status of the volume with the `ro` and
  `rw` options.

* If you don't specify `rw` or `ro`, it will be `rw` by default.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## Hold your horses... and your mounts

- The `-v /path/on/host:/path/in/container` syntax is the "old" syntax

- The modern syntax looks like this:

  `--mount type=bind,source=/path/on/host,target=/path/in/container`

- `--mount` is more explicit, but `-v` is quicker to type

- `--mount` supports all mount types; `-v` doesn't support `tmpfs` mounts

- `--mount` fails if the path on the host doesn't exist; `-v` creates it

With the new syntax, our command becomes:
```bash
docker run --mount=type=bind,source=$(pwd),target=/src -dP namer
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Testing the development container

* Check the port used by our new container.

```bash
$ docker ps -l
CONTAINER ID  IMAGE  COMMAND  CREATED        STATUS  PORTS                   NAMES
045885b68bc5  namer  rackup   3 seconds ago  Up ...  0.0.0.0:32770->9292/tcp ...
```

* Open the application in your web browser.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Making a change to our application

Our customer really doesn't like the color of our text. Let's change it.

```bash
$ vi company_name_generator.rb
```

And change

```css
color: royalblue;
```

To:

```css
color: red;
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Viewing our changes

* Reload the application in our browser.

--

* The color should have changed.

  ![web application 2](images/webapp-in-red.png)

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Understanding volumes

- Volumes are *not* copying or synchronizing files between the host and the container

- Changes made in the host are immediately visible in the container (and vice versa)

- When running on Linux:

  - volumes and bind mounts correspond to directories on the host

  - if Docker runs in a Linux VM, these directories are in the Linux VM

- When running on Docker Desktop:

  - volumes correspond to directories in a small Linux VM running Docker

  - access to bind mounts is translated to host filesystem access
    <br/>
    (a bit like a network filesystem)

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## Docker Desktop caveats

- When running Docker natively on Linux, accessing a mount = native I/O

- When running Docker Desktop, accessing a bind mount = file access translation

- That file access translation has relatively good performance *in general*

  (watch out, however, for that big `npm install` working on a bind mount!)

- There are some corner cases when watching files (with mechanisms like inotify)

- Features like "live reload" or programs like `entr` don't always behave properly

  (due to e.g. file attribute caching, and other interesting details!)

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Trash your servers and burn your code

*(This is the title of a
[2013 blog post][immutable-deployments]
by Chad Fowler, where he explains the concept of immutable infrastructure.)*

[immutable-deployments]: https://web.archive.org/web/20160305073617/http://chadfowler.com/blog/2013/06/23/immutable-deployments/

--

* Let's majorly mess up our container.

  (Remove files or whatever.)

* Now, how can we fix this?

--

* Our old container (with the blue version of the code) is still running.

* See on which port it is exposed:
  ```bash
  docker ps
  ```

* Point our browser to it to confirm that it still works fine.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Immutable infrastructure in a nutshell

* Instead of *updating* a server, we deploy a new one.

* This might be challenging with classical servers, but it's trivial with containers.

* In fact, with Docker, the most logical workflow is to build a new image and run it.

* If something goes wrong with the new image, we can always restart the old one.

* We can even keep both versions running side by side.

If this pattern sounds interesting, you might want to read about *blue/green deployment*
and *canary deployments*.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Recap of the development workflow

1. Write a Dockerfile to build an image containing our development environment.
   <br/>
   (Rails, Django, ... and all the dependencies for our app)

2. Start a container from that image.
   <br/>
   Use the `-v` flag to mount our source code inside the container.

3. Edit the source code outside the container, using familiar tools.
   <br/>
   (vim, emacs, textmate...)

4. Test the application.
   <br/>
   (Some frameworks pick up changes automatically.
   <br/>Others require you to Ctrl-C + restart after each modification.)

5. Iterate and repeat steps 3 and 4 until satisfied.

6. When done, commit+push source code changes.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## Debugging inside the container

Docker has a command called `docker exec`.

It allows users to run a new process in a container which is already running.

If sometimes you find yourself wishing you could SSH into a container: you can use `docker exec` instead.

You can get a shell prompt inside an existing container this way, or run an arbitrary process for automation.

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## `docker exec` example

```bash
$ # You can run ruby commands in the area the app is running and more!
$ docker exec -it <yourContainerId> bash
root@5ca27cf74c2e:/opt/namer# irb
irb(main):001:0> [0, 1, 2, 3, 4].map {|x| x ** 2}.compact
=> [0, 1, 4, 9, 16]
irb(main):002:0> exit
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## Stopping the container

Now that we're done let's stop our container.

```bash
$ docker stop <yourContainerID>
```

And remove it.

```bash
$ docker rm <yourContainerID>
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

## Section summary

We've learned how to:

* Share code between container and host.

* Set our working directory.

* Use a simple local development workflow.

???

:EN:Developing with containers
:EN:- “Containerize” a development environment

:FR:Développer au jour le jour
:FR:- « Containeriser » son environnement de développement

.debug[[containers/Local_Development_Workflow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Local_Development_Workflow.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-the-container-network-model
class: title

 The Container Network Model

.nav[
[Previous part](#toc-local-development-workflow-with-docker)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-service-discovery-with-containers)
]

.debug[(automatically generated title slide)]

---

class: title

# The Container Network Model

![A denser graph network](images/title-the-container-network-model.jpg)

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Objectives

We will learn about the CNM (Container Network Model).

At the end of this lesson, you will be able to:

* Create a private network for a group of containers.

* Use container naming to connect services together.

* Dynamically connect and disconnect containers to networks.

* Set the IP address of a container.

We will also explain the principle of overlay networks and network plugins.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## The Container Network Model

Docker has "networks".

We can manage them with the `docker network` commands; for instance:

```bash
$ docker network ls
NETWORK ID          NAME                DRIVER
6bde79dfcf70        bridge              bridge
8d9c78725538        none                null
eb0eeab782f4        host                host
4c1ff84d6d3f        blog-dev            overlay
228a4355d548        blog-prod           overlay
```

New networks can be created (with `docker network create`).

(Note: networks `none` and `host` are special; let's set them aside for now.)

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## What's a network?

- Conceptually, a Docker "network" is a virtual switch

  (we can also think about it like a VLAN, or a WiFi SSID, for instance)

- By default, containers are connected to a single network

  (but they can be connected to zero, or many networks, even dynamically)

- Each network has its own subnet (IP address range)

- A network can be local (to a single Docker Engine) or global (span multiple hosts)

- Containers can have *network aliases* providing DNS-based service discovery

  (and each network has its own "domain", "zone", or "scope")

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Service discovery

- A container can be given a network alias

  (e.g. with `docker run --net some-network --net-alias db ...`)

- The containers running in the same network can resolve that network alias

  (i.e. if they do a DNS lookup on `db`, it will give the container's address)

- We can have a different `db` container in each network

  (this avoids naming conflicts between different stacks)

- When we name a container, it automatically adds the name as a network alias

  (i.e. `docker run --name xyz ...` is like `docker run --net-alias xyz ...`

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Network isolation

- Networks are isolated

- By default, containers in network A cannot reach those in network B

- A container connected to both networks A and B can act as a router or proxy

- Published ports are always reachable through the Docker host address

  (`docker run -P ...` makes a container port available to everyone)

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## How to use networks

- We typically create one network per "stack" or app that we deploy

- More complex apps or stacks might require multiple networks

  (e.g. `frontend`, `backend`, ...)

- Networks allow us to deploy multiple copies of the same stack

  (e.g. `prod`, `dev`, `pr-442`, ....)

- If we use Docker Compose, this is managed automatically for us

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: pic

![Multiple containers on the default bridge network, on a Linux machine](images/docker-networking-default-bridge-linux.png)

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: pic

![Multiple containers in multiple bridge networks, on a Linux machine](images/docker-networking-networks-linux.png)

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: pic

![Multiple containers in multiple bridge networks, on a Mac/Windows machine](images/docker-networking-networks-macwin.png)

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## CNM vs CNI

- CNM is the model used by Docker

- Kubernetes uses a different model, architectured around CNI

  (CNI is a kind of API between a container engine and *CNI plugins*)

- Docker model:

  - multiple isolated networks
  - per-network service discovery
  - network interconnection requires extra steps

- Kubernetes model:

  - single flat network
  - per-namespace service discovery
  - network isolation requires extra steps (Network Policies)

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Creating a network

Let's create a network called `dev`.

```bash
$ docker network create dev
4c1ff84d6d3f1733d3e233ee039cac276f425a9d5228a4355d54878293a889ba
```

The network is now visible with the `network ls` command:

```bash
$ docker network ls
NETWORK ID          NAME                DRIVER
6bde79dfcf70        bridge              bridge
8d9c78725538        none                null
eb0eeab782f4        host                host
4c1ff84d6d3f        dev                 bridge
```

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Placing containers on a network

We will create a *named* container on this network.

It will be reachable with its name, `es`.

```bash
$ docker run -d --name es --net dev elasticsearch:2
8abb80e229ce8926c7223beb69699f5f34d6f1d438bfc5682db893e798046863
```

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Communication between containers

Now, create another container on this network.

.small[
```bash
$ docker run -ti --net dev alpine sh
root@0ecccdfa45ef:/#
```
]

From this new container, we can resolve and ping the other one, using its assigned name:

.small[
```bash
/ # ping es
PING es (172.18.0.2) 56(84) bytes of data.
64 bytes from es.dev (172.18.0.2): icmp_seq=1 ttl=64 time=0.221 ms
64 bytes from es.dev (172.18.0.2): icmp_seq=2 ttl=64 time=0.114 ms
64 bytes from es.dev (172.18.0.2): icmp_seq=3 ttl=64 time=0.114 ms
^C
--- es ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2000ms
rtt min/avg/max/mdev = 0.114/0.149/0.221/0.052 ms
root@0ecccdfa45ef:/#
```
]

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Resolving container addresses

Since Docker Engine 1.10, name resolution is implemented by a dynamic resolver.

Archeological note: when CNM was intoduced (in Docker Engine 1.9, November 2015)
name resolution was implemented with `/etc/hosts`, and it was updated each time
CONTAINERs were added/removed. This could cause interesting race conditions
since `/etc/hosts` was a bind-mount (and couldn't be updated atomically).

.small[
```bash
[root@0ecccdfa45ef /]# cat /etc/hosts
172.18.0.3  0ecccdfa45ef
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.18.0.2      es
172.18.0.2      es.dev
```
]

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-service-discovery-with-containers
class: title

 Service discovery with containers

.nav[
[Previous part](#toc-the-container-network-model)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-gentle-introduction-to-yaml)
]

.debug[(automatically generated title slide)]

---

# Service discovery with containers

* Let's try to run an application that requires two containers.

* The first container is a web server.

* The other one is a redis data store.

* We will place them both on the `dev` network created before.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Running the web server

* The application is provided by the container image `jpetazzo/trainingwheels`.

* We don't know much about it so we will try to run it and see what happens!

Start the container, exposing all its ports:

```bash
$ docker run --net dev -d -P jpetazzo/trainingwheels
```

Check the port that has been allocated to it:

```bash
$ docker ps -l
```

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Test the web server

* If we connect to the application now, we will see an error page:

![Trainingwheels error](images/trainingwheels-error.png)

* This is because the Redis service is not running.
* This container tries to resolve the name `redis`.

Note: we're not using a FQDN or an IP address here; just `redis`.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Start the data store

* We need to start a Redis container.

* That container must be on the same network as the web server.

* It must have the right network alias (`redis`) so the application can find it.

Start the container:

```bash
$ docker run --net dev --net-alias redis -d redis
```

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Test the web server again

* If we connect to the application now, we should see that the app is working correctly:

![Trainingwheels OK](images/trainingwheels-ok.png)

* When the app tries to resolve `redis`, instead of getting a DNS error, it gets the IP address of our Redis container.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## A few words on *scope*

- Container names are unique (there can be only one `--name redis`)

- Network aliases are not unique

- We can have the same network alias in different networks:
  ```bash
  docker run --net dev --net-alias redis ...
  docker run --net prod --net-alias redis ...
  ```

- We can even have multiple containers with the same alias in the same network

  (in that case, we get multiple DNS entries, aka "DNS round robin")

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Names are *local* to each network

Let's try to ping our `es` container from another container, when that other container is *not* on the `dev` network.

```bash
$ docker run --rm alpine ping es
ping: bad address 'es'
```

Names can be resolved only when containers are on the same network.

Containers can contact each other only when they are on the same network (you can try to ping using the IP address to verify).

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Network aliases

We would like to have another network, `prod`, with its own `es` container. But there can be only one container named `es`!

We will use *network aliases*.

A container can have multiple network aliases.

Network aliases are *local* to a given network (only exist in this network).

Multiple containers can have the same network alias (even on the same network).

Since Docker Engine 1.11, resolving a network alias yields the IP addresses of all containers holding this alias.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Creating containers on another network

Create the `prod` network.

```bash
$ docker network create prod
5a41562fecf2d8f115bedc16865f7336232a04268bdf2bd816aecca01b68d50c
```

We can now create multiple containers with the `es` alias on the new `prod` network.

```bash
$ docker run -d --name prod-es-1 --net-alias es --net prod elasticsearch:2
38079d21caf0c5533a391700d9e9e920724e89200083df73211081c8a356d771
$ docker run -d --name prod-es-2 --net-alias es --net prod elasticsearch:2
1820087a9c600f43159688050dcc164c298183e1d2e62d5694fd46b10ac3bc3d
```

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Resolving network aliases

Let's try DNS resolution first, using the `nslookup` tool that ships with the `alpine` image.

```bash
$ docker run --net prod --rm alpine nslookup es
Name:      es
Address 1: 172.23.0.3 prod-es-2.prod
Address 2: 172.23.0.2 prod-es-1.prod
```

(You can ignore the `can't resolve '(null)'` errors.)

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Connecting to aliased containers

Each ElasticSearch instance has a name (generated when it is started). This name can be seen when we issue a simple HTTP request on the ElasticSearch API endpoint.

Try the following command a few times:

.small[
```bash
$ docker run --rm --net dev centos curl -s es:9200
{
  "name" : "Tarot",
...
}
```
]

Then try it a few times by replacing `--net dev` with `--net prod`:

.small[
```bash
$ docker run --rm --net prod centos curl -s es:9200
{
  "name" : "The Symbiote",
...
}
```
]

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Good to know ...

* Docker will not create network names and aliases on the default `bridge` network.

* Therefore, if you want to use those features, you have to create a custom network first.

* Network aliases are *not* unique on a given network.

* i.e., multiple containers can have the same alias on the same network.

* In that scenario, the Docker DNS server will return multiple records.
  <br/>
  (i.e. you will get DNS round robin out of the box.)

* Enabling *Swarm Mode* gives access to clustering and load balancing with IPVS.

* Creation of networks and network aliases is generally automated with tools like Compose.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## A few words about round robin DNS

Don't rely exclusively on round robin DNS to achieve load balancing.

Many factors can affect DNS resolution, and you might see:

- all traffic going to a single instance;
- traffic being split (unevenly) between some instances;
- different behavior depending on your application language;
- different behavior depending on your base distro;
- different behavior depending on other factors (sic).

It's OK to use DNS to discover available endpoints, but remember that you have to re-resolve every now and then to discover new endpoints.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Custom networks

When creating a network, extra options can be provided.

* `--internal` disables outbound traffic (the network won't have a default gateway).

* `--gateway` indicates which address to use for the gateway (when outbound traffic is allowed).

* `--subnet` (in CIDR notation) indicates the subnet to use.

* `--ip-range` (in CIDR notation) indicates the subnet to allocate from.

* `--aux-address` allows specifying a list of reserved addresses (which won't be allocated to containers).

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Setting containers' IP address

* It is possible to set a container's address with `--ip`.
* The IP address has to be within the subnet used for the container.

A full example would look like this.

```bash
$ docker network create --subnet 10.66.0.0/16 pubnet
42fb16ec412383db6289a3e39c3c0224f395d7f85bcb1859b279e7a564d4e135
$ docker run --net pubnet --ip 10.66.66.66 -d nginx
b2887adeb5578a01fd9c55c435cad56bbbe802350711d2743691f95743680b09
```

*Note: don't hard code container IP addresses in your code!*

*I repeat: don't hard code container IP addresses in your code!*

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Network drivers

* A network is managed by a *driver*.

* The built-in drivers include:

  * `bridge` (default)
  * `none`
  * `host`
  * `macvlan`
  * `overlay` (for Swarm clusters)

* More drivers can be provided by plugins (OVS, VLAN...)

* A network can have a custom IPAM (IP allocator).

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Overlay networks

* The features we've seen so far only work when all containers are on a single host.

* If containers span multiple hosts, we need an *overlay* network to connect them together.

* Docker ships with a default network plugin, `overlay`, implementing an overlay network leveraging
  VXLAN, *enabled with Swarm Mode*.

* Other plugins (Weave, Calico...) can provide overlay networks as well.

* Once you have an overlay network, *all the features that we've used in this chapter work identically
  across multiple hosts.*

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Multi-host networking (overlay)

Out of the scope for this intro-level workshop!

Very short instructions:

- enable Swarm Mode (`docker swarm init` then `docker swarm join` on other nodes)
- `docker network create mynet --driver overlay`
- `docker service create --network mynet myimage`

If you want to learn more about Swarm mode, you can check
[this video](https://www.youtube.com/watch?v=EuzoEaE6Cqs)
or [these slides](https://container.training/swarm-selfpaced.yml.html).

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Multi-host networking (plugins)

Out of the scope for this intro-level workshop!

General idea:

- install the plugin (they often ship within containers)

- run the plugin (if it's in a container, it will often require extra parameters; don't just `docker run` it blindly!)

- some plugins require configuration or activation (creating a special file that tells Docker "use the plugin whose control socket is at the following location")

- you can then `docker network create --driver pluginname`

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Connecting and disconnecting dynamically

* So far, we have specified which network to use when starting the container.

* The Docker Engine also allows connecting and disconnecting while the container is running.

* This feature is exposed through the Docker API, and through two Docker CLI commands:

  * `docker network connect <network> <container>`

  * `docker network disconnect <network> <container>`

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Dynamically connecting to a network

* We have a container named `es` connected to a network named `dev`.

* Let's start a simple alpine container on the default network:

  ```bash
  $ docker run -ti alpine sh
  / #
  ```

* In this container, try to ping the `es` container:

  ```bash
  / # ping es
  ping: bad address 'es'
  ```

  This doesn't work, but we will change that by connecting the container.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Finding the container ID and connecting it

* Figure out the ID of our alpine container; here are two methods:

  * looking at `/etc/hostname` in the container,

  * running `docker ps -lq` on the host.

* Run the following command on the host:

  ```bash
  $ docker network connect dev `<container_id>`
  ```

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Checking what we did

* Try again to `ping es` from the container.

* It should now work correctly:

  ```bash
  / # ping es
  PING es (172.20.0.3): 56 data bytes
  64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.376 ms
  64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.130 ms
  ^C
  ```

* Interrupt it with Ctrl-C.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Looking at the network setup in the container

We can look at the list of network interfaces with `ifconfig`, `ip a`, or `ip l`:

.small[
```bash
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
18: eth0@if19: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
20: eth1@if21: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP
    link/ether 02:42:ac:14:00:04 brd ff:ff:ff:ff:ff:ff
    inet 172.20.0.4/16 brd 172.20.255.255 scope global eth1
       valid_lft forever preferred_lft forever
/ #
```
]

Each network connection is materialized with a virtual network interface.

As we can see, we can be connected to multiple networks at the same time.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

## Disconnecting from a network

* Let's try the symmetrical command to disconnect the container:
  ```bash
  $ docker network disconnect dev <container_id>
  ```

* From now on, if we try to ping `es`, it will not resolve:
  ```bash
  / # ping es
  ping: bad address 'es'
  ```

* Trying to ping the IP address directly won't work either:
  ```bash
  / # ping 172.20.0.3
  ... (nothing happens until we interrupt it with Ctrl-C)
  ```

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Network aliases are scoped per network

* Each network has its own set of network aliases.

* We saw this earlier: `es` resolves to different addresses in `dev` and `prod`.

* If we are connected to multiple networks, the resolver looks up names in each of them
  (as of Docker Engine 18.03, it is the connection order) and stops as soon as the name
  is found.

* Therefore, if we are connected to both `dev` and `prod`, resolving `es` will **not**
  give us the addresses of all the `es` services; but only the ones in `dev` or `prod`.

* However, we can lookup `es.dev` or `es.prod` if we need to.

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Finding out about our networks and names

* We can do reverse DNS lookups on containers' IP addresses.

* If the IP address belongs to a network (other than the default bridge), the result will be:

  ```
  name-or-first-alias-or-container-id.network-name
  ```

* Example:

.small[
```bash
$ docker run -ti --net prod --net-alias hello alpine
/ # apk add --no-cache drill
...
OK: 5 MiB in 13 packages
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:15:00:03
          inet addr:`172.21.0.3`  Bcast:172.21.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
...
/ # drill -t ptr `3.0.21.172`.in-addr.arpa
...
;; ANSWER SECTION:
3.0.21.172.in-addr.arpa.	600	IN	PTR	`hello.prod`.
...
```
]

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Building with a custom network

* We can build a Dockerfile with a custom network with `docker build --network NAME`.

* This can be used to check that a build doesn't access the network.

  (But keep in mind that most Dockerfiles will fail,
  <br/>because they need to install remote packages and dependencies!)

* This may be used to access an internal package repository.

  (But try to use a multi-stage build instead, if possible!)

???

:EN:Container networking essentials
:EN:- The Container Network Model
:EN:- Container isolation
:EN:- Service discovery

:FR:Mettre ses conteneurs en réseau
:FR:- Le "Container Network Model"
:FR:- Isolation des conteneurs
:FR:- *Service discovery*

.debug[[containers/Container_Network_Model.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Network_Model.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-gentle-introduction-to-yaml
class: title

 Gentle introduction to YAML

.nav[
[Previous part](#toc-service-discovery-with-containers)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-compose-for-development-stacks)
]

.debug[(automatically generated title slide)]

---
# Gentle introduction to YAML

- YAML Ain't Markup Language (according to [yaml.org][yaml])

- *Almost* required when working with containers:

  - Docker Compose files

  - Kubernetes manifests

  - Many CI pipelines (GitHub, GitLab...)

- If you don't know much about YAML, this is for you!

[yaml]: https://yaml.org/

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## What is it?

- Data representation language

```yaml
- country: France
  capital: Paris
  code: fr
  population: 68042591
- country: Germany
  capital: Berlin
  code: de
  population: 84270625
- country: Norway
  capital: Oslo
  code: no # It's a trap!
  population: 5425270
```

- Even without knowing YAML, we probably can add a country to that file :)

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## Trying YAML

- Method 1: in the browser

  https://onlineyamltools.com/convert-yaml-to-json

  https://onlineyamltools.com/highlight-yaml

- Method 2: in a shell

  ```bash
  yq . foo.yaml
  ```

- Method 3: in Python

  ```python
    import yaml; yaml.safe_load("""
    - country: France
      capital: Paris
    """)
  ```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## Basic stuff

- Strings, numbers, boolean values, `null`

- Sequences (=arrays, lists)

- Mappings (=objects)

- Superset of JSON

  (if you know JSON, you can just write JSON)

- Comments start with `#`

- A single *file* can have multiple *documents*

  (separated by `---` on a single line)

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## Sequences

- Example: sequence of strings
  ```yaml
  [ "france", "germany", "norway" ]
  ```

- Example: the same sequence, without the double-quotes
  ```yaml
  [ france, germany, norway ]
  ```

- Example: the same sequence, in "block collection style" (=multi-line)
  ```yaml
  - france
  - germany
  - norway
  ```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## Mappings

- Example: mapping strings to numbers
  ```yaml
  { "france": 68042591, "germany": 84270625, "norway": 5425270 }
  ```

- Example: the same mapping, without the double-quotes
  ```yaml
  { france: 68042591, germany: 84270625, norway: 5425270 }
  ```

- Example: the same mapping, in "block collection style"
  ```yaml
  france: 68042591
  germany: 84270625
  norway: 5425270
  ```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## Combining types

- In a sequence (or mapping) we can have different types

  (including other sequences or mappings)

- Example:
  ```yaml
  questions: [ name, quest, favorite color ]
  answers: [ "Arthur, King of the Britons", Holy Grail, purple, 42 ]
  ```

- Note that we need to quote "Arthur" because of the comma

- Note that we don't have the same number of elements in questions and answers

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## More combinations

- Example:
  ```yaml
    - service: nginx
      ports: [ 80, 443 ]
    - service: bind
      ports: [ 53/tcp, 53/udp ]
    - service: ssh
      ports: 22
  ```

- Note that `ports` doesn't always have the same type

  (the code handling that data will probably have to be smart!)

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## ⚠️ Automatic booleans

```yaml
codes:
  france: fr
  germany: de
  norway: no
```

--

```json
{
  "codes": {
    "france": "fr",
    "germany": "de",
    "norway": false
  }
}
```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## ⚠️ Automatic booleans

- `no` can become `false`

  (it depends on the YAML parser used)

- It should be quoted instead:

  ```yaml
    codes:
      france: fr
      germany: de
      norway: "no"
  ```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## ⚠️ Automatic floats

```yaml
version:
  libfoo: 1.10
  fooctl: 1.0
```

--

```json
{
  "version": {
    "libfoo": 1.1,
    "fooctl": 1
  }
}
```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## ⚠️ Automatic floats

- Trailing zeros disappear

- These should also be quoted:

  ```yaml
    version:
      libfoo: "1.10"
      fooctl: "1.0"
  ```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## ⚠️ Automatic times

```yaml
portmap:
- 80:80
- 22:22
```

--

```json
{
  "portmap": [
    "80:80",
    1342
  ]
}
```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## ⚠️ Automatic times

- `22:22` becomes `1342`

- Thats 22 minutes and 22 seconds = 1342 seconds

- Again, it should be quoted

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## Document separator

- A single YAML *file* can have multiple *documents* separated by `---`:

  ```yaml
    This is a document consisting of a single string.
    --- 💡
    name: The second document
    type: This one is a mapping (key→value)
    --- 💡
    - Third document
    - This one is a sequence
  ```

- Some folks like to add an extra `---` at the beginning and/or at the end

  (it's not mandatory but can help e.g. to `cat` multiple files together)

.footnote[💡 Ignore this; it's here to work around [this issue][remarkyaml].]

[remarkyaml]: https://github.com/gnab/remark/issues/679

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

## Multi-line strings

Try the following block in a YAML parser:

```yaml
add line breaks: "in double quoted strings\n(like this)"
preserve line break: |
  by using
  a pipe (|)
  (this is great for embedding shell scripts, configuration files...)
do not preserve line breaks: >
  by using
  a greater-than (>)
  (this is great for embedding very long lines)
```

See https://yaml-multiline.info/ for advanced multi-line tips!

(E.g. to strip or keep extra `\n` characters at the end of the block.)

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

class: extra-details

## Advanced features

Anchors let you "memorize" and re-use content:

```yaml
debian: &debian
  packages: deb
  latest-stable: bullseye

also-debian: *debian

ubuntu:
  <<: *debian
  latest-stable: jammy
```

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

class: extra-details

## YAML, good or evil?

- Natural progression from XML to JSON to YAML

- There are other data languages out there

  (e.g. HCL, domain-specific things crafted with Ruby, CUE...)

- Compromises are made, for instance:

  - more user-friendly → more "magic" with side effects

  - more powerful → steeper learning curve

- Love it or loathe it but it's a good idea to understand it!

- Interesting tool if you appreciate YAML: https://carvel.dev/ytt/

???

:EN:- Understanding YAML and its gotchas
:FR:- Comprendre le YAML et ses subtilités

.debug[[shared/yaml.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/yaml.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-compose-for-development-stacks
class: title

 Compose for development stacks

.nav[
[Previous part](#toc-gentle-introduction-to-yaml)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-exercise--writing-a-compose-file)
]

.debug[(automatically generated title slide)]

---
# Compose for development stacks

Dockerfile = great to build *one* container image.

What if we have multiple containers?

What if some of them require particular `docker run` parameters?

How do we connect them all together?

... Compose solves these use-cases (and a few more).

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Life before Compose

Before we had Compose, we would typically write custom scripts to:

- build container images,

- run containers using these images,

- connect the containers together,

- rebuild, restart, update these images and containers.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Life with Compose

Compose enables a simple, powerful onboarding workflow:

1. Checkout our code.

2. Run `docker-compose up`.

3. Our app is up and running!

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

class: pic

![composeup](images/composeup.gif)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Life after Compose

(Or: when do we need something else?)

- Compose is *not* an orchestrator

- It isn't designed to need to run containers on multiple nodes

  (it can, however, work with Docker Swarm Mode)

- Compose isn't ideal if we want to run containers on Kubernetes

  - it uses different concepts (Compose services ≠ Kubernetes services)

  - it needs a Docker Engine (although containerd support might be coming)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## First rodeo with Compose

1. Write Dockerfiles

2. Describe our stack of containers in a YAML file called `docker-compose.yml`

3. `docker-compose up` (or `docker-compose up -d` to run in the background)

4. Compose pulls and builds the required images, and starts the containers

5. Compose shows the combined logs of all the containers

   (if running in the background, use `docker-compose logs`)

6. Hit Ctrl-C to stop the whole stack

   (if running in the background, use `docker-compose stop`)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Iterating

After making changes to our source code, we can:

1. `docker-compose build` to rebuild container images

2. `docker-compose up` to restart the stack with the new images

We can also combine both with `docker-compose up --build`

Compose will be smart, and only recreate the containers that have changed.

When working with interpreted languages:

- don't rebuild each time

- leverage a `volumes` section instead

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Launching Our First Stack with Compose

First step: clone the source code for the app we will be working on.

```bash
git clone https://github.com/jpetazzo/trainingwheels
cd trainingwheels
```

Second step: start the app.

```bash
docker-compose up
```

Watch Compose build and run the app.

That Compose stack exposes a web server on port 8000; try connecting to it.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Launching Our First Stack with Compose

We should see a web page like this:

![composeapp](images/composeapp.png)

Each time we reload, the counter should increase.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Stopping the app

When we hit Ctrl-C, Compose tries to gracefully terminate all of the containers.

After ten seconds (or if we press `^C` again) it will forcibly kill them.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## The `docker-compose.yml` file

Here is the file used in the demo:

.small[
```yaml
version: "3"

services:
  www:
    build: www
    ports:
      - ${PORT-8000}:5000
    user: nobody
    environment:
      DEBUG: 1
    command: python counter.py
    volumes:
      - ./www:/src

  redis:
    image: redis
```
]

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Compose file structure

A Compose file has multiple sections:

* `version` is mandatory. (Typically use "3".)

* `services` is mandatory. Each service corresponds to a container.

* `networks` is optional and indicates to which networks containers should be connected.
  <br/>(By default, containers will be connected on a private, per-compose-file network.)

* `volumes` is optional and can define volumes to be used and/or shared by the containers.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Compose file versions

* Version 1 is legacy and shouldn't be used.

  (If you see a Compose file without `version` and `services`, it's a legacy v1 file.)

* Version 2 added support for networks and volumes.

* Version 3 added support for deployment options (scaling, rolling updates, etc).

* Typically use `version: "3"`.

The [Docker documentation](https://docs.docker.com/compose/compose-file/)
has excellent information about the Compose file format if you need to know more about versions.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Containers in `docker-compose.yml`

Each service in the YAML file must contain either `build`, or `image`.

* `build` indicates a path containing a Dockerfile.

* `image` indicates an image name (local, or on a registry).

* If both are specified, an image will be built from the `build` directory and named `image`.

The other parameters are optional.

They encode the parameters that you would typically add to `docker run`.

Sometimes they have several minor improvements.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Container parameters

* `command` indicates what to run (like `CMD` in a Dockerfile).

* `ports` translates to one (or multiple) `-p` options to map ports.
  <br/>You can specify local ports (i.e. `x:y` to expose public port `x`).

* `volumes` translates to one (or multiple) `-v` options.
  <br/>You can use relative paths here.

For the full list, check: https://docs.docker.com/compose/compose-file/

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Environment variables

- We can use environment variables in Compose files

  (like `$THIS` or `${THAT}`)

- We can provide default values, e.g. `${PORT-8000}`

- Compose will also automatically load the environment file `.env`

  (it should contain `VAR=value`, one per line)

- This is a great way to customize build and run parameters

  (base image versions to use, build and run secrets, port numbers...)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Configuring a Compose stack

- Follow [12-factor app configuration principles][12factorconfig]

  (configure the app through environment variables)

- Provide (in the repo) a default environment file suitable for development

  (no secret or sensitive value)

- Copy the default environment file to `.env` and tweak it

  (or: provide a script to generate `.env` from a template)

[12factorconfig]: https://12factor.net/config

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Running multiple copies of a stack

- Copy the stack in two different directories, e.g. `front` and `frontcopy`

- Compose prefixes images and containers with the directory name:

  `front_www`, `front_www_1`, `front_db_1`

  `frontcopy_www`, `frontcopy_www_1`, `frontcopy_db_1`

- Alternatively, use `docker-compose -p frontcopy` 

  (to set the `--project-name` of a stack, which default to the dir name)

- Each copy is isolated from the others (runs on a different network)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Checking stack status

We have `ps`, `docker ps`, and similarly, `docker-compose ps`:

```bash
$ docker-compose ps
Name                      Command             State           Ports          
----------------------------------------------------------------------------
trainingwheels_redis_1   /entrypoint.sh red   Up      6379/tcp               
trainingwheels_www_1     python counter.py    Up      0.0.0.0:8000->5000/tcp 
```

Shows the status of all the containers of our stack.

Doesn't show the other containers.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Cleaning up (1)

If you have started your application in the background with Compose and
want to stop it easily, you can use the `kill` command:

```bash
$ docker-compose kill
```

Likewise, `docker-compose rm` will let you remove containers (after confirmation):

```bash
$ docker-compose rm
Going to remove trainingwheels_redis_1, trainingwheels_www_1
Are you sure? [yN] y
Removing trainingwheels_redis_1...
Removing trainingwheels_www_1...
```

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Cleaning up (2)

Alternatively, `docker-compose down` will stop and remove containers.

It will also remove other resources, like networks that were created for the application.

```bash
$ docker-compose down
Stopping trainingwheels_www_1 ... done
Stopping trainingwheels_redis_1 ... done
Removing trainingwheels_www_1 ... done
Removing trainingwheels_redis_1 ... done
```

Use `docker-compose down -v` to remove everything including volumes.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Special handling of volumes

- When an image gets updated, Compose automatically creates a new container

- The data in the old container is lost...

- ...Except if the container is using a *volume*

- Compose will then re-attach that volume to the new container

  (and data is then retained across database upgrades)

- All good database images use volumes

  (e.g. all official images)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Gotchas with volumes

- Unfortunately, Docker volumes don't have labels or metadata

- Compose tracks volumes thanks to their associated container

- If the container is deleted, the volume gets orphaned

- Example: `docker-compose down && docker-compose up`

  - the old volume still exists, detached from its container

  - a new volume gets created

- `docker-compose down -v`/`--volumes` deletes volumes

  (but **not** `docker-compose down && docker-compose down -v`!)
 
.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Managing volumes explicitly

Option 1: *named volumes*

```yaml
services:
  app:
    volumes:
    - data:/some/path
volumes:
  data:
```

- Volume will be named `<project>_data`

- It won't be orphaned with `docker-compose down`

- It will correctly be removed with `docker-compose down -v`

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Managing volumes explicitly

Option 2: *relative paths*

```yaml
services:
  app:
    volumes:
    - ./data:/some/path
```

- Makes it easy to colocate the app and its data

  (for migration, backups, disk usage accounting...)

- Won't be removed by `docker-compose down -v`

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Managing complex stacks

- Compose provides multiple features to manage complex stacks

  (with many containers)

- `-f`/`--file`/`$COMPOSE_FILE` can be a list of Compose files

  (separated by `:` and merged together)

- Services can be assigned to one or more *profiles*

- `--profile`/`$COMPOSE_PROFILE` can be a list of comma-separated profiles

  (see [Using service profiles][profiles] in the Compose documentation)

- These variables can be set in `.env`

[profiles]: https://docs.docker.com/compose/profiles/

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Dependencies

- A service can have a `depends_on` section

  (listing one or more other services)

- This is used when bringing up individual services

  (e.g. `docker-compose up blah` or `docker-compose run foo`)

⚠️ It doesn't make a service "wait" for another one to be up!

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

class: extra-details

## A bit of history and trivia

- Compose was initially named "Fig"

- Compose is one of the only components of Docker written in Python

  (almost everything else is in Go)

- In 2020, Docker introduced "Compose CLI":

  - `docker compose` command to deploy Compose stacks to some clouds

  - progressively getting feature parity with `docker-compose`

  - also provides numerous improvements (e.g. leverages BuildKit by default)

???

:EN:- Using compose to describe an environment
:EN:- Connecting services together with a *Compose file*

:FR:- Utiliser Compose pour décrire son environnement
:FR:- Écrire un *Compose file* pour connecter les services entre eux

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Compose_For_Dev_Stacks.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-exercise--writing-a-compose-file
class: title

 Exercise — writing a Compose file

.nav[
[Previous part](#toc-compose-for-development-stacks)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-reducing-image-size)
]

.debug[(automatically generated title slide)]

---
# Exercise — writing a Compose file

Let's write a Compose file for the wordsmith app!

The code is at: https://github.com/jpetazzo/wordsmith

.debug[[containers/Exercise_Composefile.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Exercise_Composefile.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-reducing-image-size
class: title

 Reducing image size

.nav[
[Previous part](#toc-exercise--writing-a-compose-file)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-multi-stage-builds)
]

.debug[(automatically generated title slide)]

---
# Reducing image size

* In the previous example, our final image contained:

  * our `hello` program

  * its source code

  * the compiler

* Only the first one is strictly necessary.

* We are going to see how to obtain an image without the superfluous components.

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Can't we remove superfluous files with `RUN`?

What happens if we do one of the following commands?

- `RUN rm -rf ...`

- `RUN apt-get remove ...`

- `RUN make clean ...`

--

This adds a layer which removes a bunch of files.

But the previous layers (which added the files) still exist.

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Removing files with an extra layer

When downloading an image, all the layers must be downloaded.

| Dockerfile instruction | Layer size | Image size |
| ---------------------- | ---------- | ---------- |
| `FROM ubuntu` | Size of base image | Size of base image |
| `...` | ... | Sum of this layer <br/>+ all previous ones |
| `RUN apt-get install somepackage` | Size of files added <br/>(e.g. a few MB) | Sum of this layer <br/>+ all previous ones |
| `...` | ... | Sum of this layer <br/>+ all previous ones |
| `RUN apt-get remove somepackage` | Almost zero <br/>(just metadata) | Same as previous one |

Therefore, `RUN rm` does not reduce the size of the image or free up disk space.

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Removing unnecessary files

Various techniques are available to obtain smaller images:

- collapsing layers,

- adding binaries that are built outside of the Dockerfile,

- squashing the final image,

- multi-stage builds.

Let's review them quickly.

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Collapsing layers

You will frequently see Dockerfiles like this:

```dockerfile
FROM ubuntu
RUN apt-get update && apt-get install xxx && ... && apt-get remove xxx && ...
```

Or the (more readable) variant:

```dockerfile
FROM ubuntu
RUN apt-get update \
 && apt-get install xxx \
 && ... \
 && apt-get remove xxx \
 && ...
```

This `RUN` command gives us a single layer.

The files that are added, then removed in the same layer, do not grow the layer size.

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Collapsing layers: pros and cons

Pros:

- works on all versions of Docker

- doesn't require extra tools

Cons:

- not very readable

- some unnecessary files might still remain if the cleanup is not thorough

- that layer is expensive (slow to build)

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Building binaries outside of the Dockerfile

This results in a Dockerfile looking like this:

```dockerfile
FROM ubuntu
COPY xxx /usr/local/bin
```

Of course, this implies that the file `xxx` exists in the build context.

That file has to exist before you can run `docker build`.

For instance, it can:

- exist in the code repository,
- be created by another tool (script, Makefile...),
- be created by another container image and extracted from the image.

See for instance the [busybox official image](https://github.com/docker-library/busybox/blob/fe634680e32659aaf0ee0594805f74f332619a90/musl/Dockerfile) or this [older busybox image](https://github.com/jpetazzo/docker-busybox).

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Building binaries outside: pros and cons

Pros:

- final image can be very small

Cons:

- requires an extra build tool

- we're back in dependency hell and "works on my machine"

Cons, if binary is added to code repository:

- breaks portability across different platforms

- grows repository size a lot if the binary is updated frequently

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Squashing the final image

The idea is to transform the final image into a single-layer image.

This can be done in (at least) two ways.

- Activate experimental features and squash the final image:
  ```bash
  docker image build --squash ...
  ```

- Export/import the final image.
  ```bash
  docker build -t temp-image .
  docker run --entrypoint true --name temp-container temp-image
  docker export temp-container | docker import - final-image
  docker rm temp-container
  docker rmi temp-image
  ```

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Squashing the image: pros and cons

Pros:

- single-layer images are smaller and faster to download

- removed files no longer take up storage and network resources

Cons:

- we still need to actively remove unnecessary files

- squash operation can take a lot of time (on big images)

- squash operation does not benefit from cache
  <br/>
  (even if we change just a tiny file, the whole image needs to be re-squashed)

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Multi-stage builds

Multi-stage builds allow us to have multiple *stages*.

Each stage is a separate image, and can copy files from previous stages.

We're going to see how they work in more detail.

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-multi-stage-builds
class: title

 Multi-stage builds

.nav[
[Previous part](#toc-reducing-image-size)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-publishing-images-to-the-docker-hub)
]

.debug[(automatically generated title slide)]

---

# Multi-stage builds

* At any point in our `Dockerfile`, we can add a new `FROM` line.

* This line starts a new stage of our build.

* Each stage can access the files of the previous stages with `COPY --from=...`.

* When a build is tagged (with `docker build -t ...`), the last stage is tagged.

* Previous stages are not discarded: they will be used for caching, and can be referenced.

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Multi-stage builds in practice

* Each stage is numbered, starting at `0`

* We can copy a file from a previous stage by indicating its number, e.g.:

  ```dockerfile
  COPY --from=0 /file/from/first/stage /location/in/current/stage
  ```

* We can also name stages, and reference these names:

  ```dockerfile
  FROM golang AS builder
  RUN ...
  FROM alpine
  COPY --from=builder /go/bin/mylittlebinary /usr/local/bin/
  ```

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Multi-stage builds for our C program

We will change our Dockerfile to:

* give a nickname to the first stage: `compiler`

* add a second stage using the same `ubuntu` base image

* add the `hello` binary to the second stage

* make sure that `CMD` is in the second stage 

The resulting Dockerfile is on the next slide.

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Multi-stage build `Dockerfile`

Here is the final Dockerfile:

```dockerfile
FROM ubuntu AS compiler
RUN apt-get update
RUN apt-get install -y build-essential
COPY hello.c /
RUN make hello
FROM ubuntu
COPY --from=compiler /hello /hello
CMD /hello
```

Let's build it, and check that it works correctly:

```bash
docker build -t hellomultistage .
docker run hellomultistage
```

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

## Comparing single/multi-stage build image sizes

List our images with `docker images`, and check the size of:

- the `ubuntu` base image,

- the single-stage `hello` image,

- the multi-stage `hellomultistage` image.

We can achieve even smaller images if we use smaller base images.

However, if we use common base images (e.g. if we standardize on `ubuntu`),
these common images will be pulled only once per node, so they are
virtually "free."

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

class: extra-details

## Build targets

* We can also tag an intermediary stage with the following command:
  ```bash
  docker build --target STAGE --tag NAME
  ```

* This will create an image (named `NAME`) corresponding to stage `STAGE`

* This can be used to easily access an intermediary stage for inspection

  (instead of parsing the output of `docker build` to find out the image ID)

* This can also be used to describe multiple images from a single Dockerfile

  (instead of using multiple Dockerfiles, which could go out of sync)

--

class: extra-details

## Dealing with download caches

* In some cases, our images contain temporary downloaded files or caches

  (examples: packages downloaded by `pip`, Maven, etc.)

* These can sometimes be disabled

  (e.g. `pip install --no-cache-dir ...`)

* The cache can also be cleaned immediately after installing

  (e.g. `pip install ... && rm -rf ~/.cache/pip`)

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

class: extra-details

## Download caches and multi-stage builds

* Download+install packages in a build stage

* Copy the installed packages to a run stage

* Example: in the specific case of Python, use a virtual env

  (install in the virtual env; then copy the virtual env directory)

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

class: extra-details

## Download caches and BuildKit

* BuildKit has a caching feature for run stages

* It can address download caches elegantly

* Example:
  ```bash
  RUN --mount=type=cache,target=/pipcache pip install --cache-dir /pipcache ...
  ```

* The cache won't be in the final image, but it'll persist across builds

???

:EN:Optimizing our images and their build process
:EN:- Leveraging multi-stage builds

:FR:Optimiser les images et leur construction
:FR:- Utilisation d'un *multi-stage build*

.debug[[containers/Multi_Stage_Builds.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Multi_Stage_Builds.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-publishing-images-to-the-docker-hub
class: title

 Publishing images to the Docker Hub

.nav[
[Previous part](#toc-multi-stage-builds)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-tips-for-efficient-dockerfiles)
]

.debug[(automatically generated title slide)]

---
# Publishing images to the Docker Hub

We have built our first images.

We can now publish it to the Docker Hub!

*You don't have to do the exercises in this section,
because they require an account on the Docker Hub, and we
don't want to force anyone to create one.*

*Note, however, that creating an account on the Docker Hub
is free (and doesn't require a credit card), and hosting
public images is free as well.*

.debug[[containers/Publishing_To_Docker_Hub.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Publishing_To_Docker_Hub.md)]
---

## Logging into our Docker Hub account

* This can be done from the Docker CLI:
  ```bash
  docker login
  ```

.warning[When running Docker for Mac/Windows, or
Docker on a Linux workstation, it can (and will when
possible) integrate with your system's keyring to
store your credentials securely. However, on most Linux
servers, it will store your credentials in `~/.docker/config`.]

.debug[[containers/Publishing_To_Docker_Hub.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Publishing_To_Docker_Hub.md)]
---

## Image tags and registry addresses

* Docker images tags are like Git tags and branches.

* They are like *bookmarks* pointing at a specific image ID.

* Tagging an image doesn't *rename* an image: it adds another tag.

* When pushing an image to a registry, the registry address is in the tag.

  Example: `registry.example.net:5000/image`

* What about Docker Hub images?

--

* `jpetazzo/clock` is, in fact, `index.docker.io/jpetazzo/clock`

* `ubuntu` is, in fact, `library/ubuntu`, i.e. `index.docker.io/library/ubuntu`

.debug[[containers/Publishing_To_Docker_Hub.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Publishing_To_Docker_Hub.md)]
---

## Tagging an image to push it on the Hub

* Let's tag our `figlet` image (or any other to our liking):
  ```bash
  docker tag figlet jpetazzo/figlet
  ```

* And push it to the Hub:
  ```bash
  docker push jpetazzo/figlet
  ```

* That's it!

--

* Anybody can now `docker run jpetazzo/figlet` anywhere.

.debug[[containers/Publishing_To_Docker_Hub.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Publishing_To_Docker_Hub.md)]
---

## The goodness of automated builds

* You can link a Docker Hub repository with a GitHub or BitBucket repository

* Each push to GitHub or BitBucket will trigger a build on Docker Hub

* If the build succeeds, the new image is available on Docker Hub

* You can map tags and branches between source and container images

* If you work with public repositories, this is free

.debug[[containers/Publishing_To_Docker_Hub.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Publishing_To_Docker_Hub.md)]
---

class: extra-details

## Setting up an automated build

* We need a Dockerized repository!
* Let's go to https://github.com/jpetazzo/trainingwheels and fork it.
* Go to the Docker Hub (https://hub.docker.com/) and sign-in. Select "Repositories" in the blue navigation menu.
* Select "Create" in the top-right bar, and select "Create Repository+".
* Connect your Docker Hub account to your GitHub account.
* Click "Create" button.
* Then go to "Builds" folder.
* Click on Github icon and select your user and the repository that we just forked.
* In "Build rules" block near page bottom, put `/www` in "Build Context" column (or whichever directory the Dockerfile is in).
* Click "Save and Build" to build the repository immediately (without waiting for a git push).
* Subsequent builds will happen automatically, thanks to GitHub hooks.

.debug[[containers/Publishing_To_Docker_Hub.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Publishing_To_Docker_Hub.md)]
---

## Building on the fly

- Some services can build images on the fly from a repository

- Example: [ctr.run](https://ctr.run/)

.lab[

- Use ctr.run to automatically build a container image and run it:
  ```bash
  docker run ctr.run/github.com/undefinedlabs/hello-world
  ```

]

There might be a long pause before the first layer is pulled,
because the API behind `docker pull` doesn't allow to stream build logs, and there is no feedback during the build.

It is possible to view the build logs by setting up an account on [ctr.run](https://ctr.run/).

???

:EN:- Publishing images to the Docker Hub
:FR:- Publier des images sur le Docker Hub

.debug[[containers/Publishing_To_Docker_Hub.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Publishing_To_Docker_Hub.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-1.jpg)]

---

name: toc-tips-for-efficient-dockerfiles
class: title

 Tips for efficient Dockerfiles

.nav[
[Previous part](#toc-publishing-images-to-the-docker-hub)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-dockerfile-examples)
]

.debug[(automatically generated title slide)]

---
# Tips for efficient Dockerfiles

We will see how to:

* Reduce the number of layers.

* Leverage the build cache so that builds can be faster.

* Embed unit testing in the build process.

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Reducing the number of layers

* Each line in a `Dockerfile` creates a new layer.

* Build your `Dockerfile` to take advantage of Docker's caching system.

* Combine commands by using `&&` to continue commands and `\` to wrap lines.

Note: it is frequent to build a Dockerfile line by line:

```dockerfile
RUN apt-get install thisthing
RUN apt-get install andthatthing andthatotherone
RUN apt-get install somemorestuff
```

And then refactor it trivially before shipping:

```dockerfile
RUN apt-get install thisthing andthatthing andthatotherone somemorestuff
```

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Avoid re-installing dependencies at each build

* Classic Dockerfile problem:

  "each time I change a line of code, all my dependencies are re-installed!"

* Solution: `COPY` dependency lists (`package.json`, `requirements.txt`, etc.)
  by themselves to avoid reinstalling unchanged dependencies every time.

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Example "bad" `Dockerfile`

The dependencies are reinstalled every time, because the build system does not know if `requirements.txt` has been updated.

```bash
FROM python
WORKDIR /src
COPY . .
RUN pip install -qr requirements.txt
EXPOSE 5000
CMD ["python", "app.py"]
```

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Fixed `Dockerfile`

Adding the dependencies as a separate step means that Docker can cache more efficiently and only install them when `requirements.txt` changes.

```bash
FROM python
WORKDIR /src
COPY requirements.txt .
RUN pip install -qr requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]
```

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Be careful with `chown`, `chmod`, `mv`

* Layers cannot store efficiently changes in permissions or ownership.

* Layers cannot represent efficiently when a file is moved either.

* As a result, operations like `chown`, `chmod`, `mv` can be expensive.

* For instance, in the Dockerfile snippet below, each `RUN` line
  creates a layer with an entire copy of `some-file`.

  ```dockerfile
  COPY some-file .
  RUN chown www-data:www-data some-file
  RUN chmod 644 some-file
  RUN mv some-file /var/www
  ```

* How can we avoid that?

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Put files on the right place

* Instead of using `mv`, directly put files at the right place.

* When extracting archives (tar, zip...), merge operations in a single layer.

  Example:

  ```dockerfile
    ...
    RUN wget http://.../foo.tar.gz \
     && tar -zxf foo.tar.gz \
     && mv foo/fooctl /usr/local/bin \
     && rm -rf foo foo.tar.gz
  ...
  ```

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Use `COPY --chown`

* The Dockerfile instruction `COPY` can take a `--chown` parameter.

  Examples:

  ```dockerfile
  ...
  COPY --chown=1000 some-file .
  COPY --chown=1000:1000 some-file .
  COPY --chown=www-data:www-data some-file .
  ```

* The `--chown` flag can specify a user, or a user:group pair.

* The user and group can be specified as names or numbers.

* When using names, the names must exist in `/etc/passwd` or `/etc/group`.

  *(In the container, not on the host!)*

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Set correct permissions locally

* Instead of using `chmod`, set the right file permissions locally.

* When files are copied with `COPY`, permissions are preserved.

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Embedding unit tests in the build process

```dockerfile
FROM <baseimage>
RUN <install dependencies>
COPY <code>
RUN <build code>
RUN <install test dependencies>
COPY <test data sets and fixtures>
RUN <unit tests>
FROM <baseimage>
RUN <install dependencies>
COPY <code>
RUN <build code>
CMD, EXPOSE ...
```

* The build fails as soon as an instruction fails
* If `RUN <unit tests>` fails, the build doesn't produce an image
* If it succeeds, it produces a clean image (without test libraries and data)

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-2.jpg)]

---

name: toc-dockerfile-examples
class: title

 Dockerfile examples

.nav[
[Previous part](#toc-tips-for-efficient-dockerfiles)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-exercise--writing-better-dockerfiles)
]

.debug[(automatically generated title slide)]

---

# Dockerfile examples

There are a number of tips, tricks, and techniques that we can use in Dockerfiles.

But sometimes, we have to use different (and even opposed) practices depending on:

- the complexity of our project,

- the programming language or framework that we are using,

- the stage of our project (early MVP vs. super-stable production),

- whether we're building a final image or a base for further images,

- etc.

We are going to show a few examples using very different techniques.

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## When to optimize an image

When authoring official images, it is a good idea to reduce as much as possible:

- the number of layers,

- the size of the final image.

This is often done at the expense of build time and convenience for the image maintainer;
but when an image is downloaded millions of time, saving even a few seconds of pull time
can be worth it.

.small[
```dockerfile
RUN apt-get update && apt-get install -y libpng12-dev libjpeg-dev && rm -rf /var/lib/apt/lists/* \
	&& docker-php-ext-configure gd --with-png-dir=/usr --with-jpeg-dir=/usr \
	&& docker-php-ext-install gd
...
RUN curl -o wordpress.tar.gz -SL https://wordpress.org/wordpress-${WORDPRESS_UPSTREAM_VERSION}.tar.gz \
	&& echo "$WORDPRESS_SHA1 *wordpress.tar.gz" | sha1sum -c - \
	&& tar -xzf wordpress.tar.gz -C /usr/src/ \
	&& rm wordpress.tar.gz \
	&& chown -R www-data:www-data /usr/src/wordpress
```
]

(Source: [Wordpress official image](https://github.com/docker-library/wordpress/blob/618490d4bdff6c5774b84b717979bfe3d6ba8ad1/apache/Dockerfile))

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## When to *not* optimize an image

Sometimes, it is better to prioritize *maintainer convenience*.

In particular, if:

- the image changes a lot,

- the image has very few users (e.g. only 1, the maintainer!),

- the image is built and run on the same machine,

- the image is built and run on machines with a very fast link ...

In these cases, just keep things simple!

(Next slide: a Dockerfile that can be used to preview a Jekyll / github pages site.)

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

```dockerfile
FROM debian:sid

RUN apt-get update -q
RUN apt-get install -yq build-essential make
RUN apt-get install -yq zlib1g-dev
RUN apt-get install -yq ruby ruby-dev
RUN apt-get install -yq python-pygments
RUN apt-get install -yq nodejs
RUN apt-get install -yq cmake
RUN gem install --no-rdoc --no-ri github-pages

COPY . /blog
WORKDIR /blog

VOLUME /blog/_site

EXPOSE 4000
CMD ["jekyll", "serve", "--host", "0.0.0.0", "--incremental"]
```

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Multi-dimensional versioning systems

Images can have a tag, indicating the version of the image.

But sometimes, there are multiple important components, and we need to indicate the versions
for all of them.

This can be done with environment variables:

```dockerfile
ENV PIP=9.0.3 \
    ZC_BUILDOUT=2.11.2 \
    SETUPTOOLS=38.7.0 \
    PLONE_MAJOR=5.1 \
    PLONE_VERSION=5.1.0 \
    PLONE_MD5=76dc6cfc1c749d763c32fff3a9870d8d
```

(Source: [Plone official image](https://github.com/plone/plone.docker/blob/master/5.1/5.1.0/alpine/Dockerfile))

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Entrypoints and wrappers

It is very common to define a custom entrypoint.

That entrypoint will generally be a script, performing any combination of:

- pre-flights checks (if a required dependency is not available, display
  a nice error message early instead of an obscure one in a deep log file),

- generation or validation of configuration files,

- dropping privileges (with e.g. `su` or `gosu`, sometimes combined with `chown`),

- and more.

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## A typical entrypoint script

```dockerfile
 #!/bin/sh
 set -e
 
 # first arg is '-f' or '--some-option'
 # or first arg is 'something.conf'
 if [ "${1#-}" != "$1" ] || [ "${1%.conf}" != "$1" ]; then
 	set -- redis-server "$@"
 fi
 
 # allow the container to be started with '--user'
 if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then
 	chown -R redis .
 	exec su-exec redis "$0" "$@"
 fi
 
 exec "$@"
```

(Source: [Redis official image](https://github.com/docker-library/redis/blob/d24f2be82673ccef6957210cc985e392ebdc65e4/4.0/alpine/docker-entrypoint.sh))

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Factoring information

To facilitate maintenance (and avoid human errors), avoid to repeat information like:

- version numbers,

- remote asset URLs (e.g. source tarballs) ...

Instead, use environment variables.

.small[
```dockerfile
ENV NODE_VERSION 10.2.1
...
RUN ...
    && curl -fsSLO --compressed "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION.tar.xz" \
    && curl -fsSLO --compressed "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \
    && gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \
    && grep " node-v$NODE_VERSION.tar.xz\$" SHASUMS256.txt | sha256sum -c - \
    && tar -xf "node-v$NODE_VERSION.tar.xz" \
    && cd "node-v$NODE_VERSION" \
...
```
]

(Source: [Nodejs official image](https://github.com/nodejs/docker-node/blob/master/10/alpine/Dockerfile))

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Overrides

In theory, development and production images should be the same.

In practice, we often need to enable specific behaviors in development (e.g. debug statements).

One way to reconcile both needs is to use Compose to enable these behaviors.

Let's look at the [trainingwheels](https://github.com/jpetazzo/trainingwheels) demo app for an example.

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Production image

This Dockerfile builds an image leveraging gunicorn:

```dockerfile
FROM python
RUN pip install flask
RUN pip install gunicorn
RUN pip install redis
COPY . /src
WORKDIR /src
CMD gunicorn --bind 0.0.0.0:5000 --workers 10 counter:app
EXPOSE 5000
```

(Source: [trainingwheels Dockerfile](https://github.com/jpetazzo/trainingwheels/blob/master/www/Dockerfile))

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## Development Compose file

This Compose file uses the same image, but with a few overrides for development:

- the Flask development server is used (overriding `CMD`),

- the `DEBUG` environment variable is set,

- a volume is used to provide a faster local development workflow.

.small[
```yaml
services:
  www:
    build: www
    ports:
      - 8000:5000
    user: nobody
    environment:
      DEBUG: 1
    command: python counter.py
    volumes:
      - ./www:/src
```
]

(Source: [trainingwheels Compose file](https://github.com/jpetazzo/trainingwheels/blob/master/docker-compose.yml))

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

## How to know which best practices are better?

- The main goal of containers is to make our lives easier.

- In this chapter, we showed many ways to write Dockerfiles.

- These Dockerfiles use sometimes diametrically opposed techniques.

- Yet, they were the "right" ones *for a specific situation.*

- It's OK (and even encouraged) to start simple and evolve as needed.

- Feel free to review this chapter later (after writing a few Dockerfiles) for inspiration!

???

:EN:Optimizing images
:EN:- Dockerfile tips, tricks, and best practices
:EN:- Reducing build time
:EN:- Reducing image size

:FR:Optimiser ses images
:FR:- Bonnes pratiques, trucs et astuces
:FR:- Réduire le temps de build
:FR:- Réduire la taille des images

.debug[[containers/Dockerfile_Tips.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Dockerfile_Tips.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/two-containers-on-a-truck.jpg)]

---

name: toc-exercise--writing-better-dockerfiles
class: title

 Exercise — writing better Dockerfiles

.nav[
[Previous part](#toc-dockerfile-examples)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-managing-hosts-with-docker-machine)
]

.debug[(automatically generated title slide)]

---
# Exercise — writing better Dockerfiles

Let's update our Dockerfiles to leverage multi-stage builds!

The code is at: https://github.com/jpetazzo/wordsmith

Use a different tag for these images, so that we can compare their sizes.

What's the size difference between single-stage and multi-stage builds?

.debug[[containers/Exercise_Dockerfile_Advanced.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Exercise_Dockerfile_Advanced.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/wall-of-containers.jpeg)]

---

name: toc-managing-hosts-with-docker-machine
class: title

 Managing hosts with Docker Machine

.nav[
[Previous part](#toc-exercise--writing-better-dockerfiles)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-advanced-dockerfile-syntax)
]

.debug[(automatically generated title slide)]

---
# Managing hosts with Docker Machine

- Docker Machine is a tool to provision and manage Docker hosts.

- It automates the creation of a virtual machine:

  - locally, with a tool like VirtualBox or VMware;

  - on a public cloud like AWS EC2, Azure, Digital Ocean, GCP, etc.;

  - on a private cloud like OpenStack.

- It can also configure existing machines through an SSH connection.

- It can manage as many hosts as you want, with as many "drivers" as you want.

.debug[[containers/Docker_Machine.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Machine.md)]
---

## Docker Machine workflow

1) Prepare the environment: setup VirtualBox, obtain cloud credentials ...

2) Create hosts with `docker-machine create -d drivername machinename`.

3) Use a specific machine with `eval $(docker-machine env machinename)`.

4) Profit!

.debug[[containers/Docker_Machine.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Machine.md)]
---

## Environment variables

- Most of the tools (CLI, libraries...) connecting to the Docker API can use environment variables.

- These variables are:

  - `DOCKER_HOST` (indicates address+port to connect to, or path of UNIX socket)

  - `DOCKER_TLS_VERIFY` (indicates that TLS mutual auth should be used)

  - `DOCKER_CERT_PATH` (path to the keypair and certificate to use for auth)

- `docker-machine env ...` will generate the variables needed to connect to a host.

- `$(eval docker-machine env ...)` sets these variables in the current shell.

.debug[[containers/Docker_Machine.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Machine.md)]
---

## Host management features

With `docker-machine`, we can:

- upgrade a host to the latest version of the Docker Engine,

- start/stop/restart hosts,

- get a shell on a remote machine (with SSH),

- copy files to/from remotes machines (with SCP),

- mount a remote host's directory on the local machine (with SSHFS),

- ...

.debug[[containers/Docker_Machine.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Machine.md)]
---

## The `generic` driver

When provisioning a new host, `docker-machine` executes these steps:

1) Create the host using a cloud or hypervisor API.

2) Connect to the host over SSH.

3) Install and configure Docker on the host.

With the `generic` driver, we provide the IP address of an existing host
(instead of e.g. cloud credentials) and we omit the first step.

This allows to provision physical machines, or VMs provided by a 3rd
party, or use a cloud for which we don't have a provisioning API.

.debug[[containers/Docker_Machine.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Docker_Machine.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/catene-de-conteneurs.jpg)]

---

name: toc-advanced-dockerfile-syntax
class: title

 Advanced Dockerfile Syntax

.nav[
[Previous part](#toc-managing-hosts-with-docker-machine)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-buildkit)
]

.debug[(automatically generated title slide)]

---

class: title

# Advanced Dockerfile Syntax

![construction](images/title-advanced-dockerfiles.jpg)

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## Objectives

We have seen simple Dockerfiles to illustrate how Docker build
container images.

In this section, we will give a recap of the Dockerfile syntax,
and introduce advanced Dockerfile commands that we might
come across sometimes; or that we might want to use in some
specific scenarios.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## `Dockerfile` usage summary

* `Dockerfile` instructions are executed in order.

* Each instruction creates a new layer in the image.

* Docker maintains a cache with the layers of previous builds.

* When there are no changes in the instructions and files making a layer,
  the builder re-uses the cached layer, without executing the instruction for that layer.

* The `FROM` instruction MUST be the first non-comment instruction.

* Lines starting with `#` are treated as comments.

* Some instructions (like `CMD` or `ENTRYPOINT`) update a piece of metadata.

  (As a result, each call to these instructions makes the previous one useless.)

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## The `RUN` instruction

The `RUN` instruction can be specified in two ways.

With shell wrapping, which runs the specified command inside a shell,
with `/bin/sh -c`:

```dockerfile
RUN apt-get update
```

Or using the `exec` method, which avoids shell string expansion, and
allows execution in images that don't have `/bin/sh`:

```dockerfile
RUN [ "apt-get", "update" ]
```

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## More about the `RUN` instruction

`RUN` will do the following:

* Execute a command.
* Record changes made to the filesystem.
* Work great to install libraries, packages, and various files.

`RUN` will NOT do the following:

* Record state of *processes*.
* Automatically start daemons.

If you want to start something automatically when the container runs,
you should use `CMD` and/or `ENTRYPOINT`.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## Collapsing layers

It is possible to execute multiple commands in a single step:

```dockerfile
RUN apt-get update && apt-get install -y wget && apt-get clean
```

It is also possible to break a command onto multiple lines:

```dockerfile
RUN apt-get update \
 && apt-get install -y wget \
 && apt-get clean
```

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## The `EXPOSE` instruction

The `EXPOSE` instruction tells Docker what ports are to be published
in this image.

```dockerfile
EXPOSE 8080
EXPOSE 80 443
EXPOSE 53/tcp 53/udp
```

* All ports are private by default.

* Declaring a port with `EXPOSE` is not enough to make it public.

* The `Dockerfile` doesn't control on which port a service gets exposed.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## Exposing ports

* When you `docker run -p <port> ...`, that port becomes public.

    (Even if it was not declared with `EXPOSE`.)

* When you `docker run -P ...` (without port number), all ports
  declared with `EXPOSE` become public.

A *public port* is reachable from other containers and from outside the host.

A *private port* is not reachable from outside.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## The `COPY` instruction

The `COPY` instruction adds files and content from your host into the
image.

```dockerfile
COPY . /src
```

This will add the contents of the *build context* (the directory
passed as an argument to `docker build`) to the directory `/src`
in the container.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## Build context isolation

Note: you can only reference files and directories *inside* the
build context. Absolute paths are taken as being anchored to
the build context, so the two following lines are equivalent:

```dockerfile
COPY . /src
COPY / /src
```

Attempts to use `..` to get out of the build context will be
detected and blocked with Docker, and the build will fail.

Otherwise, a `Dockerfile` could succeed on host A, but fail on host B.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## `ADD`

`ADD` works almost like `COPY`, but has a few extra features.

`ADD` can get remote files:

```dockerfile
ADD http://www.example.com/webapp.jar /opt/
```

This would download the `webapp.jar` file and place it in the `/opt`
directory.

`ADD` will automatically unpack zip files and tar archives:

```dockerfile
ADD ./assets.zip /var/www/htdocs/assets/
```

This would unpack `assets.zip` into `/var/www/htdocs/assets`.

*However,* `ADD` will not automatically unpack remote archives.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## `ADD`, `COPY`, and the build cache

* Before creating a new layer, Docker checks its build cache.

* For most Dockerfile instructions, Docker only looks at the
  `Dockerfile` content to do the cache lookup.

* For `ADD` and `COPY` instructions, Docker also checks if the files
  to be added to the container have been changed.

* `ADD` always needs to download the remote file before
  it can check if it has been changed.

  (It cannot use,
  e.g., ETags or If-Modified-Since headers.)

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## `VOLUME`

The `VOLUME` instruction tells Docker that a specific directory
should be a *volume*.

```dockerfile
VOLUME /var/lib/mysql
```

Filesystem access in volumes bypasses the copy-on-write layer,
offering native performance to I/O done in those directories.

Volumes can be attached to multiple containers, allowing to
"port" data over from a container to another, e.g. to
upgrade a database to a newer version.

It is possible to start a container in "read-only" mode.
The container filesystem will be made read-only, but volumes
can still have read/write access if necessary.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## The `WORKDIR` instruction

The `WORKDIR` instruction sets the working directory for subsequent
instructions.

It also affects `CMD` and `ENTRYPOINT`, since it sets the working
directory used when starting the container.
   
```dockerfile
WORKDIR /src
```

You can specify `WORKDIR` again to change the working directory for
further operations.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## The `ENV` instruction

The `ENV` instruction specifies environment variables that should be
set in any container launched from the image.

```dockerfile
ENV WEBAPP_PORT 8080
```

This will result in an environment variable being created in any
containers created from this image of

```bash
WEBAPP_PORT=8080
```

You can also specify environment variables when you use `docker run`.

```bash
$ docker run -e WEBAPP_PORT=8000 -e WEBAPP_HOST=www.example.com ...
```

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## The `USER` instruction

The `USER` instruction sets the user name or UID to use when running
the image.

It can be used multiple times to change back to root or to another user.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## The `CMD` instruction

The `CMD` instruction is a default command run when a container is
launched from the image.

```dockerfile
CMD [ "nginx", "-g", "daemon off;" ]
```

Means we don't need to specify `nginx -g "daemon off;"` when running the
container.

Instead of:

```bash
$ docker run <dockerhubUsername>/web_image nginx -g "daemon off;"
```

We can just do:

```bash
$ docker run <dockerhubUsername>/web_image
```

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## More about the `CMD` instruction

Just like `RUN`, the `CMD` instruction comes in two forms.
The first executes in a shell:

```dockerfile
CMD nginx -g "daemon off;"
```

The second executes directly, without shell processing:

```dockerfile
CMD [ "nginx", "-g", "daemon off;" ]
```

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

class: extra-details

## Overriding the `CMD` instruction

The `CMD` can be overridden when you run a container.

```bash
$ docker run -it <dockerhubUsername>/web_image bash
```

Will run `bash` instead of `nginx -g "daemon off;"`.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## The `ENTRYPOINT` instruction

The `ENTRYPOINT` instruction is like the `CMD` instruction,
but arguments given on the command line are *appended* to the
entry point.

Note: you have to use the "exec" syntax (`[ "..." ]`).

```dockerfile
ENTRYPOINT [ "/bin/ls" ]
```

If we were to run:

```bash
$ docker run training/ls -l
```

Instead of trying to run `-l`, the container will run `/bin/ls -l`.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

class: extra-details

## Overriding the `ENTRYPOINT` instruction

The entry point can be overridden as well.

```bash
$ docker run -it training/ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
$ docker run -it --entrypoint bash training/ls
root@d902fb7b1fc7:/#
```

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## How `CMD` and `ENTRYPOINT` interact

The `CMD` and `ENTRYPOINT` instructions work best when used
together.

```dockerfile
ENTRYPOINT [ "nginx" ]
CMD [ "-g", "daemon off;" ]
```

The `ENTRYPOINT` specifies the command to be run and the `CMD`
specifies its options. On the command line we can then potentially
override the options when needed.

```bash
$ docker run -d <dockerhubUsername>/web_image -t
```

This will override the options `CMD` provided with new flags.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

## Advanced Dockerfile instructions

* `ONBUILD` lets you stash instructions that will be executed
  when this image is used as a base for another one.
* `LABEL` adds arbitrary metadata to the image.
* `ARG` defines build-time variables (optional or mandatory).
* `STOPSIGNAL` sets the signal for `docker stop` (`TERM` by default).
* `HEALTHCHECK` defines a command assessing the status of the container.
* `SHELL` sets the default program to use for string-syntax RUN, CMD, etc.

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

class: extra-details

## The `ONBUILD` instruction

The `ONBUILD` instruction is a trigger. It sets instructions that will
be executed when another image is built from the image being build.

This is useful for building images which will be used as a base
to build other images.

```dockerfile
ONBUILD COPY . /src
```

* You can't chain `ONBUILD` instructions with `ONBUILD`.
* `ONBUILD` can't be used to trigger `FROM` instructions.

???

:EN:- Advanced Dockerfile syntax
:FR:- Dockerfile niveau expert

.debug[[containers/Advanced_Dockerfiles.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Advanced_Dockerfiles.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-buildkit
class: title

 Buildkit

.nav[
[Previous part](#toc-advanced-dockerfile-syntax)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-init-systems-and-pid-)
]

.debug[(automatically generated title slide)]

---
# Buildkit

- "New" backend for Docker builds

  - announced in 2017

  - ships with Docker Engine 18.09

  - enabled by default on Docker Desktop in 2021

- Huge improvements in build efficiency

- 100% compatible with existing Dockerfiles

- New features for multi-arch

- Not just for building container images

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Old vs New

- Classic `docker build`:

  - copy whole build context
  - linear execution
  - `docker run` + `docker commit` + `docker run` + `docker commit`...

- Buildkit:

  - copy files only when they are needed; cache them
  - compute dependency graph (dependencies are expressed by `COPY`)
  - parallel execution
  - doesn't rely on Docker, but on internal runner/snapshotter
  - can run in "normal" containers (including in Kubernetes pods)

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Parallel execution

- In multi-stage builds, all stages can be built in parallel

  (example: https://github.com/jpetazzo/shpod; [before] and [after])

- Stages are built only when they are necessary

  (i.e. if their output is tagged or used in another necessary stage)

- Files are copied from context only when needed

- Files are cached in the builder

[before]: https://github.com/jpetazzo/shpod/blob/c6efedad6d6c3dc3120dbc0ae0a6915f85862474/Dockerfile
[after]: https://github.com/jpetazzo/shpod/blob/d20887bbd56b5fcae2d5d9b0ce06cae8887caabf/Dockerfile

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Turning it on and off

- On recent version of Docker Desktop (since 2021):

  *enabled by default*

- On older versions, or on Docker CE (Linux):

  `export DOCKER_BUILDKIT=1`

- Turning it off:

  `export DOCKER_BUILDKIT=0`

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Multi-arch support

- Historically, Docker only ran on x86_64 / amd64

  (Intel/AMD 64 bits architecture)

- Folks have been running it on 32-bit ARM for ages

  (e.g. Raspberry Pi)

- This required a Go compiler and appropriate base images

  (which means changing/adapting Dockerfiles to use these base images)

- Docker [image manifest v2 schema 2][manifest] introduces multi-arch images

  (`FROM alpine` automatically gets the right image for your architecture)

[manifest]: https://docs.docker.com/registry/spec/manifest-v2-2/

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Why?

- Raspberry Pi (32-bit and 64-bit ARM)

- Other ARM-based embedded systems (ODROID, NVIDIA Jetson...)

- Apple M1, M2...

- AWS Graviton

- Ampere Altra (e.g. on Hetzner, Oracle Cloud, Scaleway...)

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Multi-arch builds in a nutshell

Use the `docker buildx build` command:

```bash
docker buildx build … \
       --platform linux/amd64,linux/arm64,linux/arm/v7,linux/386 \
       [--tag jpetazzo/hello --push]
```

- Requires all base images to be available for these platforms

- Must not use binary downloads with hard-coded architectures!

  (streamlining a Dockerfile for multi-arch: [before], [after])

[before]: https://github.com/jpetazzo/shpod/blob/d20887bbd56b5fcae2d5d9b0ce06cae8887caabf/Dockerfile
[after]: https://github.com/jpetazzo/shpod/blob/c50789e662417b34fea6f5e1d893721d66d265b7/Dockerfile

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Native vs emulated vs cross

- Native builds:

  *aarch64 machine running aarch64 programs building aarch64 images/binaries*

- Emulated builds:

  *x86_64 machine running aarch64 programs building aarch64 images/binaries*

- Cross builds:

  *x86_64 machine running x86_64 programs building aarch64 images/binaries*

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Native

- Dockerfiles are (relatively) simple to write

  (nothing special to do to handle multi-arch; just avoid hard-coded archs)

- Best performance

- Requires "exotic" machines

- Requires setting up a build farm

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Emulated

- Dockerfiles are (relatively) simple to write

- Emulation performance can vary

  (from "OK" to "ouch this is slow")

- Emulation isn't always perfect

  (weird bugs/crashes are rare but can happen)

- Doesn't require special machines

- Supports arbitrary architectures thanks to QEMU

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Cross

- Dockerfiles are more complicated to write

- Requires cross-compilation toolchains

- Performance is good

- Doesn't require special machines

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Native builds

- Requires base images to be available

- To view available architectures for an image:
  ```bash
  regctl manifest get --list <imagename>
  docker manifest inspect <imagename>
  ```

- Nothing special to do, *except* when downloading binaries!

  ```
  https://releases.hashicorp.com/terraform/1.1.5/terraform_1.1.5_linux_`amd64`.zip
  ```

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Finding the right architecture

`uname -m` → armv7l, aarch64, i686, x86_64

`GOARCH` (from `go env`) → arm, arm64, 386, amd64

In Dockerfile, add `ARG TARGETARCH` (or `ARG TARGETPLATFORM`)

- `TARGETARCH` matches `GOARCH`

- `TARGETPLAFORM` → linux/arm/v7, linux/arm64, linux/386, linux/amd64

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

class: extra-details

## Welp

Sometimes, binary releases be like:

```
Linux_arm64.tar.gz
Linux_ppc64le.tar.gz
Linux_s390x.tar.gz
Linux_x86_64.tar.gz 
```

This needs a bit of custom mapping.

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Emulation

- Leverages `binfmt_misc` and QEMU on Linux

- Enabling:
  ```bash
  docker run --rm --privileged aptman/qus -s -- -p
  ```

- Disabling:
  ```bash
  docker run --rm --privileged aptman/qus -- -r
  ```

- Checking status:
  ```bash
  ls -l /proc/sys/fs/binfmt_misc
  ```

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

class: extra-details

## How it works

- `binfmt_misc` lets us register _interpreters_ for binaries, e.g.:

  - [DOSBox][dosbox] for DOS programs

  - [Wine][wine] for Windows programs

  - [QEMU][qemu] for Linux programs for other architectures

- When we try to execute e.g. a SPARC binary on our x86_64 machine:

  - `binfmt_misc` detects the binary format and invokes `qemu-<arch> the-binary ...`

  - QEMU translates SPARC instructions to x86_64 instructions

  - system calls go straight to the kernel

[dosbox]: https://www.dosbox.com/
[QEMU]: https://www.qemu.org/
[wine]: https://www.winehq.org/

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

class: extra-details

## QEMU registration

- The `aptman/qus` image mentioned earlier contains static QEMU builds

- It registers all these interpreters with the kernel

- For more details, check:

  - https://github.com/dbhi/qus

  - https://dbhi.github.io/qus/

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Cross-compilation

- Cross-compilation is about 10x faster than emulation

  (non-scientific benchmarks!)

- In Dockerfile, add:

  `ARG BUILDARCH BUILDPLATFORM TARGETARCH TARGETPLATFORM`

- Can use `FROM --platform=$BUILDPLATFORM <image>`

- Then use `$TARGETARCH` or `$TARGETPLATFORM`

  (e.g. for Go, `export GOARCH=$TARGETARCH`)

- Check [tonistiigi/xx][xx] and [Toni's blog][toni] for some amazing cross tools!

[xx]: https://github.com/tonistiigi/xx
[toni]: https://medium.com/@tonistiigi/faster-multi-platform-builds-dockerfile-cross-compilation-guide-part-1-ec087c719eaf

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Checking runtime capabilities

Build and run the following Dockerfile:

```dockerfile
FROM --platform=linux/amd64 busybox AS amd64
FROM --platform=linux/arm64 busybox AS arm64
FROM --platform=linux/arm/v7 busybox AS arm32
FROM --platform=linux/386 busybox AS ia32
FROM alpine
RUN apk add file
WORKDIR /root
COPY --from=amd64 /bin/busybox /root/amd64/busybox
COPY --from=arm64 /bin/busybox /root/arm64/busybox
COPY --from=arm32 /bin/busybox /root/arm32/busybox
COPY --from=ia32 /bin/busybox /root/ia32/busybox
CMD for A in *; do echo "$A => $($A/busybox uname -a)"; done
```

It will indicate which executables can be run on your engine.

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## Cache directories

```bash
RUN --mount=type=cache,target=/pipcache pip install --cache-dir /pipcache ...
```

- The `/pipcache` directory won't be in the final image

- But it will persist across builds

- This can simplify Dockerfiles a lot

  - we no longer need to `download package && install package && rm package`

  - download to a cache directory, and skip `rm` phase

- Subsequent builds will also be faster, thanks to caching

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

## More than builds

- Buildkit is also used in other systems:

  - [Earthly] - generic repeatable build pipelines

  - [Dagger] - CICD pipelines that run anywhere

  - and more!

[Earthly]: https://earthly.dev/
[Dagger]: https://dagger.io/

.debug[[containers/Buildkit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Buildkit.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-init-systems-and-pid-
class: title

 Init systems and PID 1

.nav[
[Previous part](#toc-buildkit)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-application-configuration)
]

.debug[(automatically generated title slide)]

---
# Init systems and PID 1

In this chapter, we will consider:

- the role of PID 1 in the world of Docker,

- how to avoid some common pitfalls due to the misuse of init systems.

.debug[[containers/Init_Systems.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Init_Systems.md)]
---

## What's an init system?

- On UNIX, the "init system" (or "init" in short) is PID 1.

- It is the first process started by the kernel when the system starts.

- It has multiple responsibilities:

  - start every other process on the machine,

  - reap orphaned zombie processes.

.debug[[containers/Init_Systems.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Init_Systems.md)]
---

class: extra-details

## Orphaned zombie processes ?!?

- When a process exits (or "dies"), it becomes a "zombie".

  (Zombie processes show up in `ps` or `top` with the status code `Z`.)

- Its parent process must *reap* the zombie process.

  (This is done by calling `waitpid()` to retrieve the process' exit status.)

- When a process exits, if it has child processes, these processes are "orphaned."

- They are then re-parented to PID 1, init.

- Init therefore needs to take care of these orphaned processes when they exit.

.debug[[containers/Init_Systems.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Init_Systems.md)]
---

## Don't use init systems in containers

- It's often tempting to use an init system or a process manager.

  (Examples: *systemd*, *supervisord*...)

- Our containers are then called "system containers".

  (By contrast with "application containers".)

- "System containers" are similar to lightweight virtual machines.

- They have multiple downsides:

  - when starting multiple processes, their logs get mixed on stdout,

  - if the application process dies, the container engine doesn't see it.

- Overall, they make it harder to operate troubleshoot containerized apps.

.debug[[containers/Init_Systems.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Init_Systems.md)]
---

## Exceptions and workarounds

- Sometimes, it's convenient to run a real init system like *systemd*.

  (Example: a CI system whose goal is precisely to test an init script or unit file.)

- If we need to run multiple processes: can we use multiple containers?

  (Example: [this Compose file](https://github.com/jpetazzo/container.training/blob/master/compose/simple-k8s-control-plane/docker-compose.yaml) runs multiple processes together.)

- When deploying with Kubernetes:

  - a container belong to a pod,

  - a pod can have multiple containers.

.debug[[containers/Init_Systems.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Init_Systems.md)]
---

## What about these zombie processes?

- Our application runs as PID 1 in the container.

- Our application may or may not be designed to reap zombie processes.

- If our application uses subprocesses and doesn't reap them ...

  ... this can lead to PID exhaustion!

  (Or, more realistically, to a confusing herd of zombie processes.)

- How can we solve this?

.debug[[containers/Init_Systems.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Init_Systems.md)]
---

## Tini to the rescue

- Docker can automatically provide a minimal `init` process.

- This is enabled with `docker run --init ...`

- It uses a small init system ([tini](https://github.com/krallin/tini)) as PID 1:

  - it reaps zombies,

  - it forwards signals,

  - it exits when the child exits.

- It is totally transparent to our application.

- We should use it if our application creates subprocess but doesn't reap them.

.debug[[containers/Init_Systems.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Init_Systems.md)]
---

class: extra-details

## What about Kubernetes?

- Kubernetes does not expose that `--init` option.

- However, we can achieve the same result with [Process Namespace Sharing](https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/).

- When Process Namespace Sharing is enabled, PID 1 will be `pause`.

- That `pause` process takes care of reaping zombies.

- Process Namespace Sharing is available since Kubernetes 1.16.

- If you're using an older version of Kubernetes ...

  ... you might have to add `tini` explicitly to your Docker image.

.debug[[containers/Init_Systems.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Init_Systems.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-application-configuration
class: title

 Application Configuration

.nav[
[Previous part](#toc-init-systems-and-pid-)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-logging)
]

.debug[(automatically generated title slide)]

---
# Application Configuration

There are many ways to provide configuration to containerized applications.

There is no "best way" — it depends on factors like:

* configuration size,

* mandatory and optional parameters,

* scope of configuration (per container, per app, per customer, per site, etc),

* frequency of changes in the configuration.

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Command-line parameters

```bash
docker run jpetazzo/hamba 80 www1:80 www2:80
```

* Configuration is provided through command-line parameters.

* In the above example, the `ENTRYPOINT` is a script that will:

  - parse the parameters,

  - generate a configuration file,

  - start the actual service.

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Command-line parameters pros and cons

* Appropriate for mandatory parameters (without which the service cannot start).

* Convenient for "toolbelt" services instantiated many times.

  (Because there is no extra step: just run it!)

* Not great for dynamic configurations or bigger configurations.

  (These things are still possible, but more cumbersome.)

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Environment variables

```bash
docker run -e ELASTICSEARCH_URL=http://es42:9201/ kibana
```

* Configuration is provided through environment variables.

* The environment variable can be used straight by the program,
  <br/>or by a script generating a configuration file.

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Environment variables pros and cons

* Appropriate for optional parameters (since the image can provide default values).

* Also convenient for services instantiated many times.

  (It's as easy as command-line parameters.)

* Great for services with lots of parameters, but you only want to specify a few.

  (And use default values for everything else.)

* Ability to introspect possible parameters and their default values.

* Not great for dynamic configurations.

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Baked-in configuration

```
FROM prometheus
COPY prometheus.conf /etc
```

* The configuration is added to the image.

* The image may have a default configuration; the new configuration can:

  - replace the default configuration,

  - extend it (if the code can read multiple configuration files).

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Baked-in configuration pros and cons

* Allows arbitrary customization and complex configuration files.

* Requires writing a configuration file. (Obviously!)

* Requires building an image to start the service.

* Requires rebuilding the image to reconfigure the service.

* Requires rebuilding the image to upgrade the service.

* Configured images can be stored in registries.

  (Which is great, but requires a registry.)

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Configuration volume

```bash
docker run -v appconfig:/etc/appconfig myapp
```

* The configuration is stored in a volume.

* The volume is attached to the container.

* The image may have a default configuration.

  (But this results in a less "obvious" setup, that needs more documentation.)

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Configuration volume pros and cons

* Allows arbitrary customization and complex configuration files.

* Requires creating a volume for each different configuration.

* Services with identical configurations can use the same volume.

* Doesn't require building / rebuilding an image when upgrading / reconfiguring.

* Configuration can be generated or edited through another container.

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Dynamic configuration volume

* This is a powerful pattern for dynamic, complex configurations.

* The configuration is stored in a volume.

* The configuration is generated / updated by a special container.

* The application container detects when the configuration is changed.

  (And automatically reloads the configuration when necessary.)

* The configuration can be shared between multiple services if needed.

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Dynamic configuration volume example

In a first terminal, start a load balancer with an initial configuration:

```bash
$ docker run --name loadbalancer jpetazzo/hamba \
  80 goo.gl:80
```

In another terminal, reconfigure that load balancer:

```bash
$ docker run --rm --volumes-from loadbalancer jpetazzo/hamba reconfigure \
  80 google.com:80
```

The configuration could also be updated through e.g. a REST API.

(The REST API being itself served from another container.)

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

## Keeping secrets

.warning[Ideally, you should not put secrets (passwords, tokens...) in:]

* command-line or environment variables (anyone with Docker API access can get them),

* images, especially stored in a registry.

Secrets management is better handled with an orchestrator (like Swarm or Kubernetes).

Orchestrators will allow to pass secrets in a "one-way" manner.

Managing secrets securely without an orchestrator can be contrived.

E.g.:

- read the secret on stdin when the service starts,

- pass the secret using an API endpoint.

.debug[[containers/Application_Configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Application_Configuration.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-logging
class: title

 Logging

.nav[
[Previous part](#toc-application-configuration)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-deep-dive-into-container-internals)
]

.debug[(automatically generated title slide)]

---
# Logging

In this chapter, we will explain the different ways to send logs from containers.

We will then show one particular method in action, using ELK and Docker's logging drivers.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## There are many ways to send logs

- The simplest method is to write on the standard output and error.

- Applications can write their logs to local files.

  (The files are usually periodically rotated and compressed.)

- It is also very common (on UNIX systems) to use syslog.

  (The logs are collected by syslogd or an equivalent like journald.)

- In large applications with many components, it is common to use a logging service.

  (The code uses a library to send messages to the logging service.)

*All these methods are available with containers.*

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Writing on stdout/stderr

- The standard output and error of containers is managed by the container engine.

- This means that each line written by the container is received by the engine.

- The engine can then do "whatever" with these log lines.

- With Docker, the default configuration is to write the logs to local files.

- The files can then be queried with e.g. `docker logs` (and the equivalent API request).

- This can be customized, as we will see later.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Writing to local files

- If we write to files, it is possible to access them but cumbersome.

  (We have to use `docker exec` or `docker cp`.)

- Furthermore, if the container is stopped, we cannot use `docker exec`.

- If the container is deleted, the logs disappear.

- What should we do for programs who can only log to local files?

--

- There are multiple solutions.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Using a volume or bind mount

- Instead of writing logs to a normal directory, we can place them on a volume.

- The volume can be accessed by other containers.

- We can run a program like `filebeat` in another container accessing the same volume.

  (`filebeat` reads local log files continuously, like `tail -f`, and sends them
  to a centralized system like ElasticSearch.)

- We can also use a bind mount, e.g. `-v /var/log/containers/www:/var/log/tomcat`.

- The container will write log files to a directory mapped to a host directory.

- The log files will appear on the host and be consumable directly from the host.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Using logging services

- We can use logging frameworks (like log4j or the Python `logging` package).

- These frameworks require some code and/or configuration in our application code.

- These mechanisms can be used identically inside or outside of containers.

- Sometimes, we can leverage containerized networking to simplify their setup.

- For instance, our code can send log messages to a server named `log`.

- The name `log` will resolve to different addresses in development, production, etc.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Using syslog

- What if our code (or the program we are running in containers) uses syslog?

- One possibility is to run a syslog daemon in the container.

- Then that daemon can be setup to write to local files or forward to the network.

- Under the hood, syslog clients connect to a local UNIX socket, `/dev/log`.

- We can expose a syslog socket to the container (by using a volume or bind-mount).

- Then just create a symlink from `/dev/log` to the syslog socket.

- Voilà!

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Using logging drivers

- If we log to stdout and stderr, the container engine receives the log messages.

- The Docker Engine has a modular logging system with many plugins, including:

  - json-file (the default one)
  - syslog
  - journald
  - gelf
  - fluentd
  - splunk
  - etc.

- Each plugin can process and forward the logs to another process or system.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## A word of warning about `json-file`

- By default, log file size is unlimited.

- This means that a very verbose container *will* use up all your disk space.

  (Or a less verbose container, but running for a very long time.)

- Log rotation can be enabled by setting a `max-size` option.

- Older log files can be removed by setting a `max-file` option.

- Just like other logging options, these can be set per container, or globally.

Example:
```bash
$ docker run --log-opt max-size=10m --log-opt max-file=3 elasticsearch
```

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Demo: sending logs to ELK

- We are going to deploy an ELK stack.

- It will accept logs over a GELF socket.

- We will run a few containers with the `gelf` logging driver.

- We will then see our logs in Kibana, the web interface provided by ELK.

*Important foreword: this is not an "official" or "recommended"
setup; it is just an example. We used ELK in this demo because
it's a popular setup and we keep being asked about it; but you
will have equal success with Fluent or other logging stacks!*

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## What's in an ELK stack?

- ELK is three components:

  - ElasticSearch (to store and index log entries)

  - Logstash (to receive log entries from various
    sources, process them, and forward them to various
    destinations)

  - Kibana (to view/search log entries with a nice UI)

- The only component that we will configure is Logstash

- We will accept log entries using the GELF protocol

- Log entries will be stored in ElasticSearch,
  <br/>and displayed on Logstash's stdout for debugging

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Running ELK

- We are going to use a Compose file describing the ELK stack.

- The Compose file is in the container.training repository on GitHub.

```bash
$ git clone https://github.com/jpetazzo/container.training
$ cd container.training
$ cd elk
$ docker-compose up
```

- Let's have a look at the Compose file while it's deploying.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Our basic ELK deployment

- We are using images from the Docker Hub: `elasticsearch`, `logstash`, `kibana`.

- We don't need to change the configuration of ElasticSearch.

- We need to tell Kibana the address of ElasticSearch:

  - it is set with the `ELASTICSEARCH_URL` environment variable,

  - by default it is `localhost:9200`, we change it to `elasticsearch:9200`.

- We need to configure Logstash:

  - we pass the entire configuration file through command-line arguments,

  - this is a hack so that we don't have to create an image just for the config.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Sending logs to ELK

- The ELK stack accepts log messages through a GELF socket.

- The GELF socket listens on UDP port 12201.

- To send a message, we need to change the logging driver used by Docker.

- This can be done globally (by reconfiguring the Engine) or on a per-container basis.

- Let's override the logging driver for a single container:

```bash
$ docker run --log-driver=gelf --log-opt=gelf-address=udp://localhost:12201 \
  alpine echo hello world
```

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Viewing the logs in ELK

- Connect to the Kibana interface.

- It is exposed on port 5601.

- Browse http://X.X.X.X:5601.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## "Configuring" Kibana

- Kibana should offer you to "Configure an index pattern":
  <br/>in the "Time-field name" drop down, select "@timestamp", and hit the
  "Create" button.

- Then:

  - click "Discover" (in the top-left corner),
  - click "Last 15 minutes" (in the top-right corner),
  - click "Last 1 hour" (in the list in the middle),
  - click "Auto-refresh" (top-right corner),
  - click "5 seconds" (top-left of the list).

- You should see a series of green bars (with one new green bar every minute).

- Our 'hello world' message should be visible there.

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

## Important afterword

**This is not a "production-grade" setup.**

It is just an educational example. Since we have only
one node , we did set up a single
ElasticSearch instance and a single Logstash instance.

In a production setup, you need an ElasticSearch cluster
(both for capacity and availability reasons). You also
need multiple Logstash instances.

And if you want to withstand
bursts of logs, you need some kind of message queue:
Redis if you're cheap, Kafka if you want to make sure
that you don't drop messages on the floor. Good luck.

If you want to learn more about the GELF driver,
have a look at [this blog post](
https://jpetazzo.github.io/2017/01/20/docker-logging-gelf/).

.debug[[containers/Logging.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Logging.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-deep-dive-into-container-internals
class: title

 Deep dive into container internals

.nav[
[Previous part](#toc-logging)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-control-groups)
]

.debug[(automatically generated title slide)]

---
# Deep dive into container internals

In this chapter, we will explain some of the fundamental building blocks of containers.

This will give you a solid foundation so you can:

- understand "what's going on" in complex situations,

- anticipate the behavior of containers (performance, security...) in new scenarios,

- implement your own container engine.

The last item should be done for educational purposes only!

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## There is no container code in the Linux kernel

- If we search "container" in the Linux kernel code, we find:

  - generic code to manipulate data structures (like linked lists, etc.),

  - unrelated concepts like "ACPI containers",

  - *nothing* relevant to "our" containers!

- Containers are composed using multiple independent features.

- On Linux, containers rely on "namespaces, cgroups, and some filesystem magic."

- Security also requires features like capabilities, seccomp, LSMs...

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-control-groups
class: title

 Control groups

.nav[
[Previous part](#toc-deep-dive-into-container-internals)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-namespaces)
]

.debug[(automatically generated title slide)]

---

# Control groups

- Control groups provide resource *metering* and *limiting*.

- This covers a number of "usual suspects" like:

  - memory

  - CPU

  - block I/O

  - network (with cooperation from iptables/tc)

- And a few exotic ones:

  - huge pages (a special way to allocate memory)

  - RDMA (resources specific to InfiniBand / remote memory transfer)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Crowd control

- Control groups also allow to group processes for special operations:

  - freezer (conceptually similar to a "mass-SIGSTOP/SIGCONT")

  - perf_event (gather performance events on multiple processes)

  - cpuset (limit or pin processes to specific CPUs)

- There is a "pids" cgroup to limit the number of processes in a given group.

- There is also a "devices" cgroup to control access to device nodes.

  (i.e. everything in `/dev`.)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Generalities

- Cgroups form a hierarchy (a tree).

- We can create nodes in that hierarchy.

- We can associate limits to a node.

- We can move a process (or multiple processes) to a node.

- The process (or processes) will then respect these limits.

- We can check the current usage of each node.

- In other words: limits are optional (if we only want accounting).

- When a process is created, it is placed in its parent's groups.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Example

The numbers are PIDs.

The names are the names of our nodes (arbitrarily chosen).

.small[
```bash
cpu                      memory
├── batch                ├── stateless
│   ├── cryptoscam       │   ├── 25
│   │   └── 52           │   ├── 26
│   └── ffmpeg           │   ├── 27
│       ├── 109          │   ├── 52
│       └── 88           │   ├── 109
└── realtime             │   └── 88
    ├── nginx            └── databases
    │   ├── 25               ├── 1008
    │   ├── 26               └── 524
    │   └── 27
    ├── postgres
    │   └── 524
    └── redis
        └── 1008
```
]

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Cgroups v1 vs v2

- Cgroups v1 are available on all systems (and widely used).

- Cgroups v2 are a huge refactor.

  (Development started in Linux 3.10, released in 4.5.)

- Cgroups v2 have a number of differences:

  - single hierarchy (instead of one tree per controller),

  - processes can only be on leaf nodes (not inner nodes),

  - and of course many improvements / refactorings.

- Cgroups v2 enabled by default on Fedora 31 (2019), Ubuntu 21.10...

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Memory cgroup: accounting

- Keeps track of pages used by each group:

  - file (read/write/mmap from block devices),
  - anonymous (stack, heap, anonymous mmap),
  - active (recently accessed),
  - inactive (candidate for eviction).

- Each page is "charged" to a group.

- Pages can be shared across multiple groups.

  (Example: multiple processes reading from the same files.)

- To view all the counters kept by this cgroup:

  ```bash
  $ cat /sys/fs/cgroup/memory/memory.stat
  ```

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Memory cgroup v1: limits

- Each group can have (optional) hard and soft limits.

- Limits can be set for different kinds of memory:

  - physical memory,

  - kernel memory,

  - total memory (including swap).

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Soft limits and hard limits

- Soft limits are not enforced.

  (But they influence reclaim under memory pressure.)

- Hard limits *cannot* be exceeded:

  - if a group of processes exceeds a hard limit,

  - and if the kernel cannot reclaim any memory,

  - then the OOM (out-of-memory) killer is triggered,

  - and processes are killed until memory gets below the limit again.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Avoiding the OOM killer

- For some workloads (databases and stateful systems), killing
  processes because we run out of memory is not acceptable.

- The "oom-notifier" mechanism helps with that.

- When "oom-notifier" is enabled and a hard limit is exceeded:

  - all processes in the cgroup are frozen,

  - a notification is sent to user space (instead of killing processes),

  - user space can then raise limits, migrate containers, etc.,

  - once the memory usage is below the hard limit, unfreeze the cgroup.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Overhead of the memory cgroup

- Each time a process grabs or releases a page, the kernel update counters.

- This adds some overhead.

- Unfortunately, this cannot be enabled/disabled per process.

- It has to be done system-wide, at boot time.

- Also, when multiple groups use the same page:

  - only the first group gets "charged",

  - but if it stops using it, the "charge" is moved to another group.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Setting up a limit with the memory cgroup

Create a new memory cgroup:

```bash
$ CG=/sys/fs/cgroup/memory/onehundredmegs
$ sudo mkdir $CG
```

Limit it to approximately 100MB of memory usage:

```bash
$ sudo tee $CG/memory.memsw.limit_in_bytes <<< 100000000
```

Move the current process to that cgroup:

```bash
$ sudo tee $CG/tasks <<< $$
```

The current process *and all its future children* are now limited.

(Confused about `<<<`? Look at the next slide!)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## What's `<<<`?

- This is a "here string". (It is a non-POSIX shell extension.)

- The following commands are equivalent:

  ```bash
  foo <<< hello
  ```

  ```bash
  echo hello | foo
  ```

  ```bash
  foo <<EOF
  hello
  EOF
  ```

- Why did we use that?

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Writing to cgroups pseudo-files requires root

Instead of:

```bash
sudo tee $CG/tasks <<< $$
```

We could have done:

```bash
sudo sh -c "echo $$ > $CG/tasks"
```

The following commands, however, would be invalid:

```bash
sudo echo $$ > $CG/tasks
```

```bash
sudo -i # (or su)
echo $$ > $CG/tasks
```

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Testing the memory limit

Start the Python interpreter:

```bash
$ python
Python 3.6.4 (default, Jan  5 2018, 02:35:40)
[GCC 7.2.1 20171224] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

Allocate 80 megabytes:

```python
>>> s = "!" * 1000000 * 80
```

Add 20 megabytes more:

```python
>>> t = "!" * 1000000 * 20
Killed
```

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Memory cgroup v2: limits

- `memory.min` = hard reservation (guaranteed memory for this cgroup)

- `memory.low` = soft reservation ("*try* not to reclaim memory if we're below this")

- `memory.high` = soft limit (aggressively reclaim memory; don't trigger OOMK)

- `memory.max` = hard limit (triggers OOMK)

- `memory.swap.high` = aggressively reclaim memory when using that much swap

- `memory.swap.max` = prevent using more swap than this

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## CPU cgroup

- Keeps track of CPU time used by a group of processes.

  (This is easier and more accurate than `getrusage` and `/proc`.)

- Keeps track of usage per CPU as well.

  (i.e., "this group of process used X seconds of CPU0 and Y seconds of CPU1".)

- Allows setting relative weights used by the scheduler.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Cpuset cgroup

- Pin groups to specific CPU(s).

- Use-case: reserve CPUs for specific apps.

- Warning: make sure that "default" processes aren't using all CPUs!

- CPU pinning can also avoid performance loss due to cache flushes.

- This is also relevant for NUMA systems.

- Provides extra dials and knobs.

  (Per zone memory pressure, process migration costs...)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Blkio cgroup

- Keeps track of I/Os for each group:

  - per block device
  - read vs write
  - sync vs async

- Set throttle (limits) for each group:

  - per block device
  - read vs write
  - ops vs bytes

- Set relative weights for each group.

- Note: most writes go through the page cache.
  <br/>(So classic writes will appear to be unthrottled at first.)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Net_cls and net_prio cgroup

- Only works for egress (outgoing) traffic.

- Automatically set traffic class or priority
  for traffic generated by processes in the group.

- Net_cls will assign traffic to a class.

- Classes have to be matched with tc or iptables, otherwise traffic just flows normally.

- Net_prio will assign traffic to a priority.

- Priorities are used by queuing disciplines.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Devices cgroup

- Controls what the group can do on device nodes

- Permissions include read/write/mknod

- Typical use:

  - allow `/dev/{tty,zero,random,null}` ...
  - deny everything else

- A few interesting nodes:

  - `/dev/net/tun` (network interface manipulation)
  - `/dev/fuse` (filesystems in user space)
  - `/dev/kvm` (VMs in containers, yay inception!)
  - `/dev/dri` (GPU)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-namespaces
class: title

 Namespaces

.nav[
[Previous part](#toc-control-groups)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-security-features)
]

.debug[(automatically generated title slide)]

---

# Namespaces

- Provide processes with their own view of the system.

- Namespaces limit what you can see (and therefore, what you can use).

- These namespaces are available in modern kernels:

  - pid
  - net
  - mnt
  - uts
  - ipc
  - user
  - time
  - cgroup

  (We are going to detail them individually.)

- Each process belongs to one namespace of each type.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Namespaces are always active

- Namespaces exist even when you don't use containers.

- This is a bit similar to the UID field in UNIX processes:

  - all processes have the UID field, even if no user exists on the system

  - the field always has a value / the value is always defined
    <br/>
    (i.e. any process running on the system has some UID)

  - the value of the UID field is used when checking permissions
    <br/>
    (the UID field determines which resources the process can access)

- You can replace "UID field" with "namespace" above and it still works!

- In other words: even when you don't use containers,
  <br/>there is one namespace of each type, containing all the processes on the system.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Manipulating namespaces

- Namespaces are created with two methods:

  - the `clone()` system call (used when creating new threads and processes),

  - the `unshare()` system call.

- The Linux tool `unshare` allows doing that from a shell.

- A new process can re-use none / all / some of the namespaces of its parent.

- It is possible to "enter" a namespace with the `setns()` system call.

- The Linux tool `nsenter` allows doing that from a shell.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Namespaces lifecycle

- When the last process of a namespace exits, the namespace is destroyed.

- All the associated resources are then removed.

- Namespaces are materialized by pseudo-files in `/proc/<pid>/ns`.

  ```bash
  ls -l /proc/self/ns
  ```

- It is possible to compare namespaces by checking these files.

  (This helps to answer the question, "are these two processes in the same namespace?")

- It is possible to preserve a namespace by bind-mounting its pseudo-file.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Namespaces can be used independently

- As mentioned in the previous slides:

  *A new process can re-use none / all / some of the namespaces of its parent.*

- We are going to use that property in the examples in the next slides.

- We are going to present each type of namespace.

- For each type, we will provide an example using only that namespace.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## UTS namespace

- gethostname / sethostname

- Allows setting a custom hostname for a container.

- That's (mostly) it!

- Also allows setting the NIS domain.

  (If you don't know what a NIS domain is, you don't have to worry about it!)

- If you're wondering: UTS = UNIX time sharing.

- This namespace was named like this because of the `struct utsname`,
  <br/>
  which is commonly used to obtain the machine's hostname, architecture, etc.

  (The more you know!)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Creating our first namespace

Let's use `unshare` to create a new process that will have its own UTS namespace:

```bash
$ sudo unshare --uts
```

- We have to use `sudo` for most `unshare` operations.

- We indicate that we want a new uts namespace, and nothing else.

- If we don't specify a program to run, a `$SHELL` is started.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Demonstrating our uts namespace

In our new "container", check the hostname, change it, and check it:

```bash
 # hostname
 nodeX
 # hostname tupperware
 # hostname
 tupperware
```

In another shell, check that the machine's hostname hasn't changed:

```bash
$ hostname
nodeX
```

Exit the "container" with `exit` or `Ctrl-D`.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Net namespace overview

- Each network namespace has its own private network stack.

- The network stack includes:

  - network interfaces (including `lo`),

  - routing table**s** (as in `ip rule` etc.),

  - iptables chains and rules,

  - sockets (as seen by `ss`, `netstat`).

- You can move a network interface from a network namespace to another:
  ```bash
  ip link set dev eth0 netns PID
  ```

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Net namespace typical use

- Each container is given its own network namespace.

- For each network namespace (i.e. each container), a `veth` pair is created.

  (Two `veth` interfaces act as if they were connected with a cross-over cable.)

- One `veth` is moved to the container network namespace (and renamed `eth0`).

- The other `veth` is moved to a bridge on the host (e.g. the `docker0` bridge).

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details

## Creating a network namespace

Start a new process with its own network namespace:

```bash
$ sudo unshare --net
```

See that this new network namespace is unconfigured:

```bash
 # ping 1.1
 connect: Network is unreachable
 # ifconfig
 # ip link ls
 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
```

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details

## Creating the `veth` interfaces

In another shell (on the host), create a `veth` pair:

```bash
$ sudo ip link add name in_host type veth peer name in_netns
```

Configure the host side (`in_host`):

```bash
$ sudo ip link set in_host master docker0 up
```

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details

## Moving the `veth` interface

*In the process created by `unshare`,* check the PID of our "network container":

```bash
 # echo $$
 533
```

*On the host*, move the other side (`in_netns`) to the network namespace:

```bash
$ sudo ip link set in_netns netns 533
```

(Make sure to update "533" with the actual PID obtained above!)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details

## Basic network configuration

Let's set up `lo` (the loopback interface):

```bash
 # ip link set lo up
```

Activate the `veth` interface and rename it to `eth0`:

```bash
 # ip link set in_netns name eth0 up
```

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details

## Allocating IP address and default route

*On the host*, check the address of the Docker bridge:

```bash
$ ip addr ls dev docker0
```

(It could be something like `172.17.0.1`.)

Pick an IP address in the middle of the same subnet, e.g. `172.17.0.99`.

*In the process created by `unshare`,* configure the interface:

```bash
 # ip addr add 172.17.0.99/24 dev eth0
 # ip route add default via 172.17.0.1
```

(Make sure to update the IP addresses if necessary.)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details

## Validating the setup

Check that we now have connectivity:

```bash
 # ping 1.1
```

Note: we were able to take a shortcut, because Docker is running,
and provides us with a `docker0` bridge and a valid `iptables` setup.

If Docker is not running, you will need to take care of this!

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details

## Cleaning up network namespaces

- Terminate the process created by `unshare` (with `exit` or `Ctrl-D`).

- Since this was the only process in the network namespace, it is destroyed.

- All the interfaces in the network namespace are destroyed.

- When a `veth` interface is destroyed, it also destroys the other half of the pair.

- So we don't have anything else to do to clean up!

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Other ways to use network namespaces

- `--net none` gives an empty network namespace to a container.

  (Effectively isolating it completely from the network.)

- `--net host` means "do not containerize the network".

  (No network namespace is created; the container uses the host network stack.)

- `--net container` means "reuse the network namespace of another container".

  (As a result, both containers share the same interfaces, routes, etc.)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Mnt namespace

- Processes can have their own root fs (à la chroot).

- Processes can also have "private" mounts. This allows:

  - isolating `/tmp` (per user, per service...)

  - masking `/proc`, `/sys` (for processes that don't need them)

  - mounting remote filesystems or sensitive data,
    <br/>but make it visible only for allowed processes

- Mounts can be totally private, or shared.

- At this point, there is no easy way to pass along a mount
  from a namespace to another.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## Setting up a private `/tmp`

Create a new mount namespace:

```bash
$ sudo unshare --mount
```

In that new namespace, mount a brand new `/tmp`:

```bash
 # mount -t tmpfs none /tmp
```

Check the content of `/tmp` in the new namespace, and compare to the host.

The mount is automatically cleaned up when you exit the process.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## PID namespace

- Processes within a PID namespace only "see" processes
  in the same PID namespace.

- Each PID namespace has its own numbering (starting at 1).

- When PID 1 goes away, the whole namespace is killed.

  (When PID 1 goes away on a normal UNIX system, the kernel panics!)

- Those namespaces can be nested.

- A process ends up having multiple PIDs (one per namespace in which it is nested).

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## PID namespace in action

Create a new PID namespace:

```bash
$ sudo unshare --pid --fork
```

(We need the `--fork` flag because the PID namespace is special.)

Check the process tree in the new namespace:

```bash
 # ps faux
```

--

class: extra-details, deep-dive

🤔 Why do we see all the processes?!?

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## PID namespaces and `/proc`

- Tools like `ps` rely on the `/proc` pseudo-filesystem.

- Our new namespace still has access to the original `/proc`.

- Therefore, it still sees host processes.

- But it cannot affect them.

  (Try to `kill` a process: you will get `No such process`.)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## PID namespaces, take 2

- This can be solved by mounting `/proc` in the namespace.

- The `unshare` utility provides a convenience flag, `--mount-proc`.

- This flag will mount `/proc` in the namespace.

- It will also unshare the mount namespace, so that this mount is local.

Try it:

```bash
 $ sudo unshare --pid --fork --mount-proc
 # ps faux
```

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details

## OK, really, why do we need `--fork`?

*It is not necessary to remember all these details.
<br/>
This is just an illustration of the complexity of namespaces!*

The `unshare` tool calls the `unshare` syscall, then `exec`s the new binary.
<br/>
A process calling `unshare` to create new namespaces is moved to the new namespaces...
<br/>
... Except for the PID namespace.
<br/>
(Because this would change the current PID of the process from X to 1.)

The processes created by the new binary are placed into the new PID namespace.
<br/>
The first one will be PID 1.
<br/>
If PID 1 exits, it is not possible to create additional processes in the namespace.
<br/>
(Attempting to do so will result in `ENOMEM`.)

Without the `--fork` flag, the first command that we execute will be PID 1 ...
<br/>
... And once it exits, we cannot create more processes in the namespace!

Check `man 2 unshare` and `man pid_namespaces` if you want more details.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## IPC namespace

--

- Does anybody know about IPC?

--

- Does anybody *care* about IPC?

--

- Allows a process (or group of processes) to have own:

  - IPC semaphores
  - IPC message queues
  - IPC shared memory

  ... without risk of conflict with other instances.

- Older versions of PostgreSQL cared about this.

*No demo for that one.*

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## User namespace

- Allows mapping UID/GID; e.g.:

  - UID 0→1999 in container C1 is mapped to UID 10000→11999 on host
  - UID 0→1999 in container C2 is mapped to UID 12000→13999 on host
  - etc.

- UID 0 in the container can still perform privileged operations in the container.

  (For instance: setting up network interfaces.)

- But outside of the container, it is a non-privileged user.

- It also means that the UID in containers becomes unimportant.

  (Just use UID 0 in the container, since it gets squashed to a non-privileged user outside.)

- Ultimately enables better privilege separation in container engines.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: extra-details, deep-dive

## User namespace challenges

- UID needs to be mapped when passed between processes or kernel subsystems.

- Filesystem permissions and file ownership are more complicated.

  .small[(E.g. when the same root filesystem is shared by multiple containers
  running with different UIDs.)]

- With the Docker Engine:

  - some feature combinations are not allowed
    <br/>
    (e.g. user namespace + host network namespace sharing)

  - user namespaces need to be enabled/disabled globally
    <br/>
    (when the daemon is started)

  - container images are stored separately
    <br/>
    (so the first time you toggle user namespaces, you need to re-pull images)

*No demo for that one.*

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Time namespace

- Virtualize time

- Expose a slower/faster clock to some processes

  (for e.g. simulation purposes)

- Expose a clock offset to some processes

  (simulation, suspend/restore...)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Cgroup namespace

- Virtualize access to `/proc/<PID>/cgroup`

- Lets containerized processes view their relative cgroup tree

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-security-features
class: title

 Security features

.nav[
[Previous part](#toc-namespaces)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-copy-on-write-filesystems)
]

.debug[(automatically generated title slide)]

---

# Security features

- Namespaces and cgroups are not enough to ensure strong security.

- We need extra mechanisms: capabilities, seccomp, LSMs.

- These mechanisms were already used before containers to harden security.

- They can be used together with containers.

- Good container engines will automatically leverage these features.

  (So that you don't have to worry about it.)

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Capabilities

- In traditional UNIX, many operations are possible if and only if UID=0 (root).

- Some of these operations are very powerful:

  - changing file ownership, accessing all files ...

- Some of these operations deal with system configuration, but can be abused:

  - setting up network interfaces, mounting filesystems ...

- Some of these operations are not very dangerous but are needed by servers:

  - binding to a port below 1024.

- Capabilities are per-process flags to allow these operations individually.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Some capabilities

- `CAP_CHOWN`: arbitrarily change file ownership and permissions.

- `CAP_DAC_OVERRIDE`: arbitrarily bypass file ownership and permissions.

- `CAP_NET_ADMIN`: configure network interfaces, iptables rules, etc.

- `CAP_NET_BIND_SERVICE`: bind a port below 1024.

See `man capabilities` for the full list and details.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Using capabilities

- Container engines will typically drop all "dangerous" capabilities.

- You can then re-enable capabilities on a per-container basis, as needed.

- With the Docker engine: `docker run --cap-add ...`

- If you write your own code to manage capabilities:

  - make sure that you understand what each capability does,

  - read about *ambient* capabilities as well.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Seccomp

- Seccomp is secure computing.

- Achieve high level of security by restricting drastically available syscalls.

- Original seccomp only allows `read()`, `write()`, `exit()`, `sigreturn()`.

- The seccomp-bpf extension allows specifying custom filters with BPF rules.

- This allows filtering by syscall, and by parameter.

- BPF code can perform arbitrarily complex checks, quickly, and safely.

- Container engines take care of this so you don't have to.

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

## Linux Security Modules

- The most popular ones are SELinux and AppArmor.

- Red Hat distros generally use SELinux.

- Debian distros (in particular, Ubuntu) generally use AppArmor.

- LSMs add a layer of access control to all process operations.

- Container engines take care of this so you don't have to.

???

:EN:Containers internals
:EN:- Control groups (cgroups)
:EN:- Linux kernel namespaces
:FR:Fonctionnement interne des conteneurs
:FR:- Les "control groups" (cgroups)
:FR:- Les namespaces du noyau Linux

.debug[[containers/Namespaces_Cgroups.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Namespaces_Cgroups.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-copy-on-write-filesystems
class: title

 Copy-on-write filesystems

.nav[
[Previous part](#toc-security-features)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-building-containers-from-scratch)
]

.debug[(automatically generated title slide)]

---
# Copy-on-write filesystems

Container engines rely on copy-on-write to be able
to start containers quickly, regardless of their size.

We will explain how that works, and review some of
the copy-on-write storage systems available on Linux.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## What is copy-on-write?

- Copy-on-write is a mechanism allowing to share data.

- The data appears to be a copy, but is only
  a link (or reference) to the original data.

- The actual copy happens only when someone
  tries to change the shared data.

- Whoever changes the shared data ends up
  using their own copy instead of the shared data.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## A few metaphors

--

- First metaphor:
  <br/>white board and tracing paper

--

- Second metaphor:
  <br/>magic books with shadowy pages

--

- Third metaphor:
  <br/>just-in-time house building

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## Copy-on-write is *everywhere*

- Process creation with `fork()`.

- Consistent disk snapshots.

- Efficient VM provisioning.

- And, of course, containers.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## Copy-on-write and containers

Copy-on-write is essential to give us "convenient" containers.

- Creating a new container (from an existing image) is "free".

  (Otherwise, we would have to copy the image first.)

- Customizing a container (by tweaking a few files) is cheap.

  (Adding a 1 KB configuration file to a 1 GB container takes 1 KB, not 1 GB.)

- We can take snapshots, i.e. have "checkpoints" or "save points"
  when building images.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## AUFS overview

- The original (legacy) copy-on-write filesystem used by first versions of Docker.

- Combine multiple *branches* in a specific order.

- Each branch is just a normal directory.

- You generally have:

  - at least one read-only branch (at the bottom),

  - exactly one read-write branch (at the top).

  (But other fun combinations are possible too!)

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## AUFS operations: opening a file

- With `O_RDONLY` - read-only access:

  - look it up in each branch, starting from the top

  - open the first one we find

- With `O_WRONLY` or `O_RDWR` - write access:

  - if the file exists on the top branch: open it

  - if the file exists on another branch: "copy up"
    <br/>
    (i.e. copy the file to the top branch and open the copy)

  - if the file doesn't exist on any branch: create it on the top branch

That "copy-up" operation can take a while if the file is big!

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## AUFS operations: deleting a file

- A *whiteout* file is created.

- This is similar to the concept of "tombstones" used in some data systems.

```
 # docker run ubuntu rm /etc/shadow

 # ls -la /var/lib/docker/aufs/diff/$(docker ps --no-trunc -lq)/etc
 total 8
 drwxr-xr-x 2 root root 4096 Jan 27 15:36 .
 drwxr-xr-x 5 root root 4096 Jan 27 15:36 ..
 -r--r--r-- 2 root root    0 Jan 27 15:36 .wh.shadow
```

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## AUFS performance

- AUFS `mount()` is fast, so creation of containers is quick.

- Read/write access has native speeds.

- But initial `open()` is expensive in two scenarios:

  - when writing big files (log files, databases ...),

  - when searching many directories (PATH, classpath, etc.) over many layers.

- Protip: when we built dotCloud, we ended up putting
  all important data on *volumes*.

- When starting the same container multiple times:

  - the data is loaded only once from disk, and cached only once in memory;

  - but `dentries` will be duplicated.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## Device Mapper

Device Mapper is a rich subsystem with many features.

It can be used for: RAID, encrypted devices, snapshots, and more.

In the context of containers (and Docker in particular), "Device Mapper"
means:

"the Device Mapper system + its *thin provisioning target*"

If you see the abbreviation "thinp" it stands for "thin provisioning".

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## Device Mapper principles

- Copy-on-write happens on the *block* level
  (instead of the *file* level).

- Each container and each image get their own block device.

- At any given time, it is possible to take a snapshot:

  - of an existing container (to create a frozen image),

  - of an existing image (to create a container from it).

- If a block has never been written to:

  - it's assumed to be all zeros,

  - it's not allocated on disk.

(That last property is the reason for the name "thin" provisioning.)

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## Device Mapper operational details

- Two storage areas are needed:
  one for *data*, another for *metadata*.

- "data" is also called the "pool"; it's just a big pool of blocks.

  (Docker uses the smallest possible block size, 64 KB.)

- "metadata" contains the mappings between virtual offsets (in the
  snapshots) and physical offsets (in the pool).

- Each time a new block (or a copy-on-write block) is written,
  a block is allocated from the pool.

- When there are no more blocks in the pool, attempts to write
  will stall until the pool is increased (or the write operation
  aborted).

- In other words: when running out of space, containers are
  frozen, but operations will resume as soon as space is available.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## Device Mapper performance

- By default, Docker puts data and metadata on a loop device
  backed by a sparse file.

- This is great from a usability point of view,
  since zero configuration is needed.

- But it is terrible from a performance point of view:

  - each time a container writes to a new block,
  - a block has to be allocated from the pool,
  - and when it's written to,
  - a block has to be allocated from the sparse file,
  - and sparse file performance isn't great anyway.

- If you use Device Mapper, make sure to put data (and metadata)
  on devices!

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## BTRFS principles

- BTRFS is a filesystem (like EXT4, XFS, NTFS...) with built-in snapshots.

- The "copy-on-write" happens at the filesystem level.

- BTRFS integrates the snapshot and block pool management features
  at the filesystem level.

  (Instead of the block level for Device Mapper.)

- In practice, we create a "subvolume" and 
  later take a "snapshot" of that subvolume.

  Imagine: `mkdir` with Super Powers and `cp -a` with Super Powers.

- These operations can be executed with the `btrfs` CLI tool.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## BTRFS in practice with Docker

- Docker can use BTRFS and its snapshotting features to store container images.

- The only requirement is that `/var/lib/docker` is on a BTRFS filesystem.

  (Or, the directory specified with the `--data-root` flag when starting the engine.)

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

class: extra-details

## BTRFS quirks

- BTRFS works by dividing its storage in *chunks*.

- A chunk can contain data or metadata.

- You can run out of chunks (and get `No space left on device`)
  even though `df` shows space available.
  
  (Because chunks are only partially allocated.)

- Quick fix:

```
 # btrfs filesys balance start -dusage=1 /var/lib/docker
```

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## Overlay2

- Overlay2 is very similar to AUFS.

- However, it has been merged in "upstream" kernel.

- It is therefore available on all modern kernels.

  (AUFS was available on Debian and Ubuntu, but required custom kernels on other distros.)

- It is simpler than AUFS (it can only have two branches, called "layers").

- The container engine abstracts this detail, so this is not a concern.

- Overlay2 storage drivers generally use hard links between layers.

- This improves `stat()` and `open()` performance, at the expense of inode usage.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## ZFS

- ZFS is similar to BTRFS (at least from a container user's perspective).

- Pros:

  - high performance
  - high reliability (with e.g. data checksums)
  - optional data compression and deduplication

- Cons:

  - high memory usage
  - not in upstream kernel

- It is available as a kernel module or through FUSE.

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

## Which one is the best?

- Eventually, overlay2 should be the best option.

- It is available on all modern systems.

- Its memory usage is better than Device Mapper, BTRFS, or ZFS.

- The remarks about *write performance* shouldn't bother you:
  <br/>
  data should always be stored in volumes anyway!

???

:EN:- Copy-on-write filesystems
:EN:- Docker graph drivers
:FR:- Les systèmes de fichiers "copy-on-write"
:FR:- Les "graph drivers" de Docker

.debug[[containers/Copy_On_Write.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Copy_On_Write.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-building-containers-from-scratch
class: title

 Building containers from scratch

.nav[
[Previous part](#toc-copy-on-write-filesystems)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-docker-engine-and-other-container-engines)
]

.debug[(automatically generated title slide)]

---
# Building containers from scratch

(This is a "bonus section" done if time permits.)
.debug[[containers/Containers_From_Scratch.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Containers_From_Scratch.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-docker-engine-and-other-container-engines
class: title

 Docker Engine and other container engines

.nav[
[Previous part](#toc-building-containers-from-scratch)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-container-super-structure)
]

.debug[(automatically generated title slide)]

---
# Docker Engine and other container engines

* We are going to cover the architecture of the Docker Engine.

* We will also present other container engines.

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

class: pic

## Docker Engine external architecture

![](images/docker-engine-architecture.svg)

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## Docker Engine external architecture

* The Engine is a daemon (service running in the background).

* All interaction is done through a REST API exposed over a socket.

* On Linux, the default socket is a UNIX socket: `/var/run/docker.sock`.

* We can also use a TCP socket, with optional mutual TLS authentication.

* The `docker` CLI communicates with the Engine over the socket.

Note: strictly speaking, the Docker API is not fully REST.

Some operations (e.g. dealing with interactive containers
and log streaming) don't fit the REST model.
 
.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

class: pic

## Docker Engine internal architecture

![](images/dockerd-and-containerd.png)

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## Docker Engine internal architecture

* Up to Docker 1.10: the Docker Engine is one single monolithic binary.

* Starting with Docker 1.11, the Engine is split into multiple parts:

  - `dockerd` (REST API, auth, networking, storage)

  - `containerd` (container lifecycle, controlled over a gRPC API)

  - `containerd-shim` (per-container; does almost nothing but allows to restart the Engine without restarting the containers)

  - `runc` (per-container; does the actual heavy lifting to start the container)

* Some features (like image and snapshot management) are progressively being pushed from `dockerd` to `containerd`.

For more details, check [this short presentation by Phil Estes](https://www.slideshare.net/PhilEstes/diving-through-the-layers-investigating-runc-containerd-and-the-docker-engine-architecture).

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## Other container engines

The following list is not exhaustive.

Furthermore, we limited the scope to Linux containers.

We can also find containers (or things that look like containers) on other platforms
like Windows, macOS, Solaris, FreeBSD ...

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## LXC

* The venerable ancestor (first released in 2008).

* Docker initially relied on it to execute containers.

* No daemon; no central API.

* Each container is managed by a `lxc-start` process.

* Each `lxc-start` process exposes a custom API over a local UNIX socket, allowing to interact with the container.

* No notion of image (container filesystems have to be managed manually).

* Networking has to be set up manually.

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## LXD

* Re-uses LXC code (through liblxc).

* Builds on top of LXC to offer a more modern experience.

* Daemon exposing a REST API.

* Can manage images, snapshots, migrations, networking, storage.

* "offers a user experience similar to virtual machines but using Linux containers instead."

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## CRI-O

* Designed to be used with Kubernetes as a simple, basic runtime.

* Compares to `containerd`.

* Daemon exposing a gRPC interface.

* Controlled using the CRI API (Container Runtime Interface defined by Kubernetes).

* Needs an underlying OCI runtime (e.g. runc).

* Handles storage, images, networking (through CNI plugins).

We're not aware of anyone using it directly (i.e. outside of Kubernetes).

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## systemd

* "init" system (PID 1) in most modern Linux distributions.

* Offers tools like `systemd-nspawn` and `machinectl` to manage containers.

* `systemd-nspawn` is "In many ways it is similar to chroot(1), but more powerful".

* `machinectl` can interact with VMs and containers managed by systemd.

* Exposes a DBUS API.

* Basic image support (tar archives and raw disk images).

* Network has to be set up manually.

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## Kata containers

* OCI-compliant runtime.

* Fusion of two projects: Intel Clear Containers and Hyper runV.

* Run each container in a lightweight virtual machine.

* Requires running on bare metal *or* with nested virtualization.

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## gVisor

* OCI-compliant runtime.

* Implements a subset of the Linux kernel system calls.

* Written in go, uses a smaller subset of system calls.

* Can be heavily sandboxed.

* Can run in two modes:

  * KVM (requires bare metal or nested virtualization),

  * ptrace (no requirement, but slower).

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

## Overall ...

* The Docker Engine is very developer-centric:

  - easy to install

  - easy to use

  - no manual setup

  - first-class image build and transfer

* As a result, it is a fantastic tool in development environments.

* On servers:

  - Docker is a good default choice

  - If you use Kubernetes, the engine doesn't matter

.debug[[containers/Container_Engines.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Container_Engines.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-1.jpg)]

---

name: toc-container-super-structure
class: title

 Container Super-structure

.nav[
[Previous part](#toc-docker-engine-and-other-container-engines)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-the-container-ecosystem)
]

.debug[(automatically generated title slide)]

---
# Container Super-structure

- Multiple orchestration platforms support some kind of container super-structure.

  (i.e., a construct or abstraction bigger than a single container.)

- For instance, on Kubernetes, this super-structure is called a *pod*.

- A pod is a group of containers (it could be a single container, too).

- These containers run together, on the same host.

  (A pod cannot straddle multiple hosts.)

- All the containers in a pod have the same IP address.

- How does that map to the Docker world?

.debug[[containers/Pods_Anatomy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Pods_Anatomy.md)]
---

class: pic

## Anatomy of a Pod

![Pods](images/kubernetes_pods.svg)

.debug[[containers/Pods_Anatomy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Pods_Anatomy.md)]
---

## Pods in Docker

- The containers inside a pod share the same network namespace.

  (Just like when using `docker run --net=container:<container_id>` with the CLI.)

- As a result, they can communicate together over `localhost`.

- In addition to "our" containers, the pod has a special container, the *sandbox*.

- That container uses a special image: `k8s.gcr.io/pause`.

  (This is visible when listing containers running on a Kubernetes node.)

- Containers within a pod have independent filesystems.

- They can share directories by using a mechanism called *volumes.*

  (Which is similar to the concept of volumes in Docker.)

.debug[[containers/Pods_Anatomy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Pods_Anatomy.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-2.jpg)]

---

name: toc-the-container-ecosystem
class: title

 The container ecosystem

.nav[
[Previous part](#toc-container-super-structure)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-orchestration-an-overview)
]

.debug[(automatically generated title slide)]

---
# The container ecosystem

In this chapter, we will talk about a few actors of the container ecosystem.

We have (arbitrarily) decided to focus on two groups:

- the Docker ecosystem,

- the Cloud Native Computing Foundation (CNCF) and its projects.

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

class: pic

## The Docker ecosystem

![The Docker ecosystem in 2015](images/docker-ecosystem-2015.png)

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

## Moby vs. Docker

- Docker Inc. (the company) started Docker (the open source project).

- At some point, it became necessary to differentiate between:

  - the open source project (code base, contributors...),

  - the product that we use to run containers (the engine),

  - the platform that we use to manage containerized applications,

  - the brand.

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

class: pic

![Picture of a Tesla](images/tesla.jpg)

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

## Exercise in brand management

Questions:

--

- What is the brand of the car on the previous slide?

--

- What kind of engine does it have?

--

- Would you say that it's a safe or unsafe car?

--

- Harder question: can you drive from the US West to East coasts with it?

--

The answers to these questions are part of the Tesla brand.

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

## What if ...

- The blueprints for Tesla cars were available for free.

- You could legally build your own Tesla.

- You were allowed to customize it entirely.

  (Put a combustion engine, drive it with a game pad ...)

- You could even sell the customized versions.

--

- ... And call your customized version "Tesla".

--

Would we give the same answers to the questions on the previous slide?

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

## From Docker to Moby

- Docker Inc. decided to split the brand.

- Moby is the open source project.

  (= Components and libraries that you can use, reuse, customize, sell ...)

- Docker is the product.

  (= Software that you can use, buy support contracts ...)

- Docker is made with Moby.

- When Docker Inc. improves the Docker products, it improves Moby.

  (And vice versa.)


.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

## Other examples

- *Read the Docs* is an open source project to generate and host documentation.

- You can host it yourself (on your own servers).

- You can also get hosted on readthedocs.org.

- The maintainers of the open source project often receive
  support requests from users of the hosted product ...

- ... And the maintainers of the hosted product often
  receive support requests from users of self-hosted instances.

- Another example:

  *WordPress.com is a blogging platform that is owned and hosted online by
  Automattic. It is run on WordPress, an open source piece of software used by
  bloggers. (Wikipedia)*

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

## Docker CE vs Docker EE

- Docker CE = Community Edition.

- Available on most Linux distros, Mac, Windows.

- Optimized for developers and ease of use.

- Docker EE = Enterprise Edition.

- Available only on a subset of Linux distros + Windows servers.

  (Only available when there is a strong partnership to offer enterprise-class support.)

- Optimized for production use.

- Comes with additional components: security scanning, RBAC ...

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

## The CNCF

- Non-profit, part of the Linux Foundation; founded in December 2015. 

  *The Cloud Native Computing Foundation builds sustainable ecosystems and fosters
  a community around a constellation of high-quality projects that orchestrate
  containers as part of a microservices architecture.*

  *CNCF is an open source software foundation dedicated to making cloud-native computing universal and sustainable.*

- Home of Kubernetes (and many other projects now).

- Funded by corporate memberships.

.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

class: pic

![Cloud Native Landscape](https://landscape.cncf.io/images/landscape.png)


.debug[[containers/Ecosystem.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Ecosystem.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/two-containers-on-a-truck.jpg)]

---

name: toc-orchestration-an-overview
class: title

 Orchestration, an overview

.nav[
[Previous part](#toc-the-container-ecosystem)
|
[Back to table of contents](#toc-part-5)
|
[Next part](#toc-pre-requirements)
]

.debug[(automatically generated title slide)]

---
# Orchestration, an overview

In this chapter, we will:

* Explain what is orchestration and why we would need it.

* Present (from a high-level perspective) some orchestrators.

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## What's orchestration?

![Joana Carneiro (orchestra conductor)](images/conductor.jpg)

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## What's orchestration?

According to Wikipedia:

*Orchestration describes the __automated__ arrangement,
coordination, and management of complex computer systems,
middleware, and services.*

--

*[...] orchestration is often discussed in the context of 
__service-oriented architecture__, __virtualization__, provisioning, 
Converged Infrastructure and __dynamic datacenter__ topics.*

--

What does that really mean?

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Example 1: dynamic cloud instances

--

- Q: do we always use 100% of our servers?

--

- A: obviously not!

.center[![Daily variations of traffic](images/traffic-graph.png)]

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Example 1: dynamic cloud instances

- Every night, scale down
  
  (by shutting down extraneous replicated instances)

- Every morning, scale up
  
  (by deploying new copies)

- "Pay for what you use"
  
  (i.e. save big $$$ here)

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Example 1: dynamic cloud instances

How do we implement this?

- Crontab
  
- Autoscaling (save even bigger $$$)

That's *relatively* easy.

Now, how are things for our IAAS provider?

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Example 2: dynamic datacenter

- Q: what's the #1 cost in a datacenter?

--

- A: electricity!

--

- Q: what uses electricity?

--

- A: servers, obviously

- A: ... and associated cooling

--

- Q: do we always use 100% of our servers?

--

- A: obviously not!

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Example 2: dynamic datacenter

- If only we could turn off unused servers during the night...

- Problem: we can only turn off a server if it's totally empty!
  
  (i.e. all VMs on it are stopped/moved)

- Solution: *migrate* VMs and shutdown empty servers
  
  (e.g. combine two hypervisors with 40% load into 80%+0%,
  <br/>and shut down the one at 0%)

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Example 2: dynamic datacenter

How do we implement this?

- Shut down empty hosts (but keep some spare capacity)

- Start hosts again when capacity gets low

- Ability to "live migrate" VMs
  
  (Xen already did this 10+ years ago)

- Rebalance VMs on a regular basis
  
  - what if a VM is stopped while we move it?
  - should we allow provisioning on hosts involved in a migration?

*Scheduling* becomes more complex.

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## What is scheduling?

According to Wikipedia (again):

*In computing, scheduling is the method by which threads, 
processes or data flows are given access to system resources.*

The scheduler is concerned mainly with:

- throughput (total amount of work done per time unit);
- turnaround time (between submission and completion);
- response time (between submission and start);
- waiting time (between job readiness and execution);
- fairness (appropriate times according to priorities).

In practice, these goals often conflict.

**"Scheduling" = decide which resources to use.**

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Exercise 1

- You have:

  - 5 hypervisors (physical machines)

- Each server has:

  - 16 GB RAM, 8 cores, 1 TB disk

- Each week, your team requests:

  - one VM with X RAM, Y CPU, Z disk

Scheduling = deciding which hypervisor to use for each VM.

Difficulty: easy!

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

<!-- Warning, two almost identical slides (for img effect) -->

## Exercise 2

- You have:

  - 1000+ hypervisors (and counting!)

- Each server has different resources:

  - 8-500 GB of RAM, 4-64 cores, 1-100 TB disk

- Multiple times a day, a different team asks for:

  - up to 50 VMs with different characteristics

Scheduling = deciding which hypervisor to use for each VM.

Difficulty: ???

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

<!-- Warning, two almost identical slides (for img effect) -->

## Exercise 2

- You have:

  - 1000+ hypervisors (and counting!)

- Each server has different resources:

  - 8-500 GB of RAM, 4-64 cores, 1-100 TB disk

- Multiple times a day, a different team asks for:

  - up to 50 VMs with different characteristics

Scheduling = deciding which hypervisor to use for each VM.

![Troll face](images/trollface.png)

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Exercise 3

- You have machines (physical and/or virtual)

- You have containers

- You are trying to put the containers on the machines

- Sounds familiar?

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## Scheduling with one resource

.center[![Not-so-good bin packing](images/binpacking-1d-1.gif)]

## We can't fit a job of size 6 :(

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## Scheduling with one resource

.center[![Better bin packing](images/binpacking-1d-2.gif)]

## ... Now we can!

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## Scheduling with two resources

.center[![2D bin packing](images/binpacking-2d.gif)]

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## Scheduling with three resources

.center[![3D bin packing](images/binpacking-3d.gif)]

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## You need to be good at this

.center[![Tangram](images/tangram.gif)]

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## But also, you must be quick!

.center[![Tetris](images/tetris-1.png)]

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## And be web scale!

.center[![Big tetris](images/tetris-2.gif)]

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## And think outside (?) of the box!

.center[![3D tetris](images/tetris-3.png)]

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

## Good luck!

.center[![FUUUUUU face](images/fu-face.jpg)]

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## TL,DR

* Scheduling with multiple resources (dimensions) is hard.

* Don't expect to solve the problem with a Tiny Shell Script.

* There are literally tons of research papers written on this.

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## But our orchestrator also needs to manage ...

* Network connectivity (or filtering) between containers.

* Load balancing (external and internal).

* Failure recovery (if a node or a whole datacenter fails).

* Rolling out new versions of our applications.

  (Canary deployments, blue/green deployments...)


.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Some orchestrators

We are going to present briefly a few orchestrators.

There is no "absolute best" orchestrator.

It depends on:

- your applications,

- your requirements,

- your pre-existing skills...

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Nomad

- Open Source project by Hashicorp.

- Arbitrary scheduler (not just for containers).

- Great if you want to schedule mixed workloads.

  (VMs, containers, processes...)

- Less integration with the rest of the container ecosystem.

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Mesos

- Open Source project in the Apache Foundation.

- Arbitrary scheduler (not just for containers).

- Two-level scheduler.

- Top-level scheduler acts as a resource broker.

- Second-level schedulers (aka "frameworks") obtain resources from top-level.

- Frameworks implement various strategies.

  (Marathon = long running processes; Chronos = run at intervals; ...)

- Commercial offering through DC/OS by Mesosphere.

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Rancher

- Rancher 1 offered a simple interface for Docker hosts.

- Rancher 2 is a complete management platform for Docker and Kubernetes.

- Technically not an orchestrator, but it's a popular option.

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Swarm

- Tightly integrated with the Docker Engine.

- Extremely simple to deploy and setup, even in multi-manager (HA) mode.

- Secure by default.

- Strongly opinionated:

  - smaller set of features,

  - easier to operate.

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

## Kubernetes

- Open Source project initiated by Google.

- Contributions from many other actors.

- *De facto* standard for container orchestration.

- Many deployment options; some of them very complex.

- Reputation: steep learning curve.

- Reality:

  - true, if we try to understand *everything*;

  - false, if we focus on what matters.

???

:EN:- Orchestration overview
:FR:- Survol de techniques d'orchestration 

.debug[[containers/Orchestration_Overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/Orchestration_Overview.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/wall-of-containers.jpeg)]

---

name: toc-pre-requirements
class: title

 Pre-requirements

.nav[
[Previous part](#toc-orchestration-an-overview)
|
[Back to table of contents](#toc-part-6)
|
[Next part](#toc-kubernetes-architecture)
]

.debug[(automatically generated title slide)]

---
# Pre-requirements

- Kubernetes concepts

  (pods, deployments, services, labels, selectors)

- Hands-on experience working with containers

  (building images, running them; doesn't matter how exactly)

- Familiarity with the UNIX command-line

  (navigating directories, editing files, using `kubectl`)

.debug[[k8s/prereqs-advanced.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prereqs-advanced.md)]
---
class: title

*Tell me and I forget.*
<br/>
*Teach me and I remember.*
<br/>
*Involve me and I learn.*

Misattributed to Benjamin Franklin

[(Probably inspired by Chinese Confucian philosopher Xunzi)](https://www.barrypopik.com/index.php/new_york_city/entry/tell_me_and_i_forget_teach_me_and_i_may_remember_involve_me_and_i_will_lear/)

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

## Hands-on sections

- There will be *a lot* of examples and demos

- We are going to build, ship, and run containers (and sometimes, clusters!)

- If you want, you can run all the examples and demos in your environment

  (but you don't have to; it's up to you!)

- All hands-on sections are clearly identified, like the gray rectangle below

.lab[

- This is a command that we're gonna run:
  ```bash
  echo hello world
  ```

]

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

class: in-person

## Where are we going to run our containers?

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

class: in-person, pic

![You get a cluster](images/you-get-a-cluster.jpg)

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

## If you're attending a live training or workshop

- Each person gets a private lab environment

  (depending on the scenario, this will be one VM, one cluster, multiple clusters...)

- The instructor will tell you how to connect to your environment

- Your lab environments will be available for the duration of the workshop

  (check with your instructor to know exactly when they'll be shutdown)

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

## Running your own lab environments

- If you are following a self-paced course...

- Or watching a replay of a recorded course...

- ...You will need to set up a local environment for the labs

- If you want to deliver your own training or workshop:

  - deployment scripts are available in the [prepare-labs] directory

  - you can use them to automatically deploy many lab environments

  - they support many different infrastructure providers

[prepare-labs]: https://github.com/jpetazzo/container.training/tree/main/prepare-labs

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

class: in-person

## Why don't we run containers locally?

- Installing this stuff can be hard on some machines

  (32 bits CPU or OS... Laptops without administrator access... etc.)

- *"The whole team downloaded all these container images from the WiFi!
  <br/>... and it went great!"* (Literally no-one ever)

- All you need is a computer (or even a phone or tablet!), with:

  - an Internet connection

  - a web browser

  - an SSH client

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

class: in-person

## SSH clients

- On Linux, OS X, FreeBSD... you are probably all set

- On Windows, get one of these:

  - [putty](http://www.putty.org/)
  - Microsoft [Win32 OpenSSH](https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH)
  - [Git BASH](https://git-for-windows.github.io/)
  - [MobaXterm](http://mobaxterm.mobatek.net/)

- On Android, [JuiceSSH](https://juicessh.com/)
  ([Play Store](https://play.google.com/store/apps/details?id=com.sonelli.juicessh))
  works pretty well

- Nice-to-have: [Mosh](https://mosh.org/) instead of SSH, if your Internet connection tends to lose packets

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

class: in-person, extra-details

## What is this Mosh thing?

*You don't have to use Mosh or even know about it to follow along.
<br/>
We're just telling you about it because some of us think it's cool!*

- Mosh is "the mobile shell"

- It is essentially SSH over UDP, with roaming features

- It retransmits packets quickly, so it works great even on lossy connections

  (Like hotel or conference WiFi)

- It has intelligent local echo, so it works great even in high-latency connections

  (Like hotel or conference WiFi)

- It supports transparent roaming when your client IP address changes

  (Like when you hop from hotel to conference WiFi)

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

class: in-person, extra-details

## Using Mosh

- To install it: `(apt|yum|brew) install mosh`

- It has been pre-installed on the VMs that we are using

- To connect to a remote machine: `mosh user@host`

  (It is going to establish an SSH connection, then hand off to UDP)

- It requires UDP ports to be open

  (By default, it uses a UDP port between 60000 and 61000)

.debug[[shared/handson.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/handson.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/catene-de-conteneurs.jpg)]

---

name: toc-kubernetes-architecture
class: title

 Kubernetes architecture

.nav[
[Previous part](#toc-pre-requirements)
|
[Back to table of contents](#toc-part-6)
|
[Next part](#toc-the-kubernetes-api)
]

.debug[(automatically generated title slide)]

---
# Kubernetes architecture

We can arbitrarily split Kubernetes in two parts:

- the *nodes*, a set of machines that run our containerized workloads;

- the *control plane*, a set of processes implementing the Kubernetes APIs.

Kubernetes also relies on underlying infrastructure:

- servers, network connectivity (obviously!),

- optional components like storage systems, load balancers ...

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

![Kubernetes architecture diagram: communication between components](images/k8s-arch4-thanks-luxas.png)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## What runs on a node

- Our containerized workloads

- A container engine like Docker, CRI-O, containerd...

  (in theory, the choice doesn't matter, as the engine is abstracted by Kubernetes)

- kubelet: an agent connecting the node to the cluster

  (it connects to the API server, registers the node, receives instructions)

- kube-proxy: a component used for internal cluster communication

  (note that this is *not* an overlay network or a CNI plugin!)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## What's in the control plane

- Everything is stored in etcd

  (it's the only stateful component)

- Everyone communicates exclusively through the API server:

  - we (users) interact with the cluster through the API server

  - the nodes register and get their instructions through the API server

  - the other control plane components also register with the API server

- API server is the only component that reads/writes from/to etcd

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Communication protocols: API server

- The API server exposes a REST API

  (except for some calls, e.g. to attach interactively to a container)

- Almost all requests and responses are JSON following a strict format

- For performance, the requests and responses can also be done over protobuf

  (see this [design proposal](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md) for details)

- In practice, protobuf is used for all internal communication

  (between control plane components, and with kubelet)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Communication protocols: on the nodes

The kubelet agent uses a number of special-purpose protocols and interfaces, including:

- CRI (Container Runtime Interface)

  - used for communication with the container engine
  - abstracts the differences between container engines
  - based on gRPC+protobuf

- [CNI (Container Network Interface)](https://github.com/containernetworking/cni/blob/master/SPEC.md)

  - used for communication with network plugins
  - network plugins are implemented as executable programs invoked by kubelet
  - network plugins provide IPAM
  - network plugins set up network interfaces in pods

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Control plane location

The control plane can run:

- in containers, on the same nodes that run other application workloads

  (default behavior for local clusters like [Minikube](https://github.com/kubernetes/minikube), [kind](https://kind.sigs.k8s.io/)...)

- on a dedicated node

  (default behavior when deploying with kubeadm)

- on a dedicated set of nodes

  ([Kubernetes The Hard Way](https://github.com/kelseyhightower/kubernetes-the-hard-way); [kops](https://github.com/kubernetes/kops); also kubeadm)

- outside of the cluster

  (most managed clusters like AKS, DOK, EKS, GKE, Kapsule, LKE, OKE...)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

![](images/control-planes/single-node-dev.svg)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

![](images/control-planes/managed-kubernetes.svg)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

![](images/control-planes/single-control-and-workers.svg)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

![](images/control-planes/stacked-control-plane.svg)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

![](images/control-planes/advanced-control-plane.svg)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

![](images/control-planes/advanced-control-plane-split-events.svg)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

![](images/control-planes/non-dedicated-stacked-nodes.svg)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-the-kubernetes-api
class: title

 The Kubernetes API

.nav[
[Previous part](#toc-kubernetes-architecture)
|
[Back to table of contents](#toc-part-6)
|
[Next part](#toc-other-control-plane-components)
]

.debug[(automatically generated title slide)]

---

# The Kubernetes API

[
*The Kubernetes API server is a "dumb server" which offers storage, versioning, validation, update, and watch semantics on API resources.*
](
https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md#proposal-and-motivation
)

([Clayton Coleman](https://twitter.com/smarterclayton), Kubernetes Architect and Maintainer)

What does that mean?

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## The Kubernetes API is declarative

- We cannot tell the API, "run a pod"

- We can tell the API, "here is the definition for pod X"

- The API server will store that definition (in etcd)

- *Controllers* will then wake up and create a pod matching the definition

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## The core features of the Kubernetes API

- We can create, read, update, and delete objects

- We can also *watch* objects

  (be notified when an object changes, or when an object of a given type is created)

- Objects are strongly typed

- Types are *validated* and *versioned*

- Storage and watch operations are provided by etcd

  (note: the [k3s](https://k3s.io/) project allows us to use sqlite instead of etcd)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Let's experiment a bit!

- For this section, connect to the first node of the `test` cluster

.lab[

- SSH to the first node of the test cluster

- Check that the cluster is operational:
  ```bash
  kubectl get nodes
  ```

- All nodes should be `Ready`

]

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Create

- Let's create a simple object

.lab[

- Create a namespace with the following command:
  ```bash
    kubectl create -f- <<EOF
    apiVersion: v1
    kind: Namespace
    metadata:
      name: hello
    EOF
  ```

]

This is equivalent to `kubectl create namespace hello`.

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Read

- Let's retrieve the object we just created

.lab[

- Read back our object:
  ```bash
  kubectl get namespace hello -o yaml
  ```

]

We see a lot of data that wasn't here when we created the object.

Some data was automatically added to the object (like `spec.finalizers`).

Some data is dynamic (typically, the content of `status`.)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## API requests and responses

- Almost every Kubernetes API payload (requests and responses) has the same format:
  ```yaml
    apiVersion: xxx
    kind: yyy
    metadata:
      name: zzz
      (more metadata fields here)
    (more fields here)
  ```

- The fields shown above are mandatory, except for some special cases

  (e.g.: in lists of resources, the list itself doesn't have a `metadata.name`)

- We show YAML for convenience, but the API uses JSON

  (with optional protobuf encoding)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: extra-details

## API versions

- The `apiVersion` field corresponds to an *API group*

- It can be either `v1` (aka "core" group or "legacy group"), or `group/versions`; e.g.:

  - `apps/v1`
  - `rbac.authorization.k8s.io/v1`
  - `extensions/v1beta1`

- It does not indicate which version of Kubernetes we're talking about

- It *indirectly* indicates the version of the `kind`

  (which fields exist, their format, which ones are mandatory...)

- A single resource type (`kind`) is rarely versioned alone

  (e.g.: the `batch` API group contains `jobs` and `cronjobs`)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: extra-details

## Group-Version-Kind, or GVK

- A particular type will be identified by the combination of:

  - the API group it belongs to (core, `apps`, `metrics.k8s.io`, ...)

  - the version of this API group (`v1`, `v1beta1`, ...)

  - the "Kind" itself (Pod, Role, Job, ...)

- "GVK" appears a lot in the API machinery code

- Conversions are possible between different versions and even between API groups

  (e.g. when Deployments moved from `extensions` to `apps`)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Update

- Let's update our namespace object

- There are many ways to do that, including:

  - `kubectl apply` (and provide an updated YAML file)
  - `kubectl edit`
  - `kubectl patch`
  - many helpers, like `kubectl label`, or `kubectl set`

- In each case, `kubectl` will:

  - get the current definition of the object
  - compute changes
  - submit the changes (with `PATCH` requests)

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Adding a label

- For demonstration purposes, let's add a label to the namespace

- The easiest way is to use `kubectl label`

.lab[

- In one terminal, watch namespaces:
  ```bash
  kubectl get namespaces --show-labels -w
  ```

- In the other, update our namespace:
  ```bash
  kubectl label namespaces hello color=purple
  ```

]

We demonstrated *update* and *watch* semantics.

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## What's special about *watch*?

- The API server itself doesn't do anything: it's just a fancy object store

- All the actual logic in Kubernetes is implemented with *controllers*

- A *controller* watches a set of resources, and takes action when they change

- Examples:

  - when a Pod object is created, it gets scheduled and started

  - when a Pod belonging to a ReplicaSet terminates, it gets replaced

  - when a Deployment object is updated, it can trigger a rolling update

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: extra-details

## Watch events

- `kubectl get --watch` shows changes

- If we add `--output-watch-events`, we can also see:

  - the difference between ADDED and MODIFIED resources

  - DELETED resources

.lab[

- In one terminal, watch pods, displaying full events:
  ```bash
  kubectl get pods --watch --output-watch-events
  ```

- In another, run a short-lived pod:
  ```bash
  kubectl run pause --image=alpine --rm -ti --restart=Never -- sleep 5
  ```

]

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-other-control-plane-components
class: title

 Other control plane components

.nav[
[Previous part](#toc-the-kubernetes-api)
|
[Back to table of contents](#toc-part-6)
|
[Next part](#toc-kubernetes-internal-apis)
]

.debug[(automatically generated title slide)]

---

# Other control plane components

- API server ✔️

- etcd ✔️

- Controller manager

- Scheduler

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Controller manager

- This is a collection of loops watching all kinds of objects

- That's where the actual logic of Kubernetes lives

- When we create a Deployment (e.g. with `kubectl create deployment web --image=nginx`),

  - we create a Deployment object

  - the Deployment controller notices it, and creates a ReplicaSet

  - the ReplicaSet controller notices the ReplicaSet, and creates a Pod

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

## Scheduler

- When a pod is created, it is in `Pending` state

- The scheduler (or rather: *a scheduler*) must bind it to a node

  - Kubernetes comes with an efficient scheduler with many features

  - if we have special requirements, we can add another scheduler
    <br/>
    (example: this [demo scheduler](https://github.com/kelseyhightower/scheduler) uses the cost of nodes, stored in node annotations)

- A pod might stay in `Pending` state for a long time:

  - if the cluster is full

  - if the pod has special constraints that can't be met

  - if the scheduler is not running (!)

???

:EN:- Kubernetes architecture review
:FR:- Passage en revue de l'architecture de Kubernetes

.debug[[k8s/architecture.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/architecture.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-kubernetes-internal-apis
class: title

 Kubernetes Internal APIs

.nav[
[Previous part](#toc-other-control-plane-components)
|
[Back to table of contents](#toc-part-6)
|
[Next part](#toc-building-our-own-cluster-easy)
]

.debug[(automatically generated title slide)]

---
# Kubernetes Internal APIs

- Almost every Kubernetes component has some kind of internal API

  (some components even have multiple APIs on different ports!)

- At the very least, these can be used for healthchecks

  (you *should* leverage this if you are deploying and operating Kubernetes yourself!)

- Sometimes, they are used internally by Kubernetes

  (e.g. when the API server retrieves logs from kubelet)

- Let's review some of these APIs!

.debug[[k8s/internal-apis.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/internal-apis.md)]
---

## API hunting guide

This is how we found and investigated these APIs:

- look for open ports on Kubernetes nodes

  (worker nodes or control plane nodes)

- check which process owns that port

- probe the port (with `curl` or other tools)

- read the source code of that process

  (in particular when looking for API routes)

OK, now let's see the results!

.debug[[k8s/internal-apis.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/internal-apis.md)]
---

## etcd

- 2379/tcp → etcd clients

  - should be HTTPS and require mTLS authentication

- 2380/tcp → etcd peers

  - should be HTTPS and require mTLS authentication

- 2381/tcp → etcd healthcheck

  - HTTP without authentication

  - exposes two API routes: `/health` and `/metrics`

.debug[[k8s/internal-apis.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/internal-apis.md)]
---

## kubelet

- 10248/tcp → healthcheck

  - HTTP without authentication

  - exposes a single API route, `/healthz`, that just returns `ok`

- 10250/tcp → internal API

  - should be HTTPS and require mTLS authentication

  - used by the API server to obtain logs, `kubectl exec`, etc.

.debug[[k8s/internal-apis.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/internal-apis.md)]
---

class: extra-details

## kubelet API

- We can authenticate with e.g. our TLS admin certificate

- The following routes should be available:

  - `/healthz`
  - `/configz` (serves kubelet configuration)
  - `/metrics`
  - `/pods` (returns *desired state*)
  - `/runningpods` (returns *current state* from the container runtime)
  - `/logs` (serves files from `/var/log`)
  - `/containerLogs/<namespace>/<podname>/<containername>` (can add e.g. `?tail=10`)
  - `/run`, `/exec`, `/attach`, `/portForward`

- See [kubelet source code](https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/server/server.go) for details!

.debug[[k8s/internal-apis.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/internal-apis.md)]
---

class: extra-details

## Trying the kubelet API

The following example should work on a cluster deployed with `kubeadm`.

1. Obtain the key and certificate for the `cluster-admin` user.

2. Log into a node.

3. Copy the key and certificate on the node.

4. Find out the name of the `kube-proxy` pod running on that node.

5. Run the following command, updating the pod name:
   ```bash
   curl -d cmd=ls -k --cert admin.crt --key admin.key \
       https://localhost:10250/run/kube-system/`kube-proxy-xy123`/kube-proxy
   ```

... This should show the content of the root directory in the pod.

.debug[[k8s/internal-apis.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/internal-apis.md)]
---

## kube-proxy

- 10249/tcp → healthcheck

  - HTTP, without authentication

  - exposes a few API routes: `/healthz` (just returns `ok`), `/configz`, `/metrics`

- 10256/tcp → another healthcheck

  - HTTP, without authentication

  - also exposes a `/healthz` API route (but this one shows a timestamp)

.debug[[k8s/internal-apis.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/internal-apis.md)]
---

## kube-controller and kube-scheduler

- 10257/tcp → kube-controller

  - HTTPS, with optional mTLS authentication

  - `/healthz` doesn't require authentication

  - ... but `/configz` and `/metrics` do (use e.g. admin key and certificate)

- 10259/tcp → kube-scheduler

  - similar to kube-controller, with the same routes

???

:EN:- Kubernetes internal APIs
:FR:- Les APIs internes de Kubernetes
.debug[[k8s/internal-apis.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/internal-apis.md)]
---
## 19,000 words

They say, "a picture is worth one thousand words."

The following 19 slides show what really happens when we run:

```bash
kubectl create deployment web --image=nginx
```

.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/01.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/02.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/03.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/04.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/05.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/06.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/07.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/08.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/09.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/10.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/11.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/12.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/13.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/14.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/15.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/16.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/17.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/18.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/19.svg)

.debug[[k8s/deploymentslideshow.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/deploymentslideshow.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-building-our-own-cluster-easy
class: title

 Building our own cluster (easy)

.nav[
[Previous part](#toc-kubernetes-internal-apis)
|
[Back to table of contents](#toc-part-6)
|
[Next part](#toc-building-our-own-cluster-medium)
]

.debug[(automatically generated title slide)]

---
# Building our own cluster (easy)

- Let's build our own cluster!

  *Perfection is attained not when there is nothing left to add, but when there is nothing left to take away. (Antoine de Saint-Exupery)*

- Our goal is to build a minimal cluster allowing us to:

  - create a Deployment (with `kubectl create deployment`)
  - expose it with a Service
  - connect to that service


- "Minimal" here means:

  - smaller number of components
  - smaller number of command-line flags
  - smaller number of configuration files

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Non-goals

- For now, we don't care about security

- For now, we don't care about scalability

- For now, we don't care about high availability

- All we care about is *simplicity*

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Our environment

- We will use the machine indicated as `monokube1`

- This machine:

  - runs Ubuntu LTS

  - has Kubernetes, Docker, and etcd binaries installed

  - but nothing is running

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## The fine print

- We're going to use a *very old* version of Kubernetes

  (specifically, 1.19)

- Why?

- It's much easier to set up than recent versions

  - it's compatible with Docker (no need to set up CNI)

  - it doesn't require a ServiceAccount keypair

  - it can be exposed over plain HTTP (insecure but easier)

- We'll do that, and later, move to recent versions of Kubernetes!

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Checking our environment

- Let's make sure we have everything we need first

.lab[

- Log into the `monokube1` machine

- Get root:
  ```bash
  sudo -i
  ```

- Check available versions:
  ```bash
  etcd -version
  kube-apiserver --version
  dockerd --version
  ```

]

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## The plan

1. Start API server

2. Interact with it (create Deployment and Service)

3. See what's broken

4. Fix it and go back to step 2 until it works!

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Dealing with multiple processes

- We are going to start many processes

- Depending on what you're comfortable with, you can:

  - open multiple windows and multiple SSH connections

  - use a terminal multiplexer like screen or tmux

  - put processes in the background with `&`
    <br/>(warning: log output might get confusing to read!)

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting API server

.lab[

- Try to start the API server:
  ```bash
  kube-apiserver
  # It will fail with "--etcd-servers must be specified"
  ```

]

Since the API server stores everything in etcd,
it cannot start without it.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting etcd

.lab[

- Try to start etcd:
  ```bash
  etcd
  ```

]

Success!

Note the last line of output:
```
serving insecure client requests on 127.0.0.1:2379, this is strongly discouraged!
```

*Sure, that's discouraged. But thanks for telling us the address!*

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting API server (for real)

- Try again, passing the `--etcd-servers` argument

- That argument should be a comma-separated list of URLs

.lab[

- Start API server:
  ```bash
  kube-apiserver --etcd-servers http://127.0.0.1:2379
  ```

]

Success!

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Interacting with API server

- Let's try a few "classic" commands

.lab[

- List nodes:
  ```bash
  kubectl get nodes
  ```

- List services:
  ```bash
  kubectl get services
  ```

]

We should get `No resources found.` and the `kubernetes` service, respectively.

Note: the API server automatically created the `kubernetes` service entry.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

class: extra-details

## What about `kubeconfig`?

- We didn't need to create a `kubeconfig` file

- By default, the API server is listening on `localhost:8080`

  (without requiring authentication)

- By default, `kubectl` connects to `localhost:8080`

  (without providing authentication)

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Creating a Deployment

- Let's run a web server!

.lab[

- Create a Deployment with NGINX:
  ```bash
  kubectl create deployment web --image=nginx
  ```

]

Success?

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Checking our Deployment status

.lab[

- Look at pods, deployments, etc.:
  ```bash
  kubectl get all
  ```

]

Our Deployment is in bad shape:
```
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/web   0/1     0            0           2m26s
```

And, there is no ReplicaSet, and no Pod.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## What's going on?

- We stored the definition of our Deployment in etcd

  (through the API server)

- But there is no *controller* to do the rest of the work

- We need to start the *controller manager*

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting the controller manager

.lab[

- Try to start the controller manager:
  ```bash
  kube-controller-manager
  ```

]

The final error message is:
```
invalid configuration: no configuration has been provided
```

But the logs include another useful piece of information:
```
Neither --kubeconfig nor --master was specified.
Using the inClusterConfig.  This might not work.
```

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Reminder: everyone talks to API server

- The controller manager needs to connect to the API server

- It *does not* have a convenient `localhost:8080` default

- We can pass the connection information in two ways:

  - `--master` and a host:port combination (easy)

  - `--kubeconfig` and a `kubeconfig` file

- For simplicity, we'll use the first option

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting the controller manager (for real)

.lab[

- Start the controller manager:
  ```bash
  kube-controller-manager --master http://localhost:8080
  ```

]

Success!

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Checking our Deployment status

.lab[

- Check all our resources again:
  ```bash
  kubectl get all
  ```

]

We now have a ReplicaSet.

But we still don't have a Pod.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## What's going on?

In the controller manager logs, we should see something like this:
```
E0404 15:46:25.753376   22847 replica_set.go:450] Sync "default/web-5bc9bd5b8d"
failed with `No API token found for service account "default"`, retry after the
token is automatically created and added to the service account
```

- The service account `default` was automatically added to our Deployment

  (and to its pods)

- The service account `default` exists

- But it doesn't have an associated token

  (the token is a secret; creating it requires signature; therefore a CA)

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Solving the missing token issue

There are many ways to solve that issue.

We are going to list a few (to get an idea of what's happening behind the scenes).

Of course, we don't need to perform *all* the solutions mentioned here.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Option 1: disable service accounts

- Restart the API server with
  `--disable-admission-plugins=ServiceAccount`

- The API server will no longer add a service account automatically

- Our pods will be created without a service account

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Option 2: do not mount the (missing) token

- Add `automountServiceAccountToken: false` to the Deployment spec

  *or*

- Add `automountServiceAccountToken: false` to the default ServiceAccount

- The ReplicaSet controller will no longer create pods referencing the (missing) token

.lab[

- Programmatically change the `default` ServiceAccount:
  ```bash
  kubectl patch sa default -p "automountServiceAccountToken: false"
  ```

]

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Option 3: set up service accounts properly

- This is the most complex option!

- Generate a key pair

- Pass the private key to the controller manager

  (to generate and sign tokens)

- Pass the public key to the API server

  (to verify these tokens)

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Continuing without service account token

- Once we patch the default service account, the ReplicaSet can create a Pod

.lab[

- Check that we now have a pod:
  ```bash
  kubectl get all
  ```

]

Note: we might have to wait a bit for the ReplicaSet controller to retry.

If we're impatient, we can restart the controller manager.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## What's next?

- Our pod exists, but it is in `Pending` state

- Remember, we don't have a node so far

  (`kubectl get nodes` shows an empty list)

- We need to:

  - start a container engine

  - start kubelet

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting a container engine

- We're going to use Docker (because it's the default option)

.lab[

- Start the Docker Engine:
  ```bash
  dockerd
  ```

]

Success!

Feel free to check that it actually works with e.g.:
```bash
docker run alpine echo hello world
```

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting kubelet

- If we start kubelet without arguments, it *will* start

- But it will not join the cluster!

- It will start in *standalone* mode

- Just like with the controller manager, we need to tell kubelet where the API server is

- Alas, kubelet doesn't have a simple `--master` option

- We have to use `--kubeconfig`

- We need to write a `kubeconfig` file for kubelet

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Writing a kubeconfig file

- We can copy/paste a bunch of YAML

- Or we can generate the file with `kubectl`

.lab[

- Create the file `~/.kube/config` with `kubectl`:
  ```bash
    kubectl config \
            set-cluster localhost --server http://localhost:8080
    kubectl config \
            set-context localhost --cluster localhost
    kubectl config \
            use-context localhost
  ```

]

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Our `~/.kube/config` file

The file that we generated looks like the one below.

That one has been slightly simplified (removing extraneous fields), but it is still valid.

```yaml
apiVersion: v1
kind: Config
current-context: localhost
contexts:
- name: localhost
  context:
    cluster: localhost
clusters:
- name: localhost
  cluster:
    server: http://localhost:8080
```

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting kubelet

.lab[

- Start kubelet with that kubeconfig file:
  ```bash
  kubelet --kubeconfig ~/.kube/config
  ```

]

If it works: great!

If it complains about a "cgroup driver", check the next slide.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Cgroup drivers

- Cgroups ("control groups") are a Linux kernel feature

- They're used to account and limit resources

  (e.g.: memory, CPU, block I/O...)

- There are multiple ways to manipulate cgroups, including:

  - through a pseudo-filesystem (typically mounted in /sys/fs/cgroup)

  - through systemd

- Kubelet and the container engine need to agree on which method to use

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Setting the cgroup driver

- If kubelet refused to start, mentioning a cgroup driver issue, try:
  ```bash
  kubelet --kubeconfig ~/.kube/config --cgroup-driver=systemd
  ```

- That *should* do the trick!

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Looking at our 1-node cluster

- Let's check that our node registered correctly

.lab[

- List the nodes in our cluster:
  ```bash
  kubectl get nodes
  ```

]

Our node should show up.

Its name will be its hostname (it should be `monokube1`).

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Are we there yet?

- Let's check if our pod is running

.lab[

- List all resources:
  ```bash
  kubectl get all
  ```

]

--

Our pod is still `Pending`. 🤔

--

Which is normal: it needs to be *scheduled*.

(i.e., something needs to decide which node it should go on.)

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Scheduling our pod

- Why do we need a scheduling decision, since we have only one node?

- The node might be full, unavailable; the pod might have constraints ...

- The easiest way to schedule our pod is to start the scheduler

  (we could also schedule it manually)

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting the scheduler

- The scheduler also needs to know how to connect to the API server

- Just like for controller manager, we can use `--kubeconfig` or `--master`

.lab[

- Start the scheduler:
  ```bash
  kube-scheduler --master http://localhost:8080
  ```

]

- Our pod should now start correctly

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Checking the status of our pod

- Our pod will go through a short `ContainerCreating` phase

- Then it will be `Running`

.lab[

- Check pod status:
  ```bash
  kubectl get pods
  ```

]

Success!

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

class: extra-details

## Scheduling a pod manually

- We can schedule a pod in `Pending` state by creating a Binding, e.g.:
  ```bash
    kubectl create -f- <<EOF
    apiVersion: v1
    kind: Binding
    metadata:
      name: name-of-the-pod
    target:
      apiVersion: v1
      kind: Node
      name: name-of-the-node
    EOF
  ```

- This is actually how the scheduler works!

- It watches pods, makes scheduling decisions, and creates Binding objects

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Connecting to our pod

- Let's check that our pod correctly runs NGINX

.lab[

- Check our pod's IP address:
  ```bash
  kubectl get pods -o wide
  ```

- Send some HTTP request to the pod:
  ```bash
  curl `X.X.X.X`
  ```

]

We should see the `Welcome to nginx!` page.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Exposing our Deployment

- We can now create a Service associated with this Deployment

.lab[

- Expose the Deployment's port 80:
  ```bash
  kubectl expose deployment web --port=80
  ```

- Check the Service's ClusterIP, and try connecting:
  ```bash
  kubectl get service web
  curl http://`X.X.X.X`
  ```

]

--

This won't work. We need kube-proxy to enable internal communication.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Starting kube-proxy

- kube-proxy also needs to connect to the API server

- It can work with the `--master` flag

  (although that will be deprecated in the future)

.lab[

- Start kube-proxy:
  ```bash
  kube-proxy --master http://localhost:8080
  ```

]

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

## Connecting to our Service

- Now that kube-proxy is running, we should be able to connect

.lab[

- Check the Service's ClusterIP again, and retry connecting:
  ```bash
  kubectl get service web
  curl http://`X.X.X.X`
  ```

]

Success!

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

class: extra-details

## How kube-proxy works

- kube-proxy watches Service resources

- When a Service is created or updated, kube-proxy creates iptables rules

.lab[

- Check out the `OUTPUT` chain in the `nat` table:
  ```bash
  iptables -t nat -L OUTPUT
  ```

- Traffic is sent to `KUBE-SERVICES`; check that too:
  ```bash
  iptables -t nat -L KUBE-SERVICES
  ```

]

For each Service, there is an entry in that chain.

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

class: extra-details

## Diving into iptables

- The last command showed a chain named `KUBE-SVC-...` corresponding to our service

.lab[

- Check that `KUBE-SVC-...` chain:
  ```bash
  iptables -t nat -L `KUBE-SVC-...`
  ```

- It should show a jump to a `KUBE-SEP-...` chains; check it out too:
  ```bash
  iptables -t nat -L `KUBE-SEP-...`
  ```

]

This is a `DNAT` rule to rewrite the destination address of the connection to our pod.

This is how kube-proxy works!

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

class: extra-details

## kube-router, IPVS

- With recent versions of Kubernetes, it is possible to tell kube-proxy to use IPVS

- IPVS is a more powerful load balancing framework

  (remember: iptables was primarily designed for firewalling, not load balancing!)

- It is also possible to replace kube-proxy with kube-router

- kube-router uses IPVS by default

- kube-router can also perform other functions

  (e.g., we can use it as a CNI plugin to provide pod connectivity)

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

class: extra-details

## What about the `kubernetes` service?

- If we try to connect, it won't work

  (by default, it should be `10.0.0.1`)

- If we look at the Endpoints for this service, we will see one endpoint:

  `host-address:6443`

- By default, the API server expects to be running directly on the nodes

  (it could be as a bare process, or in a container/pod using the host network)

- ... And it expects to be listening on port 6443 with TLS

???

:EN:- Building our own cluster from scratch
:FR:- Construire son cluster à la main

.debug[[k8s/dmuc-easy.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-easy.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-building-our-own-cluster-medium
class: title

 Building our own cluster (medium)

.nav[
[Previous part](#toc-building-our-own-cluster-easy)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-building-our-own-cluster-hard)
]

.debug[(automatically generated title slide)]

---
# Building our own cluster (medium)

- This section assumes that you already went through

  *“Building our own cluster (easy)”*

- In that section, we saw how to run each control plane component manually...

  ...but with an older version of Kubernetes (1.19)

- In this section, we're going to do something similar...

  ...but with recent versions of Kubernetes!

- Note: we won't need the lab environment of that previous section

  (we're going to build a new cluster from scratch)

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## What remains the same

- We'll use machines with Kubernetes binaries pre-downloaded

- We'll run individual components by hand

  (etcd, API server, controller manager, scheduler, kubelet)

- We'll run on a single node

  (but we'll be laying the groundwork to add more nodes)

- We'll get the cluster to the point where we can run and expose pods

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## What's different

- We'll need to generate TLS keys and certificates

  (because it's mandatory with recent versions of Kubernetes)

- Things will be *a little bit more* secure

  (but still not 100% secure, far from it!)

- We'll use containerd instead of Docker

  (you could probably try with CRI-O or another CRI engine, too)

- We'll need to set up CNI for networking

- *And we won't do everything as root this time (but we might use `sudo` a lot)*

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Our environment

- We will use the machine indicated as `polykube1`

- This machine:

  - runs Ubuntu LTS

  - has Kubernetes, etcd, and CNI binaries installed

  - but nothing is running

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Checking our environment

- Let's make sure we have everything we need first

.lab[

- Log into the `polykube1` machine

- Check available versions:
  ```bash
  etcd -version
  kube-apiserver --version
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## The plan

We'll follow the same methodology as for the "easy" section

1. Start API server

2. Interact with it (create Deployment and Service)

3. See what's broken

4. Fix it and go back to step 2 until it works!

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Dealing with multiple processes

- Again, we are going to start many processes

- Depending on what you're comfortable with, you can:

  - open multiple windows and multiple SSH connections

  - use a terminal multiplexer like screen or tmux

  - put processes in the background with `&`
    <br/>(warning: log output might get confusing to read!)

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Starting API server

.lab[

- Try to start the API server:
  ```bash
  kube-apiserver
  # It will complain about permission to /var/run/kubernetes

  sudo kube-apiserver
  # Now it will complain about a bunch of missing flags, including:
  # --etcd-servers
  # --service-account-issuer
  # --service-account-signing-key-file
  ```

]

Just like before, we'll need to start etcd.

But we'll also need some TLS keys!

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Generating TLS keys

- There are many ways to generate TLS keys (and certificates)

- A very popular and modern tool to do that is [cfssl]

- We're going to use the old-fashioned [openssl] CLI

- Feel free to use cfssl or any other tool if you prefer!

[cfssl]: https://github.com/cloudflare/cfssl#using-the-command-line-tool
[openssl]: https://www.openssl.org/docs/man3.0/man1/

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## How many keys do we need?

At the very least, we need the following two keys:

- ServiceAccount key pair

- API client key pair, aka "CA key"

  (technically, we will need a *certificate* for that key pair)

But if we wanted to tighten the cluster security, we'd need many more...

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## The other keys

These keys are not strictly necessary at this point:

- etcd key pair

  *without that key, communication with etcd will be insecure*

- API server endpoint key pair

  *the API server will generate this one automatically if we don't*

- kubelet key pair (used by API server to connect to kubelets)

  *without that key, commands like kubectl logs/exec will be insecure*

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Would you like some auth with that?

If we want to enable authentication and authorization, we also need various API client key pairs signed by the "CA key" mentioned earlier. That would include (non-exhaustive list):

- controller manager key pair

- scheduler key pair

- in most cases: kube-proxy (or equivalent) key pair

- in most cases: key pairs for the nodes joining the cluster

  (these might be generated through TLS bootstrap tokens)

- key pairs for users that will interact with the clusters

  (unless another authentication mechanism like OIDC is used)

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Generating our keys and certificates

.lab[

- Generate the ServiceAccount key pair:
  ```bash
  openssl genrsa -out sa.key 2048
  ```

- Generate the CA key pair:
  ```bash
  openssl genrsa -out ca.key 2048
  ```

- Generate a self-signed certificate for the CA key:
  ```bash
  openssl x509 -new -key ca.key -out ca.cert -subj /CN=kubernetes/
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Starting etcd

- This one is easy!

.lab[

- Start etcd:
  ```bash
  etcd
  ```

]

Note: if you want a bit of extra challenge, you can try
to generate the etcd key pair and use it.

(You will need to pass it to etcd and to the API server.)

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Starting API server

- We need to use the keys and certificate that we just generated

.lab[

- Start the API server:
  ```bash
  sudo kube-apiserver \
  	--etcd-servers=http://localhost:2379 \
  	--service-account-signing-key-file=sa.key \
  	--service-account-issuer=https://kubernetes \
  	--service-account-key-file=sa.key \
  	--client-ca-file=ca.cert
  ```

]

The API server should now start.

But can we really use it? 🤔

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Trying `kubectl`

- Let's try some simple `kubectl` command

.lab[

- Try to list Namespaces:
  ```bash
  kubectl get namespaces
  ```

]

We're getting an error message like this one:

```
The connection to the server localhost:8080 was refused -
did you specify the right host or port?
```

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## What's going on?

- Recent versions of Kubernetes don't support unauthenticated API access

- The API server doesn't support listening on plain HTTP anymore

- `kubectl` still tries to connect to `localhost:8080` by default

- But there is nothing listening there

- Our API server listens on port 6443, using TLS

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Trying to access the API server

- Let's use `curl` first to confirm that everything works correctly

  (and then we will move to `kubectl`)

.lab[

- Try to connect with `curl`:
  ```bash
  curl https://localhost:6443
  # This will fail because the API server certificate is unknown.
  ```

- Try again, skipping certificate verification:
  ```bash
  curl --insecure https://localhost:6443
  ```

]

We should now see an `Unauthorized` Kubernetes API error message.
</br>
We need to authenticate with our key and certificate.

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Authenticating with the API server

- For the time being, we can use the CA key and cert directly

- In a real world scenario, we would *never* do that!

  (because we don't want the CA key to be out there in the wild)

.lab[

- Try again, skipping cert verification, and using the CA key and cert:
  ```bash
  curl --insecure --key ca.key --cert ca.cert https://localhost:6443
  ```

]

We should see a list of API routes.

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

class: extra-details

## Doing it right

In the future, instead of using the CA key and certificate,
we should generate a new key, and a certificate for that key,
signed by the CA key.

Then we can use that new key and certificate to authenticate.

Example:

```
### Generate a key pair
openssl genrsa -out user.key

### Extract the public key
openssl pkey -in user.key -out user.pub -pubout

### Generate a certificate signed by the CA key
openssl x509 -new -key ca.key -force_pubkey user.pub -out user.cert \
        -subj /CN=kubernetes-user/
```

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Writing a kubeconfig file

- We now want to use `kubectl` instead of `curl`

- We'll need to write a kubeconfig file for `kubectl`

- There are many way to do that; here, we're going to use `kubectl config`

- We'll need to:

  - set the "cluster" (API server endpoint)

  - set the "credentials" (the key and certficate)

  - set the "context" (referencing the cluster and credentials)

  - use that context (make it the default that `kubectl` will use)

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Set the cluster

The "cluster" section holds the API server endpoint.

.lab[

- Set the API server endpoint:
  ```bash
  kubectl config set-cluster polykube --server=https://localhost:6443
  ```

- Don't verify the API server certificate:
  ```bash
  kubectl config set-cluster polykube --insecure-skip-tls-verify
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Set the credentials

The "credentials" section can hold a TLS key and certificate, or a token, or configuration information for a plugin (for instance, when using AWS EKS or GCP GKE, they use a plugin).

.lab[

- Set the client key and certificate:
  ```bash
  kubectl config set-credentials polykube \
  			--client-key ca.key \
  			--client-certificate ca.cert 
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Set and use the context

The "context" section references the "cluster" and "credentials" that we defined earlier.

(It can also optionally reference a Namespace.)

.lab[

- Set the "context":
  ```bash
  kubectl config set-context polykube --cluster polykube --user polykube
  ```

- Set that context to be the default context:
  ```bash
  kubectl config use-context polykube
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Review the kubeconfig file

The kubeconfig file should look like this:

.small[
```yaml
apiVersion: v1
clusters:
- cluster:
    insecure-skip-tls-verify: true
    server: https://localhost:6443
  name: polykube
contexts:
- context:
    cluster: polykube
    user: polykube
  name: polykube
current-context: polykube
kind: Config
preferences: {}
users:
- name: polykube
  user:
    client-certificate: /root/ca.cert
    client-key: /root/ca.key
```
]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Trying the kubeconfig file

- We should now be able to access our cluster's API!

.lab[

- Try to list Namespaces:
  ```bash
  kubectl get namespaces
  ```
]

This should show the classic `default`, `kube-system`, etc.

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

class: extra-details

## Do we need `--client-ca-file` ?

Technically, we didn't need to specify the `--client-ca-file` flag!

But without that flag, no client can be authenticated.

Which means that we wouldn't be able to issue any API request!

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Running pods

- We can now try to create a Deployment

.lab[

- Create a Deployment:
  ```bash
  kubectl create deployment blue --image=jpetazzo/color
  ```

- Check the results:
  ```bash
  kubectl get deployments,replicasets,pods
  ```

]

Our Deployment exists, but not the Replica Set or Pod.

We need to run the controller manager.

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Running the controller manager

- Previously, we used the `--master` flag to pass the API server address

- Now, we need to authenticate properly

- The simplest way at this point is probably to use the same kubeconfig file!

.lab[

- Start the controller manager:
  ```bash
  kube-controller-manager --kubeconfig .kube/config
  ```

- Check the results:
  ```bash
  kubectl get deployments,replicasets,pods
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## What's next?

- Normally, the last commands showed us a Pod in `Pending` state

- We need two things to continue:

  - the scheduler (to assign the Pod to a Node)

  - a Node!

- We're going to run `kubelet` to register the Node with the cluster

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Running `kubelet`

- Let's try to run `kubelet` and see what happens!

.lab[

- Start `kubelet`:
  ```bash
  sudo kubelet
  ```

]

We should see an error about connecting to `containerd.sock`.

We need to run a container engine!

(For instance, `containerd`.)

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Running `containerd`

- We need to install and start `containerd`

- You could try another engine if you wanted

  (but there might be complications!)

.lab[

- Install `containerd`:
  ```bash
  sudo apt-get install containerd
  ```

- Start `containerd`:
  ```bash
  sudo containerd
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

class: extra-details

## Configuring `containerd`

Depending on how we install `containerd`, it might need a bit of extra configuration.

Watch for the following symptoms:

- `containerd` refuses to start

  (rare, unless there is an *invalid* configuration)

- `containerd` starts but `kubelet` can't connect

  (could be the case if the configuration disables the CRI socket)

- `containerd` starts and things work but Pods keep being killed

  (may happen if there is a mismatch in the cgroups driver)

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Starting `kubelet` for good

- Now that `containerd` is running, `kubelet` should start!

.lab[

- Try to start `kubelet`:
  ```bash
  sudo kubelet
  ```

- In another terminal, check if our Node is now visible:
  ```bash
  sudo kubectl get nodes
  ```

]

`kubelet` should now start, but our Node doesn't show up in `kubectl get nodes`!

This is because without a kubeconfig file, `kubelet` runs in standalone mode:
<br/>
it will not connect to a Kubernetes API server, and will only start *static pods*.

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Passing the kubeconfig file

- Let's start `kubelet` again, with our kubeconfig file

.lab[

- Stop `kubelet` (e.g. with `Ctrl-C`)

- Restart it with the kubeconfig file:
  ```bash
  sudo kubelet --kubeconfig .kube/config
  ```

- Check our list of Nodes:
  ```bash
  kubectl get nodes
  ```

]

This time, our Node should show up!

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Node readiness

- However, our Node shows up as `NotReady`

- If we wait a few minutes, the `kubelet` logs will tell us why:

  *we're missing a CNI configuration!*

- As a result, the containers can't be connected to the network

- `kubelet` detects that and doesn't become `Ready` until this is fixed

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## CNI configuration

- We need to provide a CNI configuration

- This is a file in `/etc/cni/net.d`

  (the name of the file doesn't matter; the first file in lexicographic order will be used)

- Usually, when installing a "CNI plugin¹", this file gets installed automatically

- Here, we are going to write that file manually

.footnote[¹Technically, a *pod network*; typically running as a DaemonSet, which will install the file with a `hostPath` volume.]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Our CNI configuration

Create the following file in e.g. `/etc/cni/net.d/kube.conf`:

```json
{
  "cniVersion": "0.3.1",
  "name": "kube",
  "type": "bridge",
  "bridge": "cni0",
  "isDefaultGateway": true,
  "ipMasq": true,
  "hairpinMode": true,
  "ipam": {
    "type": "host-local",
    "subnet": "10.1.1.0/24"
  }
}
```

That's all we need - `kubelet` will detect and validate the file automatically!

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Checking our Node again

- After a short time (typically about 10 seconds) the Node should be `Ready`

.lab[

- Wait until the Node is `Ready`:
  ```bash
  kubectl get nodes
  ```

]

If the Node doesn't show up as `Ready`, check the `kubelet` logs.

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## What's next?

- At this point, we have a `Pending` Pod and a `Ready` Node

- All we need is the scheduler to bind the former to the latter

.lab[

- Run the scheduler:
  ```bash
  kube-scheduler --kubeconfig .kube/config
  ```

- Check that the Pod gets assigned to the Node and becomes `Running`:
  ```bash
  kubectl get pods
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Check network access

- Let's check that we can connect to our Pod, and that the Pod can connect outside

.lab[

- Get the Pod's IP address:
  ```bash
  kubectl get pods -o wide
  ```

- Connect to the Pod (make sure to update the IP address):
  ```bash
  curl `10.1.1.2`
  ```

- Check that the Pod has external connectivity too:
  ```bash
  kubectl exec `blue-xxxxxxxxxx-yyyyy` -- ping -c3 1.1
  ```

]

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Expose our Deployment

- We can now try to expose the Deployment and connect to the ClusterIP

.lab[

- Expose the Deployment:
  ```bash
  kubectl expose deployment blue --port=80
  ```

- Retrieve the ClusterIP:
  ```bash
  kubectl get services
  ```

- Try to connect to the ClusterIP:
  ```bash
  curl `10.0.0.42`
  ```
]

At this point, it won't work - we need to run `kube-proxy`!

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## Running `kube-proxy`

- We need to run `kube-proxy`

  (also passing it our kubeconfig file)

.lab[

- Run `kube-proxy`:
  ```bash
  sudo kube-proxy --kubeconfig .kube/config
  ```

- Try again to connect to the ClusterIP:
  ```bash
  curl `10.0.0.42`
  ```

]

This time, it should work.

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

## What's next?

- Scale up the Deployment, and check that load balancing works properly 

- Enable RBAC, and generate individual certificates for each controller

  (check the [certificate paths][certpath] section in the Kubernetes documentation
  for a detailed list of all the certificates and keys that are used by the
  control plane, and which flags are used by which components to configure them!)

- Add more nodes to the cluster

*Feel free to try these if you want to get additional hands-on experience!*

[certpath]: https://kubernetes.io/docs/setup/best-practices/certificates/#certificate-paths

???

:EN:- Setting up control plane certificates
:EN:- Implementing a basic CNI configuration
:FR:- Mettre en place les certificats du plan de contrôle
:FR:- Réaliser un configuration CNI basique

.debug[[k8s/dmuc-medium.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-medium.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-building-our-own-cluster-hard
class: title

 Building our own cluster (hard)

.nav[
[Previous part](#toc-building-our-own-cluster-medium)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-adding-nodes-to-the-cluster)
]

.debug[(automatically generated title slide)]

---
# Building our own cluster (hard)

- This section assumes that you already went through

  *“Building our own cluster (medium)”*

- In that previous section, we built a cluster with a single node

- In this new section, we're going to add more nodes to the cluster

- Note: we will need the lab environment of that previous section

- If you haven't done it yet, you should go through that section first

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Our environment

- On `polykube1`, we should have our Kubernetes control plane

- We're also assuming that we have the kubeconfig file created earlier

  (in `~/.kube/config`)

- We're going to work on `polykube2` and add it to the cluster

- This machine has exactly the same setup as `polykube1`

  (Ubuntu LTS with CNI, etcd, and Kubernetes binaries installed)

- Note that we won't need the etcd binaries here

  (the control plane will run solely on `polykube1`)

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Checklist

We need to:

- generate the kubeconfig file for `polykube2`

- install a container engine

- generate a CNI configuration file

- start kubelet

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Generating the kubeconfig file

- Ideally, we should generate a key pair and certificate for `polykube2`...

- ...and generate a kubeconfig file using these

- At the moment, for simplicity, we'll use the same key pair and certificate as earlier

- We have a couple of options:

  - copy the required files (kubeconfig, key pair, certificate)

  - "flatten" the kubeconfig file (embed the key and certificate within)

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

class: extra-details

## To flatten or not to flatten?

- "Flattening" the kubeconfig file can seem easier

  (because it means we'll only have one file to move around)

- But it's easier to rotate the key or renew the certificate when they're in separate files

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Flatten and copy the kubeconfig file

- We'll flatten the file and copy it over

.lab[

- On `polykube1`, flatten the kubeconfig file:
  ```bash
  kubectl config view --flatten > kubeconfig
  ```

- Then copy it to `polykube2`:
   ```bash
   scp kubeconfig polykube2:
   ```

]

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Generate CNI configuration

Back on `polykube2`, put the following in `/etc/cni/net.d/kube.conf`:

```json
{
  "cniVersion": "0.3.1",
  "name": "kube",
  "type": "bridge",
  "bridge": "cni0",
  "isDefaultGateway": true,
  "ipMasq": true,
  "hairpinMode": true,
  "ipam": {
    "type": "host-local",
    "subnet": `"10.1.2.0/24"`
  }
}
```

Note how we changed the subnet!

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Install container engine and start `kubelet`

.lab[

- Install `containerd`:
  ```bash
  sudo apt-get install containerd -y
  ```

- Start `containerd`:
  ```bash
  sudo systemctl start containerd
  ```

- Start `kubelet`:
  ```bash
  sudo kubelet --kubeconfig kubeconfig
  ```

]

We're getting errors looking like:
```
"Post \"https://localhost:6443/api/v1/nodes\": ... connect: connection refused"
```

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Updating the kubeconfig file

- Our kubeconfig file still references `localhost:6443`

- This was fine on `polykube1`

  (where `kubelet` was connecting to the control plane running locally)

- On `polykube2`, we need to change that and put the address of the API server

  (i.e. the address of `polykube1`)

.lab[

- Update the `kubeconfig` file:
  ```bash
  sed -i s/localhost:6443/polykube1:6443/ kubeconfig
  ```

]

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Starting `kubelet`

- `kubelet` should now start correctly (hopefully!)

.lab[

- On `polykube2`, start `kubelet`:
  ```bash
  sudo kubelet --kubeconfig kubeconfig
  ```

- On `polykube1`, check that `polykube2` shows up and is `Ready`:
  ```bash
  kubectl get nodes
  ```

]

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Testing connectivity

- From `polykube1`, can we connect to Pods running on `polykube2`? 🤔

.lab[

- Scale the test Deployment:
  ```bash
  kubectl scale deployment blue --replicas=5
  ```

- Get the IP addresses of the Pods:
  ```bash
  kubectl get pods -o wide
  ```

- Pick a Pod on `polykube2` and try to connect to it:
  ```bash
  curl `10.1.2.2`
  ```

]

--

At that point, it doesn't work.

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Refresher on the *pod network*

- The *pod network* (or *pod-to-pod network*) has a few responsibilities:

  - allocating and managing Pod IP addresses

  - connecting Pods and Nodes

  - connecting Pods together on a given node

  - *connecting Pods together across nodes*

- That last part is the one that's not functioning in our cluster

- It typically requires some combination of routing, tunneling, bridging...

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Connecting networks together

- We can add manual routes between our nodes

- This requires adding `N x (N-1)` routes

  (on each node, add a route to every other node)

- This will work on home labs where nodes are directly connected

  (e.g. on an Ethernet switch, or same WiFi network, or a bridge between local VMs)

- ...Or on clouds where IP address filtering has been disabled

  (by default, most cloud providers will discard packets going to unknown IP addresses)

- If IP address filtering is enabled, you'll have to use e.g. tunneling or overlay networks

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Important warning

- The technique that we are about to use doesn't work everywhere

- It only works if:

  - all the nodes are directly connected to each other (at layer 2)

  - the underlying network allows the IP addresses of our pods

- If we are on physical machines connected by a switch: OK

- If we are on virtual machines in a public cloud: NOT OK

  - on AWS, we need to disable "source and destination checks" on our instances

  - on OpenStack, we need to disable "port security" on our network ports

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Routing basics

- We need to tell *each* node:

  "The subnet 10.1.N.0/24 is located on node N" (for all values of N)

- This is how we add a route on Linux:
  ```bash
  ip route add 10.1.N.0/24 via W.X.Y.Z
  ```

  (where `W.X.Y.Z` is the internal IP address of node N)

- We can see the internal IP addresses of our nodes with:
  ```bash
  kubectl get nodes -o wide
  ```

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## Adding our route

- Let's add a route from `polykube1` to `polykube2`

.lab[

- Check the internal address of `polykube2`:
  ```bash
  kubectl get node polykube2 -o wide
  ```

- Now, on `polykube1`, add the route to the Pods running on `polykube2`:
  ```bash
  sudo ip route add 10.1.2.0/24 via `A.B.C.D`
  ```

- Finally, check that we can now connect to a Pod running on `polykube2`:
  ```bash
  curl 10.1.2.2
  ```

]

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

## What's next?

- The network configuration feels very manual:

  - we had to generate the CNI configuration file (in `/etc/cni/net.d`)

  - we had to manually update the nodes' routing tables

- Can we automate that?

  **YES!**

- We could install something like [kube-router](https://www.kube-router.io/)

  (which specifically takes care of the CNI configuration file and populates routing tables)

- Or we could also go with e.g. [Cilium](https://cilium.io/)

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

class: extra-details

## If you want to try Cilium...

- Add the `--root-ca-file` flag to the controller manager:

  - use the certificate automatically generated by the API server
    <br/>
    (it should be in `/var/run/kubernetes/apiserver.crt`)

  - or generate a key pair and certificate for the API server and point to
  that certificate

  - without that, you'll get certificate validation errors
    <br/>
    (because in our Pods, the `ca.crt` file used to validate the API server will be empty)

- Check the Cilium [without kube-proxy][ciliumwithoutkubeproxy] instructions

  (make sure to pass the API server IP address and port!)

- Other pod-to-pod network implementations might also require additional steps

[ciliumwithoutkubeproxy]: https://docs.cilium.io/en/stable/network/kubernetes/kubeproxy-free/#kubeproxy-free

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

class: extra-details

## About the API server certificate...

- In the previous sections, we've skipped API server certificate verification

- To generate a proper certificate, we need to include a `subjectAltName` extension

- And make sure that the CA includes the extension in the certificate

```bash
openssl genrsa -out apiserver.key 4096

openssl req -new -key apiserver.key -subj /CN=kubernetes/ \
        -addext "subjectAltName = DNS:kubernetes.default.svc, \
        DNS:kubernetes.default, DNS:kubernetes, \
        DNS:localhost, DNS:polykube1" -out apiserver.csr

openssl x509 -req -in apiserver.csr -CAkey ca.key -CA ca.cert \
        -out apiserver.crt -copy_extensions copy
```

???

:EN:- Connecting nodes and pods
:FR:- Interconnecter les nœuds et les pods

.debug[[k8s/dmuc-hard.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/dmuc-hard.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-adding-nodes-to-the-cluster
class: title

 Adding nodes to the cluster

.nav[
[Previous part](#toc-building-our-own-cluster-hard)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-the-container-network-interface)
]

.debug[(automatically generated title slide)]

---
# Adding nodes to the cluster

- So far, our cluster has only 1 node

- Let's see what it takes to add more nodes

- We are going to use another set of machines: `kubenet`

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## The environment

- We have 3 identical machines: `kubenet1`, `kubenet2`, `kubenet3`

- The Docker Engine is installed (and running) on these machines

- The Kubernetes binaries are installed, but nothing is running

- We will use `kubenet1` to run the control plane

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## The plan

- Start the control plane on `kubenet1`

- Join the 3 nodes to the cluster

- Deploy and scale a simple web server

.lab[

- Log into `kubenet1`

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Running the control plane

- We will use a Compose file to start the control plane components

.lab[

- Clone the repository containing the workshop materials:
  ```bash
  git clone https://
  ```

- Go to the `compose/simple-k8s-control-plane` directory:
  ```bash
  cd container.training/compose/simple-k8s-control-plane
  ```

- Start the control plane:
  ```bash
  docker-compose up
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Checking the control plane status

- Before moving on, verify that the control plane works

.lab[

- Show control plane component statuses:
  ```bash
  kubectl get componentstatuses
  kubectl get cs
  ```

- Show the (empty) list of nodes:
  ```bash
  kubectl get nodes
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

class: extra-details

## Differences from `dmuc`

- Our new control plane listens on `0.0.0.0` instead of the default `127.0.0.1`

- The ServiceAccount admission plugin is disabled

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Joining the nodes

- We need to generate a `kubeconfig` file for kubelet

- This time, we need to put the public IP address of `kubenet1`

  (instead of `localhost` or `127.0.0.1`)

.lab[

- Generate the `kubeconfig` file:
  ```bash
    kubectl config set-cluster kubenet --server http://`X.X.X.X`:8080
    kubectl config set-context kubenet --cluster kubenet
    kubectl config use-context kubenet
    cp ~/.kube/config ~/kubeconfig
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Distributing the `kubeconfig` file

- We need that `kubeconfig` file on the other nodes, too

.lab[

- Copy `kubeconfig` to the other nodes:
  ```bash
    for N in 2 3; do
    	scp ~/kubeconfig kubenet$N:
    done
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Starting kubelet

- Reminder: kubelet needs to run as root; don't forget `sudo`!

.lab[

- Join the first node:
   ```bash
   sudo kubelet --kubeconfig ~/kubeconfig
   ```

- Open more terminals and join the other nodes to the cluster:
  ```bash
  ssh kubenet2 sudo kubelet --kubeconfig ~/kubeconfig
  ssh kubenet3 sudo kubelet --kubeconfig ~/kubeconfig
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Checking cluster status

- We should now see all 3 nodes

- At first, their `STATUS` will be `NotReady`

- They will move to `Ready` state after approximately 10 seconds

.lab[

- Check the list of nodes:
  ```bash
  kubectl get nodes
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Deploy a web server

- Let's create a Deployment and scale it

  (so that we have multiple pods on multiple nodes)

.lab[

- Create a Deployment running `jpetazzo/color`:
  ```bash
  kubectl create deployment blue --image=jpetazzo/color
  ```

- Scale it:
  ```bash
  kubectl scale deployment blue --replicas=5
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Check our pods

- The pods will be scheduled on the nodes

- The nodes will pull the `jpetazzo/color` image, and start the pods

- What are the IP addresses of our pods?

.lab[

- Check the IP addresses of our pods
  ```bash
  kubectl get pods -o wide
  ```

]

--

🤔 Something's not right ... Some pods have the same IP address!

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## What's going on?

- Without the `--network-plugin` flag, kubelet defaults to "no-op" networking

- It lets the container engine use a default network

  (in that case, we end up with the default Docker bridge)

- Our pods are running on independent, disconnected, host-local networks

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## What do we need to do?

- On a normal cluster, kubelet is configured to set up pod networking with CNI plugins

- This requires:

  - installing CNI plugins

  - writing CNI configuration files

  - running kubelet with `--network-plugin=cni`

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Using network plugins

- We need to set up a better network

- Before diving into CNI, we will use the `kubenet` plugin

- This plugin creates a `cbr0` bridge and connects the containers to that bridge

- This plugin allocates IP addresses from a range:

  - either specified to kubelet (e.g. with `--pod-cidr`)

  - or stored in the node's `spec.podCIDR` field

.footnote[See [here][kubenet-plugin] for more details about this `kubenet` plugin.]

[kubenet-plugin]: https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#kubenet

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## What `kubenet` does and *does not* do

- It allocates IP addresses to pods *locally*

  (each node has its own local subnet)

- It connects the pods to a *local* bridge

  (pods on the same node can communicate together; not with other nodes)

- It doesn't set up routing or tunneling

  (we get pods on separated networks; we need to connect them somehow)

- It doesn't allocate subnets to nodes

  (this can be done manually, or by the controller manager) 

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Setting up routing or tunneling

- *On each node*, we will add routes to the other nodes' pod network

- Of course, this is not convenient or scalable!

- We will see better techniques to do this; but for now, hang on!

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Allocating subnets to nodes

- There are multiple options:

  - passing the subnet to kubelet with the `--pod-cidr` flag

  - manually setting `spec.podCIDR` on each node

  - allocating node CIDRs automatically with the controller manager

- The last option would be implemented by adding these flags to controller manager:
  ```
  --allocate-node-cidrs=true --cluster-cidr=<cidr> 
  ```

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

class: extra-details

## The pod CIDR field is not mandatory

- `kubenet` needs the pod CIDR, but other plugins don't need it

  (e.g. because they allocate addresses in multiple pools, or a single big one)

- The pod CIDR field may eventually be deprecated and replaced by an annotation

  (see [kubernetes/kubernetes#57130](https://github.com/kubernetes/kubernetes/issues/57130))

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Restarting kubelet wih pod CIDR

- We need to stop and restart all our kubelets

- We will add the `--network-plugin` and `--pod-cidr` flags

- We all have a "cluster number" (let's call that `C`) printed on your VM info card

- We will use pod CIDR `10.C.N.0/24` (where `N` is the node number: 1, 2, 3)

.lab[

- Stop all the kubelets (Ctrl-C is fine)

- Restart them all, adding `--network-plugin=kubenet --pod-cidr 10.C.N.0/24`

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## What happens to our pods?

- When we stop (or kill) kubelet, the containers keep running

- When kubelet starts again, it detects the containers

.lab[

- Check that our pods are still here:
  ```bash
  kubectl get pods -o wide
  ```

]

🤔 But our pods still use local IP addresses!

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Recreating the pods

- The IP address of a pod cannot change

- kubelet doesn't automatically kill/restart containers with "invalid" addresses
  <br/>
  (in fact, from kubelet's point of view, there is no such thing as an "invalid" address)

- We must delete our pods and recreate them

.lab[

- Delete all the pods, and let the ReplicaSet recreate them:
  ```bash
  kubectl delete pods --all
  ```

- Wait for the pods to be up again:
  ```bash
  kubectl get pods -o wide -w
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Adding kube-proxy

- Let's start kube-proxy to provide internal load balancing

- Then see if we can create a Service and use it to contact our pods

.lab[

- Start kube-proxy:
  ```bash
  sudo kube-proxy --kubeconfig ~/.kube/config
  ```

- Expose our Deployment:
  ```bash
  kubectl expose deployment blue --port=80
  ```

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Test internal load balancing

.lab[

- Retrieve the ClusterIP address:
  ```bash
  kubectl get svc blue
  ```

- Send a few requests to the ClusterIP address (with `curl`)

]

--

Sometimes it works, sometimes it doesn't. Why?

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Routing traffic

- Our pods have new, distinct IP addresses

- But they are on host-local, isolated networks

- If we try to ping a pod on a different node, it won't work

- kube-proxy merely rewrites the destination IP address

- But we need that IP address to be reachable in the first place

- How do we fix this?

  (hint: check the title of this slide!)

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Important warning

- The technique that we are about to use doesn't work everywhere

- It only works if:

  - all the nodes are directly connected to each other (at layer 2)

  - the underlying network allows the IP addresses of our pods

- If we are on physical machines connected by a switch: OK

- If we are on virtual machines in a public cloud: NOT OK

  - on AWS, we need to disable "source and destination checks" on our instances

  - on OpenStack, we need to disable "port security" on our network ports

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Routing basics

- We need to tell *each* node:

  "The subnet 10.C.N.0/24 is located on node N" (for all values of N)

- This is how we add a route on Linux:
  ```bash
  ip route add 10.C.N.0/24 via W.X.Y.Z
  ```

  (where `W.X.Y.Z` is the internal IP address of node N)

- We can see the internal IP addresses of our nodes with:
  ```bash
  kubectl get nodes -o wide
  ```

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Firewalling

- By default, Docker prevents containers from using arbitrary IP addresses

  (by setting up iptables rules)

- We need to allow our containers to use our pod CIDR

- For simplicity, we will insert a blanket iptables rule allowing all traffic:

  `iptables -I FORWARD -j ACCEPT`

- This has to be done on every node

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## Setting up routing

.lab[

- Create all the routes on all the nodes

- Insert the iptables rule allowing traffic

- Check that you can ping all the pods from one of the nodes

- Check that you can `curl` the ClusterIP of the Service successfully

]

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

## What's next?

- We did a lot of manual operations:

  - allocating subnets to nodes

  - adding command-line flags to kubelet

  - updating the routing tables on our nodes

- We want to automate all these steps

- We want something that works on all networks

???

:EN:- Connecting nodes ands pods
:FR:- Interconnecter les nœuds et les pods

.debug[[k8s/multinode.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/multinode.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-the-container-network-interface
class: title

 The Container Network Interface

.nav[
[Previous part](#toc-adding-nodes-to-the-cluster)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-cni-internals)
]

.debug[(automatically generated title slide)]

---
# The Container Network Interface

- Allows us to decouple network configuration from Kubernetes

- Implemented by *plugins*

- Plugins are executables that will be invoked by kubelet

- Plugins are responsible for:

  - allocating IP addresses for containers

  - configuring the network for containers

- Plugins can be combined and chained when it makes sense

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Combining plugins

- Interface could be created by e.g. `vlan` or `bridge` plugin

- IP address could be allocated by e.g. `dhcp` or `host-local` plugin

- Interface parameters (MTU, sysctls) could be tweaked by the `tuning` plugin

The reference plugins are available [here][cni-reference-plugins].

Look in each plugin's directory for its documentation.

[cni-reference-plugins]: https://github.com/containernetworking/plugins/tree/master/plugins

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## How does kubelet know which plugins to use?

- The plugin (or list of plugins) is set in the CNI configuration

- The CNI configuration is a *single file* in `/etc/cni/net.d`

- If there are multiple files in that directory, the first one is used

  (in lexicographic order)

- That path can be changed with the `--cni-conf-dir` flag of kubelet

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## CNI configuration in practice

- When we set up the "pod network" (like Calico, Weave...) it ships a CNI configuration

  (and sometimes, custom CNI plugins)

- Very often, that configuration (and plugins) is installed automatically

  (by a DaemonSet featuring an initContainer with hostPath volumes)

- Examples:

  - Calico [CNI config](https://github.com/projectcalico/calico/blob/1372b56e3bfebe2b9c9cbf8105d6a14764f44159/v2.6/getting-started/kubernetes/installation/hosted/calico.yaml#L25)
    and [volume](https://github.com/projectcalico/calico/blob/1372b56e3bfebe2b9c9cbf8105d6a14764f44159/v2.6/getting-started/kubernetes/installation/hosted/calico.yaml#L219)

  - kube-router [CNI config](https://github.com/cloudnativelabs/kube-router/blob/c2f893f64fd60cf6d2b6d3fee7191266c0fc0fe5/daemonset/generic-kuberouter.yaml#L10)
    and [volume](https://github.com/cloudnativelabs/kube-router/blob/c2f893f64fd60cf6d2b6d3fee7191266c0fc0fe5/daemonset/generic-kuberouter.yaml#L73)

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## Conf vs conflist

- There are two slightly different configuration formats

- Basic configuration format:

  - holds configuration for a single plugin
  - typically has a `.conf` name suffix
  - has a `type` string field in the top-most structure
  - [examples](https://github.com/containernetworking/cni/blob/master/SPEC.md#example-configurations)

- Configuration list format:

  - can hold configuration for multiple (chained) plugins
  - typically has a `.conflist` name suffix
  - has a `plugins` list field in the top-most structure
  - [examples](https://github.com/containernetworking/cni/blob/master/SPEC.md#network-configuration-lists)

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## How plugins are invoked

- Parameters are given through environment variables, including:

  - CNI_COMMAND: desired operation (ADD, DEL, CHECK, or VERSION)

  - CNI_CONTAINERID: container ID

  - CNI_NETNS: path to network namespace file

  - CNI_IFNAME: what the network interface should be named

- The network configuration must be provided to the plugin on stdin

  (this avoids race conditions that could happen by passing a file path)

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## In practice: kube-router

- We are going to set up a new cluster

- For this new cluster, we will use kube-router

- kube-router will provide the "pod network"

  (connectivity with pods)

- kube-router will also provide internal service connectivity

  (replacing kube-proxy)

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## How kube-router works

- Very simple architecture

- Does not introduce new CNI plugins

  (uses the `bridge` plugin, with `host-local` for IPAM)

- Pod traffic is routed between nodes

  (no tunnel, no new protocol)

- Internal service connectivity is implemented with IPVS

- Can provide pod network and/or internal service connectivity

- kube-router daemon runs on every node

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## What kube-router does

- Connect to the API server

- Obtain the local node's `podCIDR`

- Inject it into the CNI configuration file

  (we'll use `/etc/cni/net.d/10-kuberouter.conflist`)

- Obtain the addresses of all nodes

- Establish a *full mesh* BGP peering with the other nodes

- Exchange routes over BGP

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## What's BGP?

- BGP (Border Gateway Protocol) is the protocol used between internet routers

- It [scales](https://www.cidr-report.org/as2.0/)
  pretty [well](https://www.cidr-report.org/cgi-bin/plota?file=%2fvar%2fdata%2fbgp%2fas2.0%2fbgp-active%2etxt&descr=Active%20BGP%20entries%20%28FIB%29&ylabel=Active%20BGP%20entries%20%28FIB%29&with=step)
  (it is used to announce the 700k CIDR prefixes of the internet)

- It is spoken by many hardware routers from many vendors

- It also has many software implementations (Quagga, Bird, FRR...)

- Experienced network folks generally know it (and appreciate it)

- It also used by Calico (another popular network system for Kubernetes)

- Using BGP allows us to interconnect our "pod network" with other systems

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## The plan

- We'll work in a new cluster (named `kuberouter`)

- We will run a simple control plane (like before)

- ... But this time, the controller manager will allocate `podCIDR` subnets

  (so that we don't have to manually assign subnets to individual nodes)

- We will create a DaemonSet for kube-router

- We will join nodes to the cluster

- The DaemonSet will automatically start a kube-router pod on each node

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Logging into the new cluster

.lab[

- Log into node `kuberouter1`

- Clone the workshop repository:
  ```bash
  git clone https://
  ```

- Move to this directory:
  ```bash
  cd container.training/compose/kube-router-k8s-control-plane
  ```

]

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## Checking the CNI configuration

- By default, kubelet gets the CNI configuration from `/etc/cni/net.d`

.lab[

- Check the content of `/etc/cni/net.d`

]

(On most machines, at this point, `/etc/cni/net.d` doesn't even exist).)

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Our control plane

- We will use a Compose file to start the control plane

- It is similar to the one we used with the `kubenet` cluster

- The API server is started with `--allow-privileged`

  (because we will start kube-router in privileged pods)

- The controller manager is started with extra flags too:

  `--allocate-node-cidrs` and `--cluster-cidr`

- We need to edit the Compose file to set the Cluster CIDR

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Starting the control plane

- Our cluster CIDR will be `10.C.0.0/16`

  (where `C` is our cluster number)

.lab[

- Edit the Compose file to set the Cluster CIDR:
  ```bash
  vim docker-compose.yaml
  ```

- Start the control plane:
  ```bash
  docker-compose up
  ```

]

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## The kube-router DaemonSet

- In the same directory, there is a `kuberouter.yaml` file

- It contains the definition for a DaemonSet and a ConfigMap

- Before we load it, we also need to edit it

- We need to indicate the address of the API server

  (because kube-router needs to connect to it to retrieve node information)

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Creating the DaemonSet

- The address of the API server will be `http://A.B.C.D:8080`

  (where `A.B.C.D` is the public address of `kuberouter1`, running the control plane)

.lab[

- Edit the YAML file to set the API server address:
  ```bash
  vim kuberouter.yaml
  ```

- Create the DaemonSet:
  ```bash
  kubectl create -f kuberouter.yaml
  ```

]

Note: the DaemonSet won't create any pods (yet) since there are no nodes (yet).

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Generating the kubeconfig for kubelet

- This is similar to what we did for the `kubenet` cluster

.lab[

- Generate the kubeconfig file (replacing `X.X.X.X` with the address of `kuberouter1`):
  ```bash
    kubectl config set-cluster cni --server http://`X.X.X.X`:8080
    kubectl config set-context cni --cluster cni
    kubectl config use-context cni
    cp ~/.kube/config ~/kubeconfig
  ```

]

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Distributing kubeconfig

- We need to copy that kubeconfig file to the other nodes

.lab[

- Copy `kubeconfig` to the other nodes:
  ```bash
    for N in 2 3; do
    	scp ~/kubeconfig kuberouter$N:
    done
  ```

]

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Starting kubelet

- We don't need the `--pod-cidr` option anymore

  (the controller manager will allocate these automatically)

- We need to pass `--network-plugin=cni`

.lab[

- Join the first node:
   ```bash
   sudo kubelet --kubeconfig ~/kubeconfig --network-plugin=cni
   ```

- Open more terminals and join the other nodes:
  ```bash
  ssh kuberouter2 sudo kubelet --kubeconfig ~/kubeconfig --network-plugin=cni
  ssh kuberouter3 sudo kubelet --kubeconfig ~/kubeconfig --network-plugin=cni
  ```

]

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## Checking the CNI configuration

- At this point, kuberouter should have installed its CNI configuration

  (in `/etc/cni/net.d`)

.lab[

- Check the content of `/etc/cni/net.d`

]

- There should be a file created by kuberouter

- The file should contain the node's podCIDR

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Setting up a test

- Let's create a Deployment and expose it with a Service

.lab[

- Create a Deployment running a web server:
  ```bash
  kubectl create deployment blue --image=jpetazzo/color
  ```

- Scale it so that it spans multiple nodes:
  ```bash
  kubectl scale deployment blue --replicas=5
  ```

- Expose it with a Service:
  ```bash
  kubectl expose deployment blue --port=8888
  ```

]

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

## Checking that everything works

.lab[

- Get the ClusterIP address for the service:
  ```bash
  kubectl get svc web
  ```

- Send a few requests there:
  ```bash
  curl `X.X.X.X`:8888
  ```

]

Note that if you send multiple requests, they are load-balanced in a round robin manner.

This shows that we are using IPVS (vs. iptables, which picked random endpoints).

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## Troubleshooting

- What if we need to check that everything is working properly?

.lab[

- Check the IP addresses of our pods:
  ```bash
  kubectl get pods -o wide
  ```

- Check our routing table:
  ```bash
  route -n
  ip route
  ```

]

We should see the local pod CIDR connected to `kube-bridge`, and the other nodes' pod CIDRs having individual routes, with each node being the gateway.

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## More troubleshooting

- We can also look at the output of the kube-router pods

  (with `kubectl logs`)

- kube-router also comes with a special shell that gives lots of useful info

  (we can access it with `kubectl exec`)

- But with the current setup of the cluster, these options may not work!

- Why?

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## Trying `kubectl logs` / `kubectl exec`

.lab[

- Try to show the logs of a kube-router pod:
  ```bash
  kubectl -n kube-system logs ds/kube-router
  ```

- Or try to exec into one of the kube-router pods:
  ```bash
  kubectl -n kube-system exec kube-router-xxxxx bash
  ```

]

These commands will give an error message that includes:
```
dial tcp: lookup kuberouterX on 127.0.0.11:53: no such host
```

What does that mean?

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## Internal name resolution

- To execute these commands, the API server needs to connect to kubelet

- By default, it creates a connection using the kubelet's name

  (e.g. `http://kuberouter1:...`)

- This requires our nodes names to be in DNS

- We can change that by setting a flag on the API server:

  `--kubelet-preferred-address-types=InternalIP`

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## Another way to check the logs

- We can also ask the logs directly to the container engine

- First, get the container ID, with `docker ps` or like this:
  ```bash
  CID=$(docker ps -q \
        --filter label=io.kubernetes.pod.namespace=kube-system \
        --filter label=io.kubernetes.container.name=kube-router)
  ```

- Then view the logs:
  ```bash
  docker logs $CID
  ```

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: extra-details

## Other ways to distribute routing tables

- We don't need kube-router and BGP to distribute routes

- The list of nodes (and associated `podCIDR` subnets) is available through the API

- This shell snippet generates the commands to add all required routes on a node:

```bash
NODES=$(kubectl get nodes -o name | cut -d/ -f2)
for DESTNODE in $NODES; do
  if [ "$DESTNODE" != "$HOSTNAME" ]; then
    echo $(kubectl get node $DESTNODE -o go-template="
      route add -net {{.spec.podCIDR}} gw {{(index .status.addresses 0).address}}")
  fi
done
```

- This could be useful for embedded platforms with very limited resources

  (or lab environments for learning purposes)

???

:EN:- Configuring CNI plugins
:FR:- Configurer des plugins CNI

.debug[[k8s/cni.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-cni-internals
class: title

 CNI internals

.nav[
[Previous part](#toc-the-container-network-interface)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-interconnecting-clusters)
]

.debug[(automatically generated title slide)]

---
# CNI internals

- Kubelet looks for a CNI configuration file

  (by default, in `/etc/cni/net.d`)

- Note: if we have multiple files, the first one will be used

  (in lexicographic order)

- If no configuration can be found, kubelet holds off on creating containers

  (except if they are using `hostNetwork`)

- Let's see how exactly plugins are invoked!

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## General principle

- A plugin is an executable program

- It is invoked with by kubelet to set up / tear down networking for a container

- It doesn't take any command-line argument

- However, it uses environment variables to know what to do, which container, etc.

- It reads JSON on stdin, and writes back JSON on stdout

- There will generally be multiple plugins invoked in a row

  (at least IPAM + network setup; possibly more)

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## Environment variables

- `CNI_COMMAND`: `ADD`, `DEL`, `CHECK`, or `VERSION`

- `CNI_CONTAINERID`: opaque identifier

  (container ID of the "sandbox", i.e. the container running the `pause` image)

- `CNI_NETNS`: path to network namespace pseudo-file

  (e.g. `/var/run/netns/cni-0376f625-29b5-7a21-6c45-6a973b3224e5`)

- `CNI_IFNAME`: interface name, usually `eth0`

- `CNI_PATH`: path(s) with plugin executables (e.g. `/opt/cni/bin`)

- `CNI_ARGS`: "extra arguments" (see next slide)

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## `CNI_ARGS`

- Extra key/value pair arguments passed by "the user"

- "The user", here, is "kubelet" (or in an abstract way, "Kubernetes")

- This is used to pass the pod name and namespace to the CNI plugin

- Example:
  ```
  IgnoreUnknown=1
  K8S_POD_NAMESPACE=default
  K8S_POD_NAME=web-96d5df5c8-jcn72
  K8S_POD_INFRA_CONTAINER_ID=016493dbff152641d334d9828dab6136c1ff...
  ```

Note that technically, it's a `;`-separated list, so it really looks like this:
```
CNI_ARGS=IgnoreUnknown=1;K8S_POD_NAMESPACE=default;K8S_POD_NAME=web-96d...
```

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## JSON in, JSON out

- The plugin reads its configuration on stdin

- It writes back results in JSON

  (e.g. allocated address, routes, DNS...)

⚠️ "Plugin configuration" is not always the same as "CNI configuration"!

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## Conf vs Conflist

- The CNI configuration can be a single plugin configuration

  - it will then contain a `type` field in the top-most structure

  - it will be passed "as-is"

- It can also be a "conflist", containing a chain of plugins

  (it will then contain a `plugins` field in the top-most structure)

- Plugins are then invoked in order (reverse order for `DEL` action)

- In that case, the input of the plugin is not the whole configuration

  (see details on next slide)

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## List of plugins

- When invoking a plugin in a list, the JSON input will be:

  - the configuration of the plugin

  - augmented with `name` (matching the conf list `name`)

  - augmented with `prevResult` (which will be the output of the previous plugin)

- Conceptually, a plugin (generally the first one) will do the "main setup"

- Other plugins can do tuning / refinement (firewalling, traffic shaping...)

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## Analyzing plugins

- Let's see what goes in and out of our CNI plugins!

- We will create a fake plugin that:

  - saves its environment and input

  - executes the real plugin with the saved input

  - saves the plugin output

  - passes the saved output

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## Our fake plugin

```bash
#!/bin/sh
PLUGIN=$(basename $0)
cat > /tmp/cni.$$.$PLUGIN.in
env | sort > /tmp/cni.$$.$PLUGIN.env
echo "PPID=$PPID, $(readlink /proc/$PPID/exe)" > /tmp/cni.$$.$PLUGIN.parent
$0.real < /tmp/cni.$$.$PLUGIN.in > /tmp/cni.$$.$PLUGIN.out
EXITSTATUS=$?
cat /tmp/cni.$$.$PLUGIN.out
exit $EXITSTATUS
```

Save this script as `/opt/cni/bin/debug` and make it executable.

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## Substituting the fake plugin

- For each plugin that we want to instrument:

  - rename the plugin from e.g. `ptp` to `ptp.real`

  - symlink `ptp` to our `debug` plugin

- There is no need to change the CNI configuration or restart kubelet

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

## Create some pods and looks at the results

- Create a pod

- For each instrumented plugin, there will be files in `/tmp`:

  `cni.PID.pluginname.in` (JSON input)

  `cni.PID.pluginname.env` (environment variables)

  `cni.PID.pluginname.parent` (parent process information)

  `cni.PID.pluginname.out` (JSON output)

❓️ What is calling our plugins?

???

:EN:- Deep dive into CNI internals
:FR:- La Container Network Interface (CNI) en détails

.debug[[k8s/cni-internals.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cni-internals.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-interconnecting-clusters
class: title

 Interconnecting clusters

.nav[
[Previous part](#toc-cni-internals)
|
[Back to table of contents](#toc-part-7)
|
[Next part](#toc-api-server-availability)
]

.debug[(automatically generated title slide)]

---
# Interconnecting clusters

- We assigned different Cluster CIDRs to each cluster

- This allows us to connect our clusters together

- We will leverage kube-router BGP abilities for that

- We will *peer* each kube-router instance with a *route reflector*

- As a result, we will be able to ping each other's pods

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

## Disclaimers

- There are many methods to interconnect clusters

- Depending on your network implementation, you will use different methods

- The method shown here only works for nodes with direct layer 2 connection

- We will often need to use tunnels or other network techniques

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

## The plan

- Someone will start the *route reflector*

  (typically, that will be the person presenting these slides!)

- We will update our kube-router configuration

- We will add a *peering* with the route reflector

  (instructing kube-router to connect to it and exchange route information)

- We should see the routes to other clusters on our nodes

  (in the output of e.g. `route -n` or `ip route show`)

- We should be able to ping pods of other nodes

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

## Starting the route reflector

- Only do this slide if you are doing this on your own

- There is a Compose file in the `compose/frr-route-reflector` directory

- Before continuing, make sure that you have the IP address of the route reflector

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

## Configuring kube-router

- This can be done in two ways:

  - with command-line flags to the `kube-router` process

  - with annotations to Node objects

- We will use the command-line flags

  (because it will automatically propagate to all nodes)

.footnote[Note: with Calico, this is achieved by creating a BGPPeer CRD.]

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

## Updating kube-router configuration

- We need to pass two command-line flags to the kube-router process

.lab[

- Edit the `kuberouter.yaml` file

- Add the following flags to the kube-router arguments:
  ```
  - "--peer-router-ips=`X.X.X.X`"
  - "--peer-router-asns=64512"
  ```
  (Replace `X.X.X.X` with the route reflector address)

- Update the DaemonSet definition:
  ```bash
  kubectl apply -f kuberouter.yaml
  ```

]

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

## Restarting kube-router

- The DaemonSet will not update the pods automatically

  (it is using the default `updateStrategy`, which is `OnDelete`)

- We will therefore delete the pods

  (they will be recreated with the updated definition)

.lab[

- Delete all the kube-router pods:
  ```bash
  kubectl delete pods -n kube-system -l k8s-app=kube-router
  ```

]

Note: the other `updateStrategy` for a DaemonSet is RollingUpdate.
<br/>
For critical services, we might want to precisely control the update process.

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

## Checking peering status

- We can see informative messages in the output of kube-router:
  ```
  time="2019-04-07T15:53:56Z" level=info msg="Peer Up"
  Key=X.X.X.X State=BGP_FSM_OPENCONFIRM Topic=Peer
  ```

- We should see the routes of the other clusters show up

- For debugging purposes, the reflector also exports a route to 1.0.0.2/32

- That route will show up like this:
  ```
  1.0.0.2     172.31.X.Y    255.255.255.255 UGH   0      0        0 eth0
  ```

- We should be able to ping the pods of other clusters!

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

## If we wanted to do more ...

- kube-router can also export ClusterIP addresses

  (by adding the flag `--advertise-cluster-ip`)

- They are exported individually (as /32)

- This would allow us to easily access other clusters' services

  (without having to resolve the individual addresses of pods)

- Even better if it's combined with DNS integration

  (to facilitate name → ClusterIP resolution)

???

:EN:- Interconnecting clusters
:FR:- Interconnexion de clusters

.debug[[k8s/interco.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/interco.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-api-server-availability
class: title

 API server availability

.nav[
[Previous part](#toc-interconnecting-clusters)
|
[Back to table of contents](#toc-part-8)
|
[Next part](#toc-setting-up-kubernetes)
]

.debug[(automatically generated title slide)]

---
# API server availability

- When we set up a node, we need the address of the API server:

  - for kubelet

  - for kube-proxy

  - sometimes for the pod network system (like kube-router)

- How do we ensure the availability of that endpoint?

  (what if the node running the API server goes down?)

.debug[[k8s/apilb.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/apilb.md)]
---

## Option 1: external load balancer

- Set up an external load balancer

- Point kubelet (and other components) to that load balancer

- Put the node(s) running the API server behind that load balancer

- Update the load balancer if/when an API server node needs to be replaced

- On cloud infrastructures, some mechanisms provide automation for this

  (e.g. on AWS, an Elastic Load Balancer + Auto Scaling Group)

- [Example in Kubernetes The Hard Way](https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/08-bootstrapping-kubernetes-controllers.md#the-kubernetes-frontend-load-balancer)

.debug[[k8s/apilb.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/apilb.md)]
---

## Option 2: local load balancer

- Set up a load balancer (like NGINX, HAProxy...) on *each* node

- Configure that load balancer to send traffic to the API server node(s)

- Point kubelet (and other components) to `localhost`

- Update the load balancer configuration when API server nodes are updated

.debug[[k8s/apilb.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/apilb.md)]
---

## Updating the local load balancer config

- Distribute the updated configuration (push)

- Or regularly check for updates (pull)

- The latter requires an external, highly available store
 
  (it could be an object store, an HTTP server, or even DNS...)

- Updates can be facilitated by a DaemonSet

  (but remember that it can't be used when installing a new node!)

.debug[[k8s/apilb.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/apilb.md)]
---

## Option 3: DNS records

- Put all the API server nodes behind a round-robin DNS

- Point kubelet (and other components) to that name

- Update the records when needed

- Note: this option is not officially supported

  (but since kubelet supports reconnection anyway, it *should* work)

.debug[[k8s/apilb.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/apilb.md)]
---

## Option 4: ....................

- Many managed clusters expose a high-availability API endpoint

  (and you don't have to worry about it)

- You can also use HA mechanisms that you're familiar with

  (e.g. virtual IPs)

- Tunnels are also fine

  (e.g. [k3s](https://k3s.io/) uses a tunnel to allow each node to contact the API server)

???

:EN:- Ensuring API server availability
:FR:- Assurer la disponibilité du serveur API

.debug[[k8s/apilb.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/apilb.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-1.jpg)]

---

name: toc-setting-up-kubernetes
class: title

 Setting up Kubernetes

.nav[
[Previous part](#toc-api-server-availability)
|
[Back to table of contents](#toc-part-8)
|
[Next part](#toc-running-a-local-development-cluster)
]

.debug[(automatically generated title slide)]

---
# Setting up Kubernetes

- Kubernetes is made of many components that require careful configuration

- Secure operation typically requires TLS certificates and a local CA

  (certificate authority)

- Setting up everything manually is possible, but rarely done

  (except for learning purposes)

- Let's do a quick overview of available options!

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## Local development

- Are you writing code that will eventually run on Kubernetes?

- Then it's a good idea to have a development cluster!

- Instead of shipping containers images, we can test them on Kubernetes

- Extremely useful when authoring or testing Kubernetes-specific objects

  (ConfigMaps, Secrets, StatefulSets, Jobs, RBAC, etc.)

- Extremely convenient to quickly test/check what a particular thing looks like

  (e.g. what are the fields a Deployment spec?)

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## One-node clusters

- It's perfectly fine to work with a cluster that has only one node

- It simplifies a lot of things:

  - pod networking doesn't even need CNI plugins, overlay networks, etc.

  - these clusters can be fully contained (no pun intended) in an easy-to-ship VM or container image

  - some of the security aspects may be simplified (different threat model)

  - images can be built directly on the node (we don't need to ship them with a registry)

- Examples: Docker Desktop, k3d, KinD, MicroK8s, Minikube

  (some of these also support clusters with multiple nodes)

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## Managed clusters ("Turnkey Solutions")

- Many cloud providers and hosting providers offer "managed Kubernetes"

- The deployment and maintenance of the *control plane* is entirely managed by the provider

  (ideally, clusters can be spun up automatically through an API, CLI, or web interface)

- Given the complexity of Kubernetes, this approach is *strongly recommended*

  (at least for your first production clusters)

- After working for a while with Kubernetes, you will be better equipped to decide:

  - whether to operate it yourself or use a managed offering

  - which offering or which distribution works best for you and your needs

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## Node management

- Most "Turnkey Solutions" offer fully managed control planes

  (including control plane upgrades, sometimes done automatically)

- However, with most providers, we still need to take care of *nodes*

  (provisioning, upgrading, scaling the nodes)

- Example with Amazon EKS ["managed node groups"](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html):

  *...when bugs or issues are reported [...] you're responsible for deploying these patched AMI versions to your managed node groups.*

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## Managed clusters differences

- Most providers let you pick which Kubernetes version you want

  - some providers offer up-to-date versions

  - others lag significantly (sometimes by 2 or 3 minor versions)

- Some providers offer multiple networking or storage options

- Others will only support one, tied to their infrastructure

  (changing that is in theory possible, but might be complex or unsupported)

- Some providers let you configure or customize the control plane

  (generally through Kubernetes "feature gates")

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## Choosing a provider

- Pricing models differ from one provider to another

  - nodes are generally charged at their usual price

  - control plane may be free or incur a small nominal fee

- Beyond pricing, there are *huge* differences in features between providers

- The "major" providers are not always the best ones!

- See [this page](https://kubernetes.io/docs/setup/production-environment/turnkey-solutions/) for a list of available providers

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## Kubernetes distributions and installers

- If you want to run Kubernetes yourselves, there are many options

  (free, commercial, proprietary, open source ...)

- Some of them are installers, while some are complete platforms

- Some of them leverage other well-known deployment tools

  (like Puppet, Terraform ...)

- There are too many options to list them all

  (check [this page](https://kubernetes.io/partners/#conformance) for an overview!)

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## kubeadm

- kubeadm is a tool part of Kubernetes to facilitate cluster setup

- Many other installers and distributions use it (but not all of them)

- It can also be used by itself

- Excellent starting point to install Kubernetes on your own machines

  (virtual, physical, it doesn't matter)

- It even supports highly available control planes, or "multi-master"

  (this is more complex, though, because it introduces the need for an API load balancer)

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## Manual setup

- The resources below are mainly for educational purposes!

- [Kubernetes The Hard Way](https://github.com/kelseyhightower/kubernetes-the-hard-way) by Kelsey Hightower

  *step by step guide to install Kubernetes on GCP, with certificates, HA...*

- [Deep Dive into Kubernetes Internals for Builders and Operators](https://www.youtube.com/watch?v=3KtEAa7_duA)

  *conference talk setting up a simplified Kubernetes cluster - no security or HA*

- 🇫🇷[Démystifions les composants internes de Kubernetes](https://www.youtube.com/watch?v=OCMNA0dSAzc)

  *improved version of the previous one, with certs and recent k8s versions*

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## About our training clusters

- How did we set up these Kubernetes clusters that we're using?

--

- We used `kubeadm` on freshly installed VM instances running Ubuntu LTS

    1. Install Docker

    2. Install Kubernetes packages

    3. Run `kubeadm init` on the first node (it deploys the control plane on that node)

    4. Set up  Weave (the overlay network) with a single `kubectl apply` command

    5. Run `kubeadm join` on the other nodes (with the token produced by `kubeadm init`)

    6. Copy the configuration file generated by `kubeadm init`

- Check the [prepare VMs README](https:///blob/master/prepare-vms/README.md) for more details

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

## `kubeadm` "drawbacks"

- Doesn't set up Docker or any other container engine

  (this is by design, to give us choice)

- Doesn't set up the overlay network

  (this is also by design, for the same reasons)

- HA control plane requires [some extra steps](https://kubernetes.io/docs/setup/independent/high-availability/)

- Note that HA control plane also requires setting up a specific API load balancer

  (which is beyond the scope of kubeadm)

???

:EN:- Various ways to install Kubernetes
:FR:- Survol des techniques d'installation de Kubernetes

.debug[[k8s/setup-overview.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-overview.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-2.jpg)]

---

name: toc-running-a-local-development-cluster
class: title

 Running a local development cluster

.nav[
[Previous part](#toc-setting-up-kubernetes)
|
[Back to table of contents](#toc-part-8)
|
[Next part](#toc-deploying-a-managed-cluster)
]

.debug[(automatically generated title slide)]

---
# Running a local development cluster

- Let's review some options to run Kubernetes locally

- There is no "best option", it depends what you value:

  - ability to run on all platforms (Linux, Mac, Windows, other?)

  - ability to run clusters with multiple nodes

  - ability to run multiple clusters side by side

  - ability to run recent (or even, unreleased) versions of Kubernetes

  - availability of plugins

  - etc.

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

### CoLiMa

- Container runtimes for LiMa

  (LiMa = Linux on macOS)

- For macOS only (Intel and ARM architectures)

- CLI-driven (no GUI like Docker/Rancher Desktop)

- Supports containerd, Docker, Kubernetes

- Installable with brew, nix, or ports

- More info: https://github.com/abiosoft/colima

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## Docker Desktop

- Available on Linux, Mac, and Windows

- Free for personal use and small businesses

  (less than 250 employees and less than $10 millions in annual revenue)

- Gives you one cluster with one node

- Streamlined installation and user experience

- Great integration with various network stacks and e.g. corporate VPNs

- Ideal for Docker users who need good integration between both platforms

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## [k3d](https://k3d.io/)

- Based on [K3s](https://k3s.io/) by Rancher Labs

- Requires Docker

- Runs Kubernetes nodes in Docker containers

- Can deploy multiple clusters, with multiple nodes

- Runs the control plane on Kubernetes nodes

- Control plane can also run on multiple nodes

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## k3d in action

- Install `k3d` (e.g. get the binary from https://github.com/rancher/k3d/releases)

- Create a simple cluster:
  ```bash
  k3d cluster create petitcluster
  ```

- Create a more complex cluster with a custom version:
  ```bash
  k3d cluster create groscluster \
        --image rancher/k3s:v1.18.9-k3s1 --servers 3 --agents 5
  ```

  (3 nodes for the control plane + 5 worker nodes)
 
- Clusters are automatically added to `.kube/config` file

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## [KinD](https://kind.sigs.k8s.io/)

- Kubernetes-in-Docker

- Requires Docker (obviously!)

- Should also work with Podman and Rootless Docker

- Deploying a single node cluster using the latest version is simple:
  ```bash
  kind create cluster
  ```

- More advanced scenarios require writing a short [config file](https://kind.sigs.k8s.io/docs/user/quick-start#configuring-your-kind-cluster)

  (to define multiple nodes, multiple control plane nodes, set Kubernetes versions ...)
 
- Can deploy multiple clusters

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## [MicroK8s](https://microk8s.io/)

- Available on Linux, and since recently, on Mac and Windows as well

- The Linux version is installed through Snap

  (which is pre-installed on all recent versions of Ubuntu)

- Also supports clustering (as in, multiple machines running MicroK8s)

- DNS is not enabled by default; enable it with `microk8s enable dns`

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## [Minikube](https://minikube.sigs.k8s.io/docs/)

- The "legacy" option!

  (note: this is not a bad thing, it means that it's very stable, has lots of plugins, etc.)

- Supports many [drivers](https://minikube.sigs.k8s.io/docs/drivers/)

  (HyperKit, Hyper-V, KVM, VirtualBox, but also Docker and many others)

- Can deploy a single cluster; recent versions can deploy multiple nodes

- Great option if you want a "Kubernetes first" experience

  (i.e. if you don't already have Docker and/or don't want/need it)

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## [Orbstack](https://orbstack.dev/)

- Mac only

- Runs Docker containers, Kubernetes, and Linux virtual machines

- Emphasis on speed and energy usage (battery life)

- Great support for `ClusterIP` and `LoadBalancer` services

- Free for personal use; paid product otherwise

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## [Podman Desktop](https://podman-desktop.io/)

- Available on Linux, Mac, and Windows

- Free and open-source

- Doesn't support Kubernetes directly, but [supports KinD](https://podman-desktop.io/docs/kind)

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## [Rancher Desktop](https://rancherdesktop.io/)

- Available on Linux, Mac, and Windows

- Free and open-source

- Runs a single cluster with a single node

- Lets you pick the Kubernetes version that you want to use

  (and change it any time you like)

- Emphasis on ease of use (like Docker Desktop)

- Based on k3s and other proven components

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

## VM with custom install

- Choose your own adventure!

- Pick any Linux distribution!

- Build your cluster from scratch or use a Kubernetes installer!

- Discover exotic CNI plugins and container runtimes!

- The only limit is yourself, and the time you are willing to sink in!

???

:EN:- Kubernetes options for local development
:FR:- Installation de Kubernetes pour travailler en local

.debug[[k8s/setup-devel.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-devel.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/two-containers-on-a-truck.jpg)]

---

name: toc-deploying-a-managed-cluster
class: title

 Deploying a managed cluster

.nav[
[Previous part](#toc-running-a-local-development-cluster)
|
[Back to table of contents](#toc-part-8)
|
[Next part](#toc-kubernetes-distributions-and-installers)
]

.debug[(automatically generated title slide)]

---
# Deploying a managed cluster

*"The easiest way to install Kubernetes is to get someone
else to do it for you."
<br/>
([Jérôme Petazzoni](https://twitter.com/jpetazzo))*

- Let's see a few options to install managed clusters!

- This is not an exhaustive list

  (the goal is to show the actual steps to get started)

- The list is sorted alphabetically

- All the options mentioned here require an account
with a cloud provider

- ... And a credit card

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## AKS (initial setup)

- Install the Azure CLI

- Login:
  ```bash
  az login
  ```

- Select a [region](https://azure.microsoft.com/en-us/global-infrastructure/services/?products=kubernetes-service&regions=all
)

- Create a "resource group":
  ```bash
  az group create --name my-aks-group --location westeurope
  ```

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## AKS (create cluster)

- Create the cluster:
  ```bash
  az aks create --resource-group my-aks-group --name my-aks-cluster
  ```

- Wait about 5-10 minutes

- Add credentials to `kubeconfig`:
  ```bash
  az aks get-credentials --resource-group my-aks-group --name my-aks-cluster
  ```

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## AKS (cleanup)

- Delete the cluster:
  ```bash
  az aks delete --resource-group my-aks-group --name my-aks-cluster
  ```

- Delete the resource group:
  ```bash
  az group delete --resource-group my-aks-group
  ```

- Note: delete actions can take a while too!

  (5-10 minutes as well)

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## AKS (notes)

- The cluster has useful components pre-installed, such as the metrics server

- There is also a product called [AKS Engine](https://github.com/Azure/aks-engine):

  - leverages ARM (Azure Resource Manager) templates to deploy Kubernetes

  - it's "the library used by AKS"

  - fully customizable

  - think of it as "half-managed" Kubernetes option

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Amazon EKS (the old way)

- [Read the doc](https://docs.aws.amazon.com/eks/latest/userguide/getting-started-console.html)

- Create service roles, VPCs, and a bunch of other oddities

- Try to figure out why it doesn't work

- Start over, following an [official AWS blog post](https://aws.amazon.com/blogs/aws/amazon-eks-now-generally-available/)

- Try to find the missing Cloud Formation template

--

.footnote[(╯°□°)╯︵ ┻━┻]

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Amazon EKS (the new way)

- Install `eksctl`

- Set the usual environment variables

  ([AWS_DEFAULT_REGION](https://docs.aws.amazon.com/general/latest/gr/rande.html#eks_region), AWS_ACCESS_KEY, AWS_SECRET_ACCESS_KEY)

- Create the cluster:
  ```bash
  eksctl create cluster
  ```

- Cluster can take a long time to be ready (15-20 minutes is typical)

- Add cluster add-ons

  (by default, it doesn't come with metrics-server, logging, etc.)

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Amazon EKS (cleanup)

- Delete the cluster:
  ```bash
  eksctl delete cluster <clustername>
  ```

- If you need to find the name of the cluster:
  ```bash
  eksctl get clusters
  ```

.footnote[Note: the AWS documentation has been updated and now includes [eksctl instructions](https://docs.aws.amazon.com/eks/latest/userguide/getting-started-eksctl.html).]

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Amazon EKS (notes)

- Convenient if you *have to* use AWS

- Needs extra steps to be truly production-ready

- [Versions tend to be outdated](https://twitter.com/jpetazzo/status/1252948707680686081)

- The only officially supported pod network is the [Amazon VPC CNI plugin](https://docs.aws.amazon.com/eks/latest/userguide/pod-networking.html)

  - integrates tightly with security groups and VPC networking

  - not suitable for high density clusters (with many small pods on big nodes)

  - other plugins [should still work](https://docs.aws.amazon.com/eks/latest/userguide/alternate-cni-plugins.html) but will require extra work

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Digital Ocean (initial setup)

- Install `doctl`

- Generate API token (in web console)

- Set up the CLI authentication:
  ```bash
  doctl auth init
  ```
  (It will ask you for the API token)

- Check the list of regions and pick one:
  ```bash
  doctl compute region list
  ```
  (If you don't specify the region later, it will use `nyc1`)

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Digital Ocean (create cluster)

- Create the cluster:
  ```bash
  doctl kubernetes cluster create my-do-cluster [--region xxx1]
  ```

- Wait 5 minutes

- Update `kubeconfig`:
  ```bash
  kubectl config use-context do-xxx1-my-do-cluster
  ```

- The cluster comes with some components (like Cilium) but no metrics server

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Digital Ocean (cleanup)

- List clusters (if you forgot its name):
  ```bash
  doctl kubernetes cluster list
  ```

- Delete the cluster:
  ```bash
  doctl kubernetes cluster delete my-do-cluster
  ```

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## GKE (initial setup)

- Install `gcloud`

- Login:
  ```bash
  gcloud auth init
  ```

- Create a "project":
  ```bash
  gcloud projects create my-gke-project
  gcloud config set project my-gke-project
  ```

- Pick a [region](https://cloud.google.com/compute/docs/regions-zones/)

  (example: `europe-west1`, `us-west1`, ...)

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## GKE (create cluster)

- Create the cluster:
  ```bash
  gcloud container clusters create my-gke-cluster --region us-west1 --num-nodes=2
  ```

  (without `--num-nodes` you might exhaust your IP address quota!)

- The first time you try to create a cluster in a given project, you get an error

  - you need to enable the Kubernetes Engine API
  - the error message gives you a link
  - follow the link and enable the API (and billing)
    <br/>(it's just a couple of clicks and it's instantaneous)

- Clutser should be ready in a couple of minutes

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## GKE (cleanup)

- List clusters (if you forgot its name):
  ```bash
  gcloud container clusters list
  ```

- Delete the cluster:
  ```bash
  gcloud container clusters delete my-gke-cluster --region us-west1
  ```

- Delete the project (optional):
  ```bash
  gcloud projects delete my-gke-project
  ```

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## GKE (notes)

- Well-rounded product overall

  (it used to be one of the best managed Kubernetes offerings available;
  now that many other providers entered the game, that title is debatable)

- The cluster comes with many add-ons

- Versions lag a bit:

  - latest minor version (e.g. 1.18) tends to be unsupported
 
  - previous minor version (e.g. 1.17) supported through alpha channel

  - previous versions (e.g. 1.14-1.16) supported

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Scaleway (initial setup)

- After creating your account, make sure you set a password or get an API key

  (by default, it uses email "magic links" to sign in)

- Install `scw`

  (you need [CLI v2](https://github.com/scaleway/scaleway-cli/tree/v2#Installation), which in beta as of May 2020)

- Generate the CLI configuration with `scw init`

  (it will prompt for your API key, or email + password)

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Scaleway (create cluster)

- Create the cluster:
  ```bash
    k8s cluster create name=my-kapsule-cluster version=1.18.3 cni=cilium \
        default-pool-config.node-type=DEV1-M default-pool-config.size=3 
  ```

- After less than 5 minutes, cluster state will be `ready`

  (check cluster status with e.g. `scw k8s cluster list` on a wide terminal
)

- Add connection information to your `.kube/config` file:
  ```bash
  scw k8s kubeconfig install `CLUSTERID`
  ```

  (the cluster ID is shown by `scw k8s cluster list`)

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

class: extra-details

## Scaleway (automation)

- If you want to obtain the cluster ID programmatically, this will do it:

  ```bash
  scw k8s cluster list
  # or
  CLUSTERID=$(scw k8s cluster list -o json | \
        jq -r '.[] | select(.name="my-kapsule-cluster") | .id')
  ```

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Scaleway (cleanup)

- Get cluster ID (e.g. with `scw k8s cluster list`)

- Delete the cluster:
  ```bash
  scw cluster delete cluster-id=$CLUSTERID
  ```

- Warning: as of May 2020, load balancers have to be deleted separately!

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## Scaleway (notes)

- The `create` command is a bit more complex than with other providers

  (you must specify the Kubernetes version, CNI plugin, and node type)

- To see available versions and CNI plugins, run `scw k8s version list`

- As of May 2020, Kapsule supports:

  - multiple CNI plugins, including: cilium, calico, weave, flannel

  - Kubernetes versions 1.15 to 1.18

  - multiple container runtimes, including: Docker, containerd, CRI-O

- To see available node types and their price, check their [pricing page](
https://www.scaleway.com/en/pricing/)

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

## More options

- Alibaba Cloud

- [IBM Cloud](https://console.bluemix.net/docs/containers/cs_cli_install.html#cs_cli_install)

- [Linode Kubernetes Engine (LKE)](https://www.linode.com/products/kubernetes/)

- OVHcloud [Managed Kubernetes Service](https://www.ovhcloud.com/en/public-cloud/kubernetes/)

- ...

???

:EN:- Installing a managed cluster
:FR:- Installer un cluster infogéré

.debug[[k8s/setup-managed.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-managed.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/wall-of-containers.jpeg)]

---

name: toc-kubernetes-distributions-and-installers
class: title

 Kubernetes distributions and installers

.nav[
[Previous part](#toc-deploying-a-managed-cluster)
|
[Back to table of contents](#toc-part-8)
|
[Next part](#toc-upgrading-clusters)
]

.debug[(automatically generated title slide)]

---
# Kubernetes distributions and installers

- Sometimes, we need to run Kubernetes ourselves

  (as opposed to "use a managed offering")

- Beware: it takes *a lot of work* to set up and maintain Kubernetes

- It might be necessary if you have specific security or compliance requirements

  (e.g. national security for states that don't have a suitable domestic cloud)

- There are [countless](https://kubernetes.io/docs/setup/pick-right-solution/) distributions available

- We can't review them all

- We're just going to explore a few options

.debug[[k8s/setup-selfhosted.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-selfhosted.md)]
---

## [kops](https://github.com/kubernetes/kops)

- Deploys Kubernetes using cloud infrastructure

  (supports AWS, GCE, Digital Ocean ...)

- Leverages special cloud features when possible

  (e.g. Auto Scaling Groups ...)

.debug[[k8s/setup-selfhosted.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-selfhosted.md)]
---

## kubeadm

- Provisions Kubernetes nodes on top of existing machines

- `kubeadm init` to provision a single-node control plane

- `kubeadm join` to join a node to the cluster

- Supports HA control plane [with some extra steps](https://kubernetes.io/docs/setup/independent/high-availability/) 

.debug[[k8s/setup-selfhosted.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-selfhosted.md)]
---

## [kubespray](https://github.com/kubernetes-incubator/kubespray)

- Based on Ansible

- Works on bare metal and cloud infrastructure

  (good for hybrid deployments)

- The expert says: ultra flexible; slow; complex

.debug[[k8s/setup-selfhosted.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-selfhosted.md)]
---

## RKE (Rancher Kubernetes Engine)

- Opinionated installer with low requirements

- Requires a set of machines with Docker + SSH access

- Supports highly available etcd and control plane

- The expert says: fast; maintenance can be tricky

.debug[[k8s/setup-selfhosted.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-selfhosted.md)]
---

## Terraform + kubeadm

- Sometimes it is necessary to build a custom solution

- Example use case: 

  - deploying Kubernetes on OpenStack

  - ... with highly available control plane

  - ... and Cloud Controller Manager integration

- Solution: Terraform + kubeadm (kubeadm driven by remote-exec)

  - [GitHub repository](https://github.com/enix/terraform-openstack-kubernetes)

  - [Blog post (in French)](https://enix.io/fr/blog/deployer-kubernetes-1-13-sur-openstack-grace-a-terraform/)

.debug[[k8s/setup-selfhosted.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-selfhosted.md)]
---

## And many more ...

- [AKS Engine](https://github.com/Azure/aks-engine)

- Docker Enterprise Edition

- [Lokomotive](https://github.com/kinvolk/lokomotive), leveraging Terraform and [Flatcar Linux](https://www.flatcar-linux.org/)

- Pivotal Container Service (PKS)

- [Tarmak](https://github.com/jetstack/tarmak), leveraging Puppet and Terraform

- Tectonic by CoreOS (now being integrated into Red Hat OpenShift)

- [Typhoon](https://typhoon.psdn.io/), leveraging Terraform

- VMware Tanzu Kubernetes Grid (TKG)

.debug[[k8s/setup-selfhosted.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-selfhosted.md)]
---

## Bottom line

- Each distribution / installer has pros and cons

- Before picking one, we should sort out our priorities:

  - cloud, on-premises, hybrid?

  - integration with existing network/storage architecture or equipment?

  - are we storing very sensitive data, like finance, health, military?

  - how many clusters are we deploying (and maintaining): 2, 10, 50?

  - which team will be responsible for deployment and maintenance?
    <br/>(do they need training?)

  - etc.

???

:EN:- Kubernetes distributions and installers
:FR:- L'offre Kubernetes "on premises"

.debug[[k8s/setup-selfhosted.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/setup-selfhosted.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/catene-de-conteneurs.jpg)]

---

name: toc-upgrading-clusters
class: title

 Upgrading clusters

.nav[
[Previous part](#toc-kubernetes-distributions-and-installers)
|
[Back to table of contents](#toc-part-8)
|
[Next part](#toc-static-pods)
]

.debug[(automatically generated title slide)]

---
# Upgrading clusters

- It's *recommended* to run consistent versions across a cluster

  (mostly to have feature parity and latest security updates)

- It's not *mandatory*

  (otherwise, cluster upgrades would be a nightmare!)

- Components can be upgraded one at a time without problems

<!-- ##VERSION## -->

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Checking what we're running

- It's easy to check the version for the API server

.lab[

- Log into node `oldversion1`

- Check the version of kubectl and of the API server:
  ```bash
  kubectl version
  ```

]

- In a HA setup with multiple API servers, they can have different versions

- Running the command above multiple times can return different values

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Node versions

- It's also easy to check the version of kubelet

.lab[

- Check node versions (includes kubelet, kernel, container engine):
  ```bash
  kubectl get nodes -o wide
  ```

]

- Different nodes can run different kubelet versions

- Different nodes can run different kernel versions

- Different nodes can run different container engines

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Control plane versions

- If the control plane is self-hosted (running in pods), we can check it

.lab[

- Show image versions for all pods in `kube-system` namespace:
  ```bash
    kubectl --namespace=kube-system get pods -o json \
            | jq -r '
              .items[]
              | [.spec.nodeName, .metadata.name]
                + 
                (.spec.containers[].image | split(":"))
              | @tsv
              ' \
            | column -t
  ```

]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## What version are we running anyway?

- When I say, "I'm running Kubernetes 1.28", is that the version of:

  - kubectl

  - API server

  - kubelet

  - controller manager

  - something else?

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Other versions that are important

- etcd

- kube-dns or CoreDNS

- CNI plugin(s)

- Network controller, network policy controller

- Container engine

- Linux kernel

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Important questions

- Should we upgrade the control plane before or after the kubelets?

- Within the control plane, should we upgrade the API server first or last?

- How often should we upgrade?

- How long are versions maintained?

- All the answers are in [the documentation about version skew policy](https://kubernetes.io/docs/setup/release/version-skew-policy/)!

- Let's review the key elements together ...

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Kubernetes uses semantic versioning

- Kubernetes versions look like MAJOR.MINOR.PATCH; e.g. in 1.28.9:

  - MAJOR = 1
  - MINOR = 28
  - PATCH = 9

- It's always possible to mix and match different PATCH releases

  (e.g. 1.28.9 and 1.28.13 are compatible)

- It is recommended to run the latest PATCH release

  (but it's mandatory only when there is a security advisory)

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Version skew

- API server must be more recent than its clients (kubelet and control plane)

- ... Which means it must always be upgraded first

- All components support a difference of one¹ MINOR version

- This allows live upgrades (since we can mix e.g. 1.28 and 1.29)

- It also means that going from 1.28 to 1.30 requires going through 1.29

.footnote[¹Except kubelet, which can be up to two MINOR behind API server,
and kubectl, which can be one MINOR ahead or behind API server.]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Release cycle

- There is a new PATCH relese whenever necessary

  (every few weeks, or "ASAP" when there is a security vulnerability)

- There is a new MINOR release every 3 months (approximately)

- At any given time, three MINOR releases are maintained

- ... Which means that MINOR releases are maintained approximately 9 months

- We should expect to upgrade at least every 3 months (on average)

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## General guidelines

- To update a component, use whatever was used to install it

- If it's a distro package, update that distro package

- If it's a container or pod, update that container or pod

- If you used configuration management, update with that

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Know where your binaries come from

- Sometimes, we need to upgrade *quickly*

  (when a vulnerability is announced and patched)

- If we are using an installer, we should:

  - make sure it's using upstream packages

  - or make sure that whatever packages it uses are current

  - make sure we can tell it to pin specific component versions

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## In practice

- We are going to update a few cluster components

- We will change the kubelet version on one node

- We will change the version of the API server

- We will work with cluster `oldversion` (nodes `oldversion1`, `oldversion2`, `oldversion3`)

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Updating the API server

- This cluster has been deployed with kubeadm

- The control plane runs in *static pods*

- These pods are started automatically by kubelet

  (even when kubelet can't contact the API server)

- They are defined in YAML files in `/etc/kubernetes/manifests`

  (this path is set by a kubelet command-line flag)

- kubelet automatically updates the pods when the files are changed

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Changing the API server version

- We will edit the YAML file to use a different image version

.lab[

- Log into node `oldversion1`

- Check API server version:
  ```bash
  kubectl version
  ```

- Edit the API server pod manifest:
  ```bash
  sudo vim /etc/kubernetes/manifests/kube-apiserver.yaml
  ```

- Look for the `image:` line, and update it to e.g. `v1.30.1`

]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Checking what we've done

- The API server will be briefly unavailable while kubelet restarts it

.lab[

- Check the API server version:
  ```bash
  kubectl version
  ```

]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Was that a good idea?

--

**No!**

--

- Remember the guideline we gave earlier:

  *To update a component, use whatever was used to install it.*

- This control plane was deployed with kubeadm

- We should use kubeadm to upgrade it!

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Updating the whole control plane

- Let's make it right, and use kubeadm to upgrade the entire control plane

  (note: this is possible only because the cluster was installed with kubeadm)

.lab[

- Check what will be upgraded:
  ```bash
  sudo kubeadm upgrade plan
  ```

]

Note 1: kubeadm thinks that our cluster is running 1.24.1.
<br/>It is confused by our manual upgrade of the API server!

Note 2: kubeadm itself is still version 1.22.1..
<br/>It doesn't know how to upgrade do 1.23.X.

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Upgrading kubeadm

- First things first: we need to upgrade kubeadm

- The Kubernetes package repositories are now split by minor versions

  (i.e. there is one repository for 1.28, another for 1.29, etc.)

- This avoids accidentally upgrading from one minor version to another

  (e.g. with unattended upgrades or if packages haven't been held/pinned)

- We'll need to add the new package repository and unpin packages!

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Installing the new packages

- Edit `/etc/apt/sources.list.d/kubernetes.list`

  (or copy it to e.g. `kubernetes-1.29.list` and edit that)

- `apt-get update`

- Now edit (or remove) `/etc/apt/preferences.d/kubernetes`

- `apt-get install kubeadm` should now upgrade `kubeadm` correctly! 🎉

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Reverting our manual API server upgrade

- First, we should revert our `image:` change

  (so that kubeadm executes the right migration steps)

.lab[

- Edit the API server pod manifest:
  ```bash
  sudo vim /etc/kubernetes/manifests/kube-apiserver.yaml
  ```

- Look for the `image:` line, and restore it to the original value

  (e.g. `v1.28.9`)

- Wait for the control plane to come back up

]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Upgrading the cluster with kubeadm

- Now we can let kubeadm do its job!

.lab[

- Check the upgrade plan:
  ```bash
  sudo kubeadm upgrade plan
  ```

- Perform the upgrade:
  ```bash
  sudo kubeadm upgrade apply v1.29.0
  ```

]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Updating kubelet

- These nodes have been installed using the official Kubernetes packages

- We can therefore use `apt` or `apt-get`

.lab[

- Log into node `oldversion2`

- Update package lists and APT pins like we did before

- Then upgrade kubelet

]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Checking what we've done

.lab[

- Log into node `oldversion1`

- Check node versions:
  ```bash
  kubectl get nodes -o wide
  ```

- Create a deployment and scale it to make sure that the node still works

]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Was that a good idea?

--

**Almost!**

--

- Yes, kubelet was installed with distribution packages

- However, kubeadm took care of configuring kubelet

  (when doing `kubeadm join ...`)

- We were supposed to run a special command *before* upgrading kubelet!

- That command should be executed on each node

- It will download the kubelet configuration generated by kubeadm

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Upgrading kubelet the right way

- We need to upgrade kubeadm, upgrade kubelet config, then upgrade kubelet

  (after upgrading the control plane)

.lab[

- Execute the whole upgrade procedure on each node:
  ```bash
    for N in 1 2 3; do
      ssh oldversion$N "
        sudo sed -i s/1.28/1.29/ /etc/apt/sources.list.d/kubernetes.list &&
        sudo rm /etc/apt/preferences.d/kubernetes &&
        sudo apt update &&
        sudo apt install kubeadm -y &&
        sudo kubeadm upgrade node &&
        sudo apt install kubelet -y"
    done
  ```
]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Checking what we've done

- All our nodes should now be updated to version 1.29

.lab[

- Check nodes versions:
  ```bash
  kubectl get nodes -o wide
  ```

]

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## And now, was that a good idea?

--

**Almost!**

--

- The official recommendation is to *drain* a node before performing node maintenance

  (migrate all workloads off the node before upgrading it)

- How do we do that?

- Is it really necessary?

- Let's see!

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Draining a node

- This can be achieved with the `kubectl drain` command, which will:

  - *cordon* the node (prevent new pods from being scheduled there)

  - *evict* all the pods running on the node (delete them gracefully)

  - the evicted pods will automatically be recreated somewhere else

  - evictions might be blocked in some cases (Pod Disruption Budgets, `emptyDir` volumes)

- Once the node is drained, it can safely be upgraded, restarted...

- Once it's ready, it can be put back in commission with `kubectl uncordon`

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Is it necessary?

- When upgrading kubelet from one patch-level version to another:

  - it's *probably fine*

- When upgrading system packages:

  - it's *probably fine*

  - except [when it's not][datadog-systemd-outage]

- When upgrading the kernel:

  - it's *probably fine*

  - ...as long as we can tolerate a restart of the containers on the node

  - ...and that they will be unavailable for a few minutes (during the reboot)

[datadog-systemd-outage]: https://www.datadoghq.com/blog/engineering/2023-03-08-deep-dive-into-platform-level-impact/

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Is it necessary?

- When upgrading kubelet from one minor version to another:

  - it *may or may not be fine*

  - in some cases (e.g. migrating from Docker to containerd) it *will not*

- Here's what [the documentation][node-upgrade-docs] says:

  *Draining nodes before upgrading kubelet ensures that pods are re-admitted and containers are re-created, which may be necessary to resolve some security issues or other important bugs.*

- Do it at your own risk, and if you do, test extensively in staging environments!

[node-upgrade-docs]: https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/#manual-deployments

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

## Database operators to the rescue

- Moving stateful pods (e.g.: database server) can cause downtime

- Database replication can help:

  - if a node contains database servers, we make sure these servers aren't primaries

  - if they are primaries, we execute a *switch over*

- Some database operators (e.g. [CNPG]) will do that switch over automatically

  (when they detect that a node has been *cordoned*)

[CNPG]: https://cloudnative-pg.io/

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

class: extra-details

## Skipping versions

- This example worked because we went from 1.28 to 1.29

- If you are upgrading from e.g. 1.26, you will have to go through 1.27 first

- This means upgrading kubeadm to 1.27.X, then using it to upgrade the cluster

- Then upgrading kubeadm to 1.28.X, etc.

- **Make sure to read the release notes before upgrading!**

???

:EN:- Best practices for cluster upgrades
:EN:- Example: upgrading a kubeadm cluster

:FR:- Bonnes pratiques pour la mise à jour des clusters
:FR:- Exemple : mettre à jour un cluster kubeadm

.debug[[k8s/cluster-upgrade.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-upgrade.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-static-pods
class: title

 Static pods

.nav[
[Previous part](#toc-upgrading-clusters)
|
[Back to table of contents](#toc-part-8)
|
[Next part](#toc-backing-up-clusters)
]

.debug[(automatically generated title slide)]

---
# Static pods

- Hosting the Kubernetes control plane on Kubernetes has advantages:

  - we can use Kubernetes' replication and scaling features for the control plane

  - we can leverage rolling updates to upgrade the control plane

- However, there is a catch:

  - deploying on Kubernetes requires the API to be available

  - the API won't be available until the control plane is deployed

- How can we get out of that chicken-and-egg problem?

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## A possible approach

- Since each component of the control plane can be replicated...

- We could set up the control plane outside of the cluster

- Then, once the cluster is fully operational, create replicas running on the cluster

- Finally, remove the replicas that are running outside of the cluster

*What could possibly go wrong?*

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## Sawing off the branch you're sitting on

- What if anything goes wrong?

  (During the setup or at a later point)

- Worst case scenario, we might need to:

  - set up a new control plane (outside of the cluster)

  - restore a backup from the old control plane

  - move the new control plane to the cluster (again)

- This doesn't sound like a great experience

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## Static pods to the rescue

- Pods are started by kubelet (an agent running on every node)

- To know which pods it should run, the kubelet queries the API server

- The kubelet can also get a list of *static pods* from:

  - a directory containing one (or multiple) *manifests*, and/or

  - a URL (serving a *manifest*)

- These "manifests" are basically YAML definitions

  (As produced by `kubectl get pod my-little-pod -o yaml`)

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## Static pods are dynamic

- Kubelet will periodically reload the manifests

- It will start/stop pods accordingly

  (i.e. it is not necessary to restart the kubelet after updating the manifests)

- When connected to the Kubernetes API, the kubelet will create *mirror pods*

- Mirror pods are copies of the static pods

  (so they can be seen with e.g. `kubectl get pods`)

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## Bootstrapping a cluster with static pods

- We can run control plane components with these static pods

- They can start without requiring access to the API server

- Once they are up and running, the API becomes available

- These pods are then visible through the API

  (We cannot upgrade them from the API, though)

*This is how kubeadm has initialized our clusters.*

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## Static pods vs normal pods

- The API only gives us read-only access to static pods

- We can `kubectl delete` a static pod...

  ...But the kubelet will re-mirror it immediately

- Static pods can be selected just like other pods

  (So they can receive service traffic)

- A service can select a mixture of static and other pods

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## From static pods to normal pods

- Once the control plane is up and running, it can be used to create normal pods

- We can then set up a copy of the control plane in normal pods

- Then the static pods can be removed

- The scheduler and the controller manager use leader election

  (Only one is active at a time; removing an instance is seamless)

- Each instance of the API server adds itself to the `kubernetes` service

- Etcd will typically require more work!

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## From normal pods back to static pods

- Alright, but what if the control plane is down and we need to fix it?

- We restart it using static pods!

- This can be done automatically with a “pod checkpointer”

- The pod checkpointer automatically generates manifests of running pods

- The manifests are used to restart these pods if API contact is lost

- This pattern is implemented in [openshift/pod-checkpointer-operator] and [bootkube checkpointer]

- Unfortunately, as of 2021, both seem abandoned / unmaintained 😢

[openshift/pod-checkpointer-operator]: https://github.com/openshift/pod-checkpointer-operator
[bootkube checkpointer]: https://github.com/kubernetes-retired/bootkube/blob/master/cmd/checkpoint/README.md

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## Where should the control plane run?

*Is it better to run the control plane in static pods, or normal pods?*

- If I'm a *user* of the cluster: I don't care, it makes no difference to me

- What if I'm an *admin*, i.e. the person who installs, upgrades, repairs... the cluster?

- If I'm using a managed Kubernetes cluster (AKS, EKS, GKE...) it's not my problem

  (I'm not the one setting up and managing the control plane)

- If I already picked a tool (kubeadm, kops...) to set up my cluster, the tool decides for me

- What if I haven't picked a tool yet, or if I'm installing from scratch?

  - static pods = easier to set up, easier to troubleshoot, less risk of outage

  - normal pods = easier to upgrade, easier to move (if nodes need to be shut down)

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

## Static pods in action

- On our clusters, the `staticPodPath` is `/etc/kubernetes/manifests`

.lab[

- Have a look at this directory:
  ```bash
  ls -l /etc/kubernetes/manifests
  ```

]

We should see YAML files corresponding to the pods of the control plane.

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

class: static-pods-exercise

## Running a static pod

- We are going to add a pod manifest to the directory, and kubelet will run it

.lab[

- Copy a manifest to the directory:
  ```bash
  sudo cp ~/container.training/k8s/just-a-pod.yaml /etc/kubernetes/manifests
  ```

- Check that it's running:
  ```bash
  kubectl get pods
  ```

]

The output should include a pod named `hello-node1`.

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

class: static-pods-exercise

## Remarks

In the manifest, the pod was named `hello`.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: hello
  namespace: default
spec:
  containers:
  - name: hello
    image: nginx
```

The `-node1` suffix was added automatically by kubelet.

If we delete the pod (with `kubectl delete`), it will be recreated immediately.

To delete the pod, we need to delete (or move) the manifest file.

???

:EN:- Static pods
:FR:- Les *static pods*

.debug[[k8s/staticpods.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/staticpods.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-backing-up-clusters
class: title

 Backing up clusters

.nav[
[Previous part](#toc-static-pods)
|
[Back to table of contents](#toc-part-9)
|
[Next part](#toc-the-cloud-controller-manager)
]

.debug[(automatically generated title slide)]

---
# Backing up clusters

- Backups can have multiple purposes:

  - disaster recovery (servers or storage are destroyed or unreachable)

  - error recovery (human or process has altered or corrupted data)

  - cloning environments (for testing, validation...)

- Let's see the strategies and tools available with Kubernetes!

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Important

- Kubernetes helps us with disaster recovery

  (it gives us replication primitives)

- Kubernetes helps us clone / replicate environments

  (all resources can be described with manifests)

- Kubernetes *does not* help us with error recovery

- We still need to back up/snapshot our data:

  - with database backups (mysqldump, pgdump, etc.)

  - and/or snapshots at the storage layer

  - and/or traditional full disk backups

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## In a perfect world ...

- The deployment of our Kubernetes clusters is automated

  (recreating a cluster takes less than a minute of human time)

- All the resources (Deployments, Services...) on our clusters are under version control

  (never use `kubectl run`; always apply YAML files coming from a repository)

- Stateful components are either:

  - stored on systems with regular snapshots

  - backed up regularly to an external, durable storage

  - outside of Kubernetes

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Kubernetes cluster deployment

- If our deployment system isn't fully automated, it should at least be documented

- Litmus test: how long does it take to deploy a cluster...

  - for a senior engineer?

  - for a new hire?

- Does it require external intervention?

  (e.g. provisioning servers, signing TLS certs...)

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Plan B

- Full machine backups of the control plane can help

- If the control plane is in pods (or containers), pay attention to storage drivers

  (if the backup mechanism is not container-aware, the backups can take way more resources than they should, or even be unusable!)

- If the previous sentence worries you:

  **automate the deployment of your clusters!**

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Managing our Kubernetes resources

- Ideal scenario:

  - never create a resource directly on a cluster

  - push to a code repository

  - a special branch (`production` or even `master`) gets automatically deployed

- Some folks call this "GitOps"

  (it's the logical evolution of configuration management and infrastructure as code)

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## GitOps in theory

- What do we keep in version control?

- For very simple scenarios: source code, Dockerfiles, scripts

- For real applications: add resources (as YAML files)

- For applications deployed multiple times: Helm, Kustomize...

  (staging and production count as "multiple times")

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## GitOps tooling

- Various tools exist (Weave Flux, GitKube...)

- These tools are still very young

- You still need to write YAML for all your resources

- There is no tool to:

  - list *all* resources in a namespace

  - get resource YAML in a canonical form

  - diff YAML descriptions with current state

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## GitOps in practice

- Start describing your resources with YAML

- Leverage a tool like Kustomize or Helm

- Make sure that you can easily deploy to a new namespace

  (or even better: to a new cluster)

- When tooling matures, you will be ready

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Plan B

- What if we can't describe everything with YAML?

- What if we manually create resources and forget to commit them to source control?

- What about global resources, that don't live in a namespace?

- How can we be sure that we saved *everything*?

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Backing up etcd

- All objects are saved in etcd

- etcd data should be relatively small

  (and therefore, quick and easy to back up)

- Two options to back up etcd:

  - snapshot the data directory

  - use `etcdctl snapshot`

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Making an etcd snapshot

- The basic command is simple:
  ```bash
  etcdctl snapshot save <filename>
  ```

- But we also need to specify:

  - an environment variable to specify that we want etcdctl v3

  - the address of the server to back up

  - the path to the key, certificate, and CA certificate
    <br/>(if our etcd uses TLS certificates)

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Snapshotting etcd on kubeadm

- The following command will work on clusters deployed with kubeadm

  (and maybe others)

- It should be executed on a master node

```bash
docker run --rm --net host -v $PWD:/vol \
    -v /etc/kubernetes/pki/etcd:/etc/kubernetes/pki/etcd:ro \
    -e ETCDCTL_API=3 k8s.gcr.io/etcd:3.3.10 \
    etcdctl --endpoints=https://[127.0.0.1]:2379 \
            --cacert=/etc/kubernetes/pki/etcd/ca.crt \
            --cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt \
            --key=/etc/kubernetes/pki/etcd/healthcheck-client.key \
            snapshot save /vol/snapshot
```

- It will create a file named `snapshot` in the current directory

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## How can we remember all these flags?

- Older versions of kubeadm did add a healthcheck probe with all these flags

- That healthcheck probe was calling `etcdctl` with all the right flags 

- With recent versions of kubeadm, we're on our own!

- Exercise: write the YAML for a batch job to perform the backup

  (how will you access the key and certificate required to connect?)

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Restoring an etcd snapshot

- ~~Execute exactly the same command, but replacing `save` with `restore`~~

  (Believe it or not, doing that will *not* do anything useful!)

- The `restore` command does *not* load a snapshot into a running etcd server

- The `restore` command creates a new data directory from the snapshot

  (it's an offline operation; it doesn't interact with an etcd server)

- It will create a new data directory in a temporary container

  (leaving the running etcd node untouched)

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## When using kubeadm

1. Create a new data directory from the snapshot:
   ```bash
   sudo rm -rf /var/lib/etcd
   docker run --rm -v /var/lib:/var/lib -v $PWD:/vol \
          -e ETCDCTL_API=3 k8s.gcr.io/etcd:3.3.10 \
          etcdctl snapshot restore /vol/snapshot --data-dir=/var/lib/etcd
   ```

2. Provision the control plane, using that data directory:
   ```bash
   sudo kubeadm init \
        --ignore-preflight-errors=DirAvailable--var-lib-etcd
   ```

3. Rejoin the other nodes

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## The fine print

- This only saves etcd state

- It **does not** save persistent volumes and local node data

- Some critical components (like the pod network) might need to be reset

- As a result, our pods might have to be recreated, too

- If we have proper liveness checks, this should happen automatically

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## More information about etcd backups

- [Kubernetes documentation](https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#built-in-snapshot) about etcd backups

- [etcd documentation](https://coreos.com/etcd/docs/latest/op-guide/recovery.html#snapshotting-the-keyspace) about snapshots and restore

- [A good blog post by elastisys](https://elastisys.com/2018/12/10/backup-kubernetes-how-and-why/) explaining how to restore a snapshot

- [Another good blog post by consol labs](https://labs.consol.de/kubernetes/2018/05/25/kubeadm-backup.html) on the same topic

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Don't forget ...

- Also back up the TLS information

  (at the very least: CA key and cert; API server key and cert)

- With clusters provisioned by kubeadm, this is in `/etc/kubernetes/pki`

- If you don't:

  - you will still be able to restore etcd state and bring everything back up

  - you will need to redistribute user certificates

.warning[**TLS information is highly sensitive! 
<br/>Anyone who has it has full access to your cluster!**]

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Stateful services

- It's totally fine to keep your production databases outside of Kubernetes

  *Especially if you have only one database server!*

- Feel free to put development and staging databases on Kubernetes

  (as long as they don't hold important data)

- Using Kubernetes for stateful services makes sense if you have *many*

  (because then you can leverage Kubernetes automation)

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## Snapshotting persistent volumes

- Option 1: snapshot volumes out of band

  (with the API/CLI/GUI of our SAN/cloud/...)

- Option 2: storage system integration

  (e.g. [Portworx](https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/create-snapshots/) can [create snapshots through annotations](https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/create-snapshots/snaps-annotations/#taking-periodic-snapshots-on-a-running-pod))

- Option 3: [snapshots through Kubernetes API](https://kubernetes.io/docs/concepts/storage/volume-snapshots/)

  (Generally available since Kuberentes 1.20 for a number of [CSI](https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/) volume plugins : GCE, OpenSDS, Ceph, Portworx, etc)

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

## More backup tools

- [Stash](https://appscode.com/products/stash/)

  back up Kubernetes persistent volumes

- [ReShifter](https://github.com/mhausenblas/reshifter)

  cluster state management

- ~~Heptio Ark~~ [Velero](https://github.com/heptio/velero)

  full cluster backup

- [kube-backup](https://github.com/pieterlange/kube-backup)

  simple scripts to save resource YAML to a git repository
  
- [bivac](https://github.com/camptocamp/bivac) 

  Backup Interface for Volumes Attached to Containers 

???

:EN:- Backing up clusters
:FR:- Politiques de sauvegarde

.debug[[k8s/cluster-backup.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-backup.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-the-cloud-controller-manager
class: title

 The Cloud Controller Manager

.nav[
[Previous part](#toc-backing-up-clusters)
|
[Back to table of contents](#toc-part-9)
|
[Next part](#toc-healthchecks)
]

.debug[(automatically generated title slide)]

---
# The Cloud Controller Manager

- Kubernetes has many features that are cloud-specific

  (e.g. providing cloud load balancers when a Service of type LoadBalancer is created)

- These features were initially implemented in API server and controller manager

- Since Kubernetes 1.6, these features are available through a separate process:

  the *Cloud Controller Manager*

- The CCM is optional, but if we run in a cloud, we probably want it!

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

## Cloud Controller Manager duties

- Creating and updating cloud load balancers

- Configuring routing tables in the cloud network (specific to GCE)

- Updating node labels to indicate region, zone, instance type...

- Obtain node name, internal and external addresses from cloud metadata service

- Deleting nodes from Kubernetes when they're deleted in the cloud

- Managing *some* volumes (e.g. ELBs, AzureDisks...)

  (Eventually, volumes will be managed by the Container Storage Interface)

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

## In-tree vs. out-of-tree

- A number of cloud providers are supported "in-tree"

  (in the main kubernetes/kubernetes repository on GitHub)

- More cloud providers are supported "out-of-tree"

  (with code in different repositories)

- There is an [ongoing effort](https://github.com/kubernetes/kubernetes/tree/master/pkg/cloudprovider) to move everything to out-of-tree providers

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

## In-tree providers

The following providers are actively maintained:

- Amazon Web Services
- Azure
- Google Compute Engine
- IBM Cloud
- OpenStack
- VMware vSphere

These ones are less actively maintained:

- Apache CloudStack
- oVirt
- VMware Photon

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

## Out-of-tree providers

The list includes the following providers:

- DigitalOcean

- keepalived (not exactly a cloud; provides VIPs for load balancers)

- Linode

- Oracle Cloud Infrastructure

(And possibly others; there is no central registry for these.)

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

## Audience questions

- What kind of clouds are you using/planning to use?

- What kind of details would you like to see in this section?

- Would you appreciate details on clouds that you don't / won't use?

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

## Cloud Controller Manager in practice

- Write a configuration file

  (typically `/etc/kubernetes/cloud.conf`)

- Run the CCM process

  (on self-hosted clusters, this can be a DaemonSet selecting the control plane nodes)

- Start kubelet with `--cloud-provider=external`

- When using managed clusters, this is done automatically

- There is very little documentation on writing the configuration file

  (except for OpenStack)

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

## Bootstrapping challenges

- When a node joins the cluster, it needs to obtain a signed TLS certificate

- That certificate must contain the node's addresses

- These addresses are provided by the Cloud Controller Manager

  (at least the external address)

- To get these addresses, the node needs to communicate with the control plane

- ...Which means joining the cluster

(The problem didn't occur when cloud-specific code was running in kubelet: kubelet could obtain the required information directly from the cloud provider's metadata service.)

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

## More information about CCM

- CCM configuration and operation is highly specific to each cloud provider

  (which is why this section remains very generic)

- The Kubernetes documentation has *some* information:

  - [architecture and diagrams](https://kubernetes.io/docs/concepts/architecture/cloud-controller/)

  - [configuration](https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/) (mainly for OpenStack)

  - [deployment](https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/)

???

:EN:- The Cloud Controller Manager
:FR:- Le *Cloud Controller Manager*

.debug[[k8s/cloud-controller-manager.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cloud-controller-manager.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-healthchecks
class: title

 Healthchecks

.nav[
[Previous part](#toc-the-cloud-controller-manager)
|
[Back to table of contents](#toc-part-9)
|
[Next part](#toc-deploying-a-sample-application)
]

.debug[(automatically generated title slide)]

---
# Healthchecks

- Healthchecks can improve the reliability of our applications, for instance:

  - detect when a container has crashed, and restart it automatically

  - pause a rolling update until the new containers are ready to serve traffic

  - temporarily remove an overloaded backend from a loadbalancer

- There are three kinds of healthchecks, corresponding to different use-cases:

  `startupProbe`, `readinessProbe`, `livenessProbe`

- Healthchecks are optional

  (in the absence of healthchecks, Kubernetes considers the container to be healthy)

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Use-cases in brief

1. *My container takes a long time to boot before being able to serve traffic.*

    → use a `startupProbe` (but often a `readinessProbe` can also do the job¹)

2. *Sometimes, my container is unavailable or overloaded, and needs to e.g. be taken temporarily out of load balancer rotation.*

    → use a `readinessProbe`

3. *Sometimes, my container enters a broken state which can only be fixed by a restart.*

    → use a `livenessProbe`

.footnote[¹In fact, we will see that in many cases, a `readinessProbe` is all we need. Stay tuned!]

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Startup probes

*My container takes a long time to boot before being able to serve traffic.*

- After creating a container, Kubernetes runs its startup probe

- The container will be considered "unhealthy" until the probe succeeds

- As long as the container is "unhealthy", its Pod...:

  - is not added to Services' endpoints

  - is not considered as "available" for rolling update purposes

- Readiness and liveness probes are enabled *after* startup probe reports success

  (if there is no startup probe, readiness and liveness probes are enabled right away)

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## When to use a startup probe

- For containers that take a long time to start

  (more than 30 seconds)

- Especially if that time can vary a lot

  (e.g. fast in dev, slow in prod, or the other way around)

.footnote[⚠️ Make sure to read the warnings later in this section!]

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Readiness probes

*Sometimes, my container "needs a break".*

- Check if the container is ready or not

- If the container is not ready, its Pod is not ready

- If the Pod belongs to a Service, it is removed from its Endpoints

  (it stops receiving new connections but existing ones are not affected)

- If there is a rolling update in progress, it might pause

  (Kubernetes will try to respect the MaxUnavailable parameter)

- As soon as the readiness probe suceeds again, everything goes back to normal

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## When to use a readiness probe

- To indicate failure due to an external cause

  - database is down or unreachable

  - mandatory auth or other backend service unavailable

- To indicate temporary failure or unavailability

  - runtime is busy doing garbage collection or (re)loading data

  - application can only service *N* parallel connections

  - new connections will be directed to other Pods

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Liveness probes

*This container is dead, we don't know how to fix it, other than restarting it.*

- Check if the container is dead or alive

- If Kubernetes determines that the container is dead:

  - it terminates the container gracefully

  - it restarts the container (unless the Pod's `restartPolicy` is `Never`)

- With the default parameters, it takes:

  - up to 30 seconds to determine that the container is dead

  - up to 30 seconds to terminate it

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## When to use a liveness probe

- To detect failures that can't be recovered

  - deadlocks (causing all requests to time out)

  - internal corruption (causing all requests to error)

- Anything where our incident response would be "just restart/reboot it"

.footnote[⚠️ Make sure to read the warnings later in this section!]

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Different types of probes

- Kubernetes supports the following mechanisms:

  - `httpGet` (HTTP GET request)

  - `exec` (arbitrary program execution)

  - `tcpSocket` (check if a TCP port is accepting connections)

  - `grpc` (standard [GRPC Health Checking Protocol][grpc])

- All probes give binary results ("it works" or "it doesn't")

- Let's see the specific details for each of them!

[grpc]: https://grpc.github.io/grpc/core/md_doc_health-checking.html

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## `httpGet`

- Make an HTTP GET request to the container

- The request will be made by Kubelet

  (doesn't require extra binaries in the container image)

- `port` must be specified

- `path` and extra `httpHeaders` can be specified optionally

- Kubernetes uses HTTP status code of the response:

  - 200-399 = success

  - anything else = failure

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## `httpGet` example

The following readiness probe checks that the container responds on `/healthz`:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: frontend
    image: myregistry.../frontend:v1.0
    readinessProbe:
      httpGet:
        port: 80
        path: /healthz
```

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## `exec`

- Runs an arbitrary program *inside* the container

  (like with `kubectl exec` or `docker exec`)

- The program must be available in the container image

- Kubernetes uses the exit status of the program

  (standard UNIX convention: 0 = success, anything else = failure)

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## `exec` example

When the worker is ready, it should create `/tmp/ready`.
<br/>
The following probe will give it 5 minutes to do so.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: queueworker
spec:
  containers:
  - name: worker
    image: myregistry.../worker:v1.0
    startupProbe:
      exec:
        command:
        - test
        - -f
        - /tmp/ready
      failureThreshold: 30
```

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

class: extra-details

## `startupProbe` and `failureThreshold`

- Note the `failureThreshold: 30` on the previous manifest

- This is important when defining a `startupProbe`

- Otherwise, if the container fails to come up within 30 seconds...

- ...Kubernetes restarts it!

- More on this later

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Using shell constructs

- If we want to use pipes, conditionals, etc. we should invoke a shell

- Example:
  ```yaml
    exec:
      command:
      - sh
      - -c
      - "curl http://localhost:5000/status | jq .ready | grep true"
  ```

- All these programs (`curl`, `jq`, `grep`) must be available in the container image

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## `tcpSocket`

- Kubernetes checks if the indicated TCP port accepts connections

- There is no additional check

.warning[It's quite possible for a process to be broken, but still accept TCP connections!]

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## `grpc`

<!-- ##VERSION## -->

<!-- https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-grpc-liveness-probe -->

- Available in beta since Kubernetes 1.24

- Leverages standard [GRPC Health Checking Protocol][grpc]

[grpc]: https://grpc.github.io/grpc/core/md_doc_health-checking.html

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Timing and thresholds

- Probes are executed at intervals of `periodSeconds` (default: 10)

- The timeout for a probe is set with `timeoutSeconds` (default: 1)

.warning[If a probe takes longer than that, it is considered as a FAIL]

.warning[For liveness probes **and startup probes** this terminates and restarts the container]

- A probe is considered successful after `successThreshold` successes (default: 1)

- A probe is considered failing after `failureThreshold` failures (default: 3)

- All these parameters can be set independently for each probe

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

class: extra-details

## `initialDelaySeconds`

- A probe can have an `initialDelaySeconds` parameter (default: 0)

- Kubernetes will wait that amount of time before running the probe for the first time

- It is generally better to use a `startupProbe` instead

  (but this parameter did exist before startup probes were implemented)

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Be careful when adding healthchecks

- It is tempting to just "add all healthchecks"

- This can be counter-productive and cause problems:

  - cascading failures

  - containers that fail to start when system is under load

  - wasting resources by restarting big containers

- Let's analyze these problems!

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Liveness probes gotchas

.warning[**Do not** use liveness probes for problems that can't be fixed by a restart]

- Otherwise we just restart our pods for no reason, creating useless load

.warning[**Do not** depend on other services within a liveness probe]

- Otherwise we can experience cascading failures

  (example: web server liveness probe that makes a requests to a database)

.warning[**Make sure** that liveness probes respond quickly]

- The default probe timeout is 1 second (this can be tuned!)

- If the probe takes longer than that, it will eventually cause a restart

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Startup probes gotchas

- If a `startupProbe` fails, Kubernetes restarts the corresponding container

- In other words: with the default parameters, the container must start within 30 seconds

  (`failureThreshold` × `periodSeconds`)

- This is why we almost always want to adjust the parameters of a `startupProbe`

  (specifically, its `failureThreshold`)

- Sometimes, it's easier/simpler to use a `readinessProbe` instead

  (see next slide for details)

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## When do we need startup probes?

- Only beneficial for containers that need a long time to start

  (more than 30 seconds)

- If there is no liveness probe, it's simpler to just use a readiness probe

  (since we probably want to have a readiness probe anyway)

- In other words, startup probes are useful in one situation:

  *we have a liveness probe, AND the container needs a lot of time to start*

- Don't forget to change the `failureThreshold`

  (otherwise the container will fail to start and be killed)

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

class: extra-details

## `readinessProbe` vs `startupProbe`

- A lot of blog posts / documentations / tutorials recommend readiness probes...

- ...even in scenarios where a startup probe would seem more appropriate!

- This is because startup probes are relatively recent

  (they reached GA status in Kubernetes 1.20)

- When there is no `livenessProbe`, using a `readinessProbe` is simpler:

  - a `startupProbe` generally requires to change the `failureThreshold`

  - a `startupProbe` generally also requires a `readinessProbe`

  - a single `readinessProbe` can fulfill both roles

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Best practices for healthchecks

- Readiness probes are almost always beneficial

  - don't hesitate to add them early!

  - we can even make them *mandatory*

- Be more careful with liveness and startup probes

  - they aren't always necessary

  - they can even cause harm

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Readiness probes

- Almost always beneficial

- Exceptions:

  - web service that doesn't have a dedicated "health" or "ping" route

  - ...and all requests are "expensive" (e.g. lots of external calls)

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Liveness probes

- If we're not careful, we end up restarting containers for no reason

  (which can cause additional load on the cluster, cascading failures, data loss, etc.)

- Suggestion:

  - don't add liveness probes immediately

  - wait until you have a bit of production experience with that code

  - then add narrow-scoped healthchecks to detect specific failure modes

- Readiness and liveness probes should be different

  (different check *or* different timeouts *or* different thresholds)

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Recap of the gotchas

- The default timeout is 1 second

  - if a probe takes longer than 1 second to reply, Kubernetes considers that it fails

  - this can be changed by setting the `timeoutSeconds` parameter
    <br/>(or refactoring the probe)

- Liveness probes should not be influenced by the state of external services

- Liveness probes and readiness probes should have different paramters

- For startup probes, remember to increase the `failureThreshold`

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---

## Healthchecks for workers

(In that context, worker = process that doesn't accept connections)

- A relatively easy solution is to use files

- For a startup or readiness probe:

  - worker creates `/tmp/ready` when it's ready
  - probe checks the existence of `/tmp/ready`

- For a liveness probe:

  - worker touches `/tmp/alive` regularly
    <br/>(e.g. just before starting to work on a job)
  - probe checks that the timestamp on `/tmp/alive` is recent
  - if the timestamp is old, it means that the worker is stuck

- Sometimes it can also make sense to embed a web server in the worker

???

:EN:- Using healthchecks to improve availability
:FR:- Utiliser des *healthchecks* pour améliorer la disponibilité

.debug[[k8s/healthchecks.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks.md)]
---
## Adding healthchecks to an app

- Let's add healthchecks to DockerCoins!

- We will examine the questions of the previous slide

- Then we will review each component individually to add healthchecks

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Liveness, readiness, or both?

- To answer that question, we need to see the app run for a while

- Do we get temporary, recoverable glitches?

  → then use readiness

- Or do we get hard lock-ups requiring a restart?

  → then use liveness

- In the case of DockerCoins, we don't know yet!

- Let's pick liveness

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Do we have HTTP endpoints that we can use?

- Each of the 3 web services (hasher, rng, webui) has a trivial route on `/`

- These routes:

  - don't seem to perform anything complex or expensive

  - don't seem to call other services

- Perfect!

  (See next slides for individual details)

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

- [hasher.rb](https://github.com/jpetazzo/container.training/blob/master/dockercoins/hasher/hasher.rb)
  ```ruby
    get '/' do
      "HASHER running on #{Socket.gethostname}\n"
    end
  ```

- [rng.py](https://github.com/jpetazzo/container.training/blob/master/dockercoins/rng/rng.py)
  ```python
    @app.route("/")
    def index():
      return "RNG running on {}\n".format(hostname)
  ```

- [webui.js](https://github.com/jpetazzo/container.training/blob/master/dockercoins/webui/webui.js)
  ```javascript
    app.get('/', function (req, res) {
      res.redirect('/index.html');
    });
  ```

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Running DockerCoins

- We will run DockerCoins in a new, separate namespace

- We will use a set of YAML manifests and pre-built images

- We will add our new liveness probe to the YAML of the `rng` DaemonSet

- Then, we will deploy the application

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Creating a new namespace

- This will make sure that we don't collide / conflict with previous labs and exercises

.lab[

- Create the yellow namespace:
  ```bash
  kubectl create namespace yellow
  ```

- Switch to that namespace:
  ```bash
  kns yellow
  ```

]

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Retrieving DockerCoins manifests

- All the manifests that we need are on a convenient repository:

  https://github.com/jpetazzo/kubercoins

.lab[

- Clone that repository:
  ```bash
  cd ~
  git clone https://github.com/jpetazzo/kubercoins
  ```

- Change directory to the repository:
  ```bash
  cd kubercoins
  ```

]

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## A simple HTTP liveness probe

This is what our liveness probe should look like:

```yaml
containers:
- name: ...
image: ...
livenessProbe:
  httpGet:
    path: /
    port: 80
  initialDelaySeconds: 30
  periodSeconds: 5
```

This will give 30 seconds to the service to start. (Way more than necessary!)
<br/>
It will run the probe every 5 seconds.
<br/>
It will use the default timeout (1 second).
<br/>
It will use the default failure threshold (3 failed attempts = dead).
<br/>
It will use the default success threshold (1 successful attempt = alive).

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Adding the liveness probe

- Let's add the liveness probe, then deploy DockerCoins

.lab[

- Edit `rng-deployment.yaml` and add the liveness probe
  ```bash
  vim rng-deployment.yaml
  ```

- Load the YAML for all the resources of DockerCoins:
  ```bash
  kubectl apply -f .
  ```

]

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Testing the liveness probe

- The rng service needs 100ms to process a request

  (because it is single-threaded and sleeps 0.1s in each request)

- The probe timeout is set to 1 second

- If we send more than 10 requests per second per backend, it will break

- Let's generate traffic and see what happens!

.lab[

- Get the ClusterIP address of the rng service:
  ```bash
  kubectl get svc rng
  ```

]

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Monitoring the rng service

- Each command below will show us what's happening on a different level

.lab[

- In one window, monitor cluster events:
  ```bash
  kubectl get events -w
  ```

- In another window, monitor the response time of rng:
  ```bash
  httping `<ClusterIP>`
  ```

- In another window, monitor pods status:
  ```bash
  kubectl get pods -w
  ```

]

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Generating traffic

- Let's use `ab` to send concurrent requests to rng

.lab[

- In yet another window, generate traffic:
  ```bash
  ab -c 10 -n 1000 http://`<ClusterIP>`/1
  ```

- Experiment with higher values of `-c` and see what happens

]

- The `-c` parameter indicates the number of concurrent requests

- The final `/1` is important to generate actual traffic

  (otherwise we would use the ping endpoint, which doesn't sleep 0.1s per request)

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Discussion

- Above a given threshold, the liveness probe starts failing

  (about 10 concurrent requests per backend should be plenty enough)

- When the liveness probe fails 3 times in a row, the container is restarted

- During the restart, there is *less* capacity available

- ... Meaning that the other backends are likely to timeout as well

- ... Eventually causing all backends to be restarted

- ... And each fresh backend gets restarted, too

- This goes on until the load goes down, or we add capacity

*This wouldn't be a good healthcheck in a real application!*

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Better healthchecks

- We need to make sure that the healthcheck doesn't trip when
  performance degrades due to external pressure

- Using a readiness check would have fewer effects

  (but it would still be an imperfect solution)

- A possible combination:

  - readiness check with a short timeout / low failure threshold

  - liveness check with a longer timeout / higher failure threshold

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

## Healthchecks for redis

- A liveness probe is enough

  (it's not useful to remove a backend from rotation when it's the only one)

- We could use an exec probe running `redis-cli ping`

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

class: extra-details

## Exec probes and zombies

- When using exec probes, we should make sure that we have a *zombie reaper*

  🤔🧐🧟 Wait, what?

- When a process terminates, its parent must call `wait()`/`waitpid()`

  (this is how the parent process retrieves the child's exit status)

- In the meantime, the process is in *zombie* state

  (the process state will show as `Z` in `ps`, `top` ...)

- When a process is killed, its children are *orphaned* and attached to PID 1

- PID 1 has the responsibility of *reaping* these processes when they terminate

- OK, but how does that affect us?

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

class: extra-details

## PID 1 in containers

- On ordinary systems, PID 1 (`/sbin/init`) has logic to reap processes

- In containers, PID 1 is typically our application process

  (e.g. Apache, the JVM, NGINX, Redis ...)

- These *do not* take care of reaping orphans

- If we use exec probes, we need to add a process reaper

- We can add [tini](https://github.com/krallin/tini) to our images

- Or [share the PID namespace between containers of a pod](https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/)

  (and have gcr.io/pause take care of the reaping)

- Discussion of this in [Video - 10 Ways to Shoot Yourself in the Foot with Kubernetes, #9 Will Surprise You](https://www.youtube.com/watch?v=QKI-JRs2RIE)

???

:EN:- Adding healthchecks to an app
:FR:- Ajouter des *healthchecks* à une application

.debug[[k8s/healthchecks-more.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/healthchecks-more.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-deploying-a-sample-application
class: title

 Deploying a sample application

.nav[
[Previous part](#toc-healthchecks)
|
[Back to table of contents](#toc-part-10)
|
[Next part](#toc-accessing-logs-from-the-cli)
]

.debug[(automatically generated title slide)]

---
# Deploying a sample application

- We will connect to our new Kubernetes cluster

- We will deploy a sample application, "DockerCoins"

- That app features multiple micro-services and a web UI

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## Connecting to our Kubernetes cluster

- Our cluster has multiple nodes named `node1`, `node2`, etc.

- We will do everything from `node1`

- We have SSH access to the other nodes, but won't need it

  (but we can use it for debugging, troubleshooting, etc.)

.lab[

- Log into `node1`

- Check that all nodes are `Ready`:
  ```bash
  kubectl get nodes
  ```

]

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## Cloning the repository

- We will need to clone the training repository

- It has the DockerCoins demo app ...

- ... as well as these slides, some scripts, more manifests

.lab[

- Clone the repository on `node1`:
  ```bash
  git clone https://
  ```

]

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## Running the application

Without further ado, let's start this application!

.lab[

- Apply the manifest for dockercoins:
  ```bash
  kubectl apply -f ~/container.training/k8s/dockercoins.yaml
  ```

]

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## What's this application?

--

- It is a DockerCoin miner! 💰🐳📦🚢

--

- No, you can't buy coffee with DockerCoins

--

- How DockerCoins works:

  - generate a few random bytes

  - hash these bytes

  - increment a counter (to keep track of speed)

  - repeat forever!

--

- DockerCoins is *not* a cryptocurrency

  (the only common points are "randomness", "hashing", and "coins" in the name)

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## DockerCoins in the microservices era

- DockerCoins is made of 5 services:

  - `rng` = web service generating random bytes

  - `hasher` = web service computing hash of POSTed data

  - `worker` = background process calling `rng` and `hasher`

  - `webui` = web interface to watch progress

  - `redis` = data store (holds a counter updated by `worker`)

- These 5 services are visible in the application's Compose file,
  [docker-compose.yml](
  https:///blob/master/dockercoins/docker-compose.yml)

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## How DockerCoins works

- `worker` invokes web service `rng` to generate random bytes

- `worker` invokes web service `hasher` to hash these bytes

- `worker` does this in an infinite loop

- every second, `worker` updates `redis` to indicate how many loops were done

- `webui` queries `redis`, and computes and exposes "hashing speed" in our browser

*(See diagram on next slide!)*

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

class: pic

![Diagram showing the 5 containers of the applications](images/dockercoins-diagram.png)

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## Service discovery in container-land

How does each service find out the address of the other ones?

--

- We do not hard-code IP addresses in the code

- We do not hard-code FQDNs in the code, either

- We just connect to a service name, and container-magic does the rest

  (And by container-magic, we mean "a crafty, dynamic, embedded DNS server")

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## Example in `worker/worker.py`

```python
redis = Redis("`redis`")


def get_random_bytes():
    r = requests.get("http://`rng`/32")
    return r.content


def hash_bytes(data):
    r = requests.post("http://`hasher`/",
                      data=data,
                      headers={"Content-Type": "application/octet-stream"})
```

(Feel free to check the [full source code][dockercoins-worker-code] of the worker!)

[dockercoins-worker-code]: https:///blob/8279a3bce9398f7c1a53bdd95187c53eda4e6435/dockercoins/worker/worker.py#L17

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## Show me the code!

- You can check the GitHub repository with all the materials of this workshop:
  <br/>https://

- The application is in the [dockercoins](
  https:///tree/master/dockercoins)
  subdirectory

- The Compose file ([docker-compose.yml](
  https:///blob/master/dockercoins/docker-compose.yml))
  lists all 5 services

- `redis` is using an official image from the Docker Hub

- `hasher`, `rng`, `worker`, `webui` are each built from a Dockerfile

- Each service's Dockerfile and source code is in its own directory

  (`hasher` is in the [hasher](https:///blob/master/dockercoins/hasher/) directory,
  `rng` is in the [rng](https:///blob/master/dockercoins/rng/)
  directory, etc.)

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## Our application at work

- We can check the logs of our application's pods

.lab[

- Check the logs of the various components:
  ```bash
  kubectl logs deploy/worker
  kubectl logs deploy/hasher
  ```

]

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

## Connecting to the web UI

- "Logs are exciting and fun!" (No-one, ever)

- The `webui` container exposes a web dashboard; let's view it

.lab[

- Check the NodePort allocated to the web UI:
  ```bash
  kubectl get svc webui
  ```

- Open that in a web browser

]

A drawing area should show up, and after a few seconds, a blue
graph will appear.

???

:EN:- Deploying a sample app with YAML manifests
:FR:- Lancer une application de démo avec du YAML

.debug[[k8s/kubercoins.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/kubercoins.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-accessing-logs-from-the-cli
class: title

 Accessing logs from the CLI

.nav[
[Previous part](#toc-deploying-a-sample-application)
|
[Back to table of contents](#toc-part-10)
|
[Next part](#toc-centralized-logging)
]

.debug[(automatically generated title slide)]

---
# Accessing logs from the CLI

- The `kubectl logs` command has limitations:

  - it cannot stream logs from multiple pods at a time

  - when showing logs from multiple pods, it mixes them all together

- We are going to see how to do it better

.debug[[k8s/logs-cli.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-cli.md)]
---

## Doing it manually

- We *could* (if we were so inclined) write a program or script that would:

  - take a selector as an argument

  - enumerate all pods matching that selector (with `kubectl get -l ...`)

  - fork one `kubectl logs --follow ...` command per container

  - annotate the logs (the output of each `kubectl logs ...` process) with their origin

  - preserve ordering by using `kubectl logs --timestamps ...` and merge the output

--

- We *could* do it, but thankfully, others did it for us already!

.debug[[k8s/logs-cli.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-cli.md)]
---

## Stern

[Stern](https://github.com/stern/stern) is an open source project
originally by [Wercker](http://www.wercker.com/).

From the README:

*Stern allows you to tail multiple pods on Kubernetes and multiple containers within the pod. Each result is color coded for quicker debugging.*

*The query is a regular expression so the pod name can easily be filtered and you don't need to specify the exact id (for instance omitting the deployment id). If a pod is deleted it gets removed from tail and if a new pod is added it automatically gets tailed.*

Exactly what we need!

.debug[[k8s/logs-cli.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-cli.md)]
---

## Checking if Stern is installed

- Run `stern` (without arguments) to check if it's installed:

  ```
  $ stern
  Tail multiple pods and containers from Kubernetes

  Usage:
    stern pod-query [flags]
  ```

- If it's missing, let's see how to install it

.debug[[k8s/logs-cli.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-cli.md)]
---

## Installing Stern

- Stern is written in Go

- Go programs are usually very easy to install

  (no dependencies, extra libraries to install, etc)

- Binary releases are available [on GitHub][stern-releases]

- Stern is also available through most package managers

  (e.g. on macOS, we can `brew install stern` or `sudo port install stern`)

[stern-releases]: https://github.com/stern/stern/releases

.debug[[k8s/logs-cli.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-cli.md)]
---

## Using Stern

- There are two ways to specify the pods whose logs we want to see:

  - `-l` followed by a selector expression (like with many `kubectl` commands)

  - with a "pod query," i.e. a regex used to match pod names

- These two ways can be combined if necessary

.lab[

- View the logs for all the pingpong containers:
  ```bash
  stern pingpong
  ```

<!--
```wait seq=```
```key ^C```
-->

]

.debug[[k8s/logs-cli.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-cli.md)]
---

## Stern convenient options

- The `--tail N` flag shows the last `N` lines for each container

  (Instead of showing the logs since the creation of the container)

- The `-t` / `--timestamps` flag shows timestamps

- The `--all-namespaces` flag is self-explanatory

.lab[

- View what's up with the `weave` system containers:
  ```bash
  stern --tail 1 --timestamps --all-namespaces weave
  ```

<!--
```wait weave-npc```
```key ^C```
-->

]

.debug[[k8s/logs-cli.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-cli.md)]
---

## Using Stern with a selector

- When specifying a selector, we can omit the value for a label

- This will match all objects having that label (regardless of the value)

- Everything created with `kubectl run` has a label `run`

- Everything created with `kubectl create deployment` has a label `app`

- We can use that property to view the logs of all the pods created with `kubectl create deployment`

.lab[

- View the logs for all the things started with `kubectl create deployment`:
  ```bash
  stern -l app
  ```

<!--
```wait seq=```
```key ^C```
-->

]

???

:EN:- Viewing pod logs from the CLI
:FR:- Consulter les logs des pods depuis la CLI

.debug[[k8s/logs-cli.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-cli.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-centralized-logging
class: title

 Centralized logging

.nav[
[Previous part](#toc-accessing-logs-from-the-cli)
|
[Back to table of contents](#toc-part-10)
|
[Next part](#toc-authentication-and-authorization)
]

.debug[(automatically generated title slide)]

---
# Centralized logging

- Using `kubectl` or `stern` is simple; but it has drawbacks:

  - when a node goes down, its logs are not available anymore

  - we can only dump or stream logs; we want to search/index/count...

- We want to send all our logs to a single place

- We want to parse them (e.g. for HTTP logs) and index them

- We want a nice web dashboard

--

- We are going to deploy an EFK stack

.debug[[k8s/logs-centralized.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-centralized.md)]
---

## What is EFK?

- EFK is three components:

  - ElasticSearch (to store and index log entries)

  - Fluentd (to get container logs, process them, and put them in ElasticSearch)

  - Kibana (to view/search log entries with a nice UI)

- The only component that we need to access from outside the cluster will be Kibana

.debug[[k8s/logs-centralized.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-centralized.md)]
---

## Deploying EFK on our cluster

- We are going to use a YAML file describing all the required resources

.lab[

- Load the YAML file into our cluster:
  ```bash
  kubectl apply -f ~/container.training/k8s/efk.yaml
  ```

]

If we [look at the YAML file](https://github.com/jpetazzo/container.training/blob/master/k8s/efk.yaml), we see that
it creates a daemon set, two deployments, two services,
and a few roles and role bindings (to give fluentd the required permissions).

.debug[[k8s/logs-centralized.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-centralized.md)]
---

## The itinerary of a log line (before Fluentd)

- A container writes a line on stdout or stderr

- Both are typically piped to the container engine (Docker or otherwise)

- The container engine reads the line, and sends it to a logging driver

- The timestamp and stream (stdout or stderr) is added to the log line

- With the default configuration for Kubernetes, the line is written to a JSON file

  (`/var/log/containers/pod-name_namespace_container-id.log`)

- That file is read when we invoke `kubectl logs`; we can access it directly too

.debug[[k8s/logs-centralized.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-centralized.md)]
---

## The itinerary of a log line (with Fluentd)

- Fluentd runs on each node (thanks to a daemon set)

- It bind-mounts `/var/log/containers` from the host (to access these files)

- It continuously scans this directory for new files; reads them; parses them

- Each log line becomes a JSON object, fully annotated with extra information:
  <br/>container id, pod name, Kubernetes labels...

- These JSON objects are stored in ElasticSearch

- ElasticSearch indexes the JSON objects

- We can access the logs through Kibana (and perform searches, counts, etc.)

.debug[[k8s/logs-centralized.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-centralized.md)]
---

## Accessing Kibana

- Kibana offers a web interface that is relatively straightforward

- Let's check it out!

.lab[

- Check which `NodePort` was allocated to Kibana:
  ```bash
  kubectl get svc kibana
  ```

- With our web browser, connect to Kibana

]

.debug[[k8s/logs-centralized.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-centralized.md)]
---

## Using Kibana

*Note: this is not a Kibana workshop! So this section is deliberately very terse.*

- The first time you connect to Kibana, you must "configure an index pattern"

- Just use the one that is suggested, `@timestamp`.red[*]

- Then click "Discover" (in the top-left corner)

- You should see container logs

- Advice: in the left column, select a few fields to display, e.g.:

  `kubernetes.host`, `kubernetes.pod_name`, `stream`, `log`

.red[*]If you don't see `@timestamp`, it's probably because no logs exist yet.
<br/>Wait a bit, and double-check the logging pipeline!

.debug[[k8s/logs-centralized.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-centralized.md)]
---

## Caveat emptor

We are using EFK because it is relatively straightforward
to deploy on Kubernetes, without having to redeploy or reconfigure
our cluster. But it doesn't mean that it will always be the best
option for your use-case. If you are running Kubernetes in the
cloud, you might consider using the cloud provider's logging
infrastructure (if it can be integrated with Kubernetes).

The deployment method that we will use here has been simplified:
there is only one ElasticSearch node. In a real deployment, you
might use a cluster, both for performance and reliability reasons.
But this is outside of the scope of this chapter.

The YAML file that we used creates all the resources in the
`default` namespace, for simplicity. In a real scenario, you will
create the resources in the `kube-system` namespace or in a dedicated namespace.

???

:EN:- Centralizing logs
:FR:- Centraliser les logs

.debug[[k8s/logs-centralized.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/logs-centralized.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-authentication-and-authorization
class: title

 Authentication and authorization

.nav[
[Previous part](#toc-centralized-logging)
|
[Back to table of contents](#toc-part-10)
|
[Next part](#toc-generating-user-certificates)
]

.debug[(automatically generated title slide)]

---
# Authentication and authorization

- In this section, we will:

  - define authentication and authorization

  - explain how they are implemented in Kubernetes

  - talk about tokens, certificates, service accounts, RBAC ...

- But first: why do we need all this?

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## The need for fine-grained security

- The Kubernetes API should only be available for identified users

  - we don't want "guest access" (except in very rare scenarios)

  - we don't want strangers to use our compute resources, delete our apps ...

  - our keys and passwords should not be exposed to the public

- Users will often have different access rights

  - cluster admin (similar to UNIX "root") can do everything

  - developer might access specific resources, or a specific namespace

  - supervision might have read only access to *most* resources

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Example: custom HTTP load balancer

- Let's imagine that we have a custom HTTP load balancer for multiple apps

- Each app has its own *Deployment* resource

- By default, the apps are "sleeping" and scaled to zero

- When a request comes in, the corresponding app gets woken up

- After some inactivity, the app is scaled down again

- This HTTP load balancer needs API access (to scale up/down)

- What if *a wild vulnerability appears*?

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Consequences of vulnerability

- If the HTTP load balancer has the same API access as we do:

  *full cluster compromise (easy data leak, cryptojacking...)*

- If the HTTP load balancer has `update` permissions on the Deployments:

  *defacement (easy), MITM / impersonation (medium to hard)*

- If the HTTP load balancer only has permission to `scale` the Deployments:

  *denial-of-service*

- All these outcomes are bad, but some are worse than others

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Definitions

- Authentication = verifying the identity of a person

  On a UNIX system, we can authenticate with login+password, SSH keys ...

- Authorization = listing what they are allowed to do

  On a UNIX system, this can include file permissions, sudoer entries ...

- Sometimes abbreviated as "authn" and "authz"

- In good modular systems, these things are decoupled

   (so we can e.g. change a password or SSH key without having to reset access rights)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authentication in Kubernetes

- When the API server receives a request, it tries to authenticate it

  (it examines headers, certificates... anything available)

- Many authentication methods are available and can be used simultaneously

  (we will see them on the next slide)

- It's the job of the authentication method to produce:

  - the user name
  - the user ID
  - a list of groups

- The API server doesn't interpret these; that'll be the job of *authorizers*

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authentication methods

- TLS client certificates

  (that's the default for clusters provisioned with `kubeadm`)

- Bearer tokens

  (a secret token in the HTTP headers of the request)

- [HTTP basic auth](https://en.wikipedia.org/wiki/Basic_access_authentication)

  (carrying user and password in an HTTP header; [deprecated since Kubernetes 1.19](https://github.com/kubernetes/kubernetes/pull/89069))

- Authentication proxy

  (sitting in front of the API and setting trusted headers)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Anonymous requests

- If any authentication method *rejects* a request, it's denied

  (`401 Unauthorized` HTTP code)

- If a request is neither rejected nor accepted by anyone, it's anonymous

  - the user name is `system:anonymous`

  - the list of groups is `[system:unauthenticated]`

- By default, the anonymous user can't do anything

  (that's what you get if you just `curl` the Kubernetes API)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authentication with TLS certificates

- Enabled in almost all Kubernetes deployments

- The user name is indicated by the `CN` in the client certificate

- The groups are indicated by the `O` fields in the client certificate

- From the point of view of the Kubernetes API, users do not exist

  (i.e. there is no resource with `kind: User`)

- The Kubernetes API can be set up to use your custom CA to validate client certs

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Authentication for kubelet

- In most clusters, kubelets authenticate using certificates

  (`O=system:nodes`, `CN=system:node:name-of-the-node`)

- The Kubernetes API can act as a CA

  (by wrapping an X509 CSR into a CertificateSigningRequest resource)

- This enables kubelets to renew their own certificates

- It can also be used to issue user certificates

  (but it lacks flexibility; e.g. validity can't be customized)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## User certificates in practice

- The Kubernetes API server does not support certificate revocation

  (see issue [#18982](https://github.com/kubernetes/kubernetes/issues/18982))

- As a result, we don't have an easy way to terminate someone's access

  (if their key is compromised, or they leave the organization)

- Issue short-lived certificates if you use them to authenticate users!

  (short-lived = a few hours)

- This can be facilitated by e.g. Vault, cert-manager...

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## What if a certificate is compromised?

- Option 1: wait for the certificate to expire

  (which is why short-lived certs are convenient!)

- Option 2: remove access from that certificate's user and groups

  - if that user was `bob.smith`, create a new user `bob.smith.2`

  - if Bob was in groups `dev`, create a new group `dev.2`

  - let's agree that this is not a great solution!

- Option 3: re-create a new CA and re-issue all certificates

  - let's agree that this is an even worse solution!

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authentication with tokens

- Tokens are passed as HTTP headers:

  `Authorization: Bearer and-then-here-comes-the-token`

- Tokens can be validated through a number of different methods:

  - static tokens hard-coded in a file on the API server

  - [bootstrap tokens](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/) (special case to create a cluster or join nodes)

  - [OpenID Connect tokens](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens) (to delegate authentication to compatible OAuth2 providers)

  - service accounts (these deserve more details, coming right up!)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Service accounts

- A service account is a user that exists in the Kubernetes API

  (it is visible with e.g. `kubectl get serviceaccounts`)

- Service accounts can therefore be created / updated dynamically

  (they don't require hand-editing a file and restarting the API server)

- A service account can be associated with a set of secrets

  (the kind that you can view with `kubectl get secrets`)

- Service accounts are generally used to grant permissions to applications, services...

  (as opposed to humans)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Service account tokens evolution

- In Kubernetes 1.21 and above, pods use *bound service account tokens*:

  - these tokens are *bound* to a specific object (e.g. a Pod)

  - they are automatically invalidated when the object is deleted

  - these tokens also expire quickly (e.g. 1 hour) and gets rotated automatically

- In Kubernetes 1.24 and above, unbound tokens aren't created automatically

  - before 1.24, we would see unbound tokens with `kubectl get secrets`

  - with 1.24 and above, these tokens can be created with `kubectl create token`

  - ...or with a Secret with the right [type and annotation][create-token]

[create-token]: https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#create-token

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Checking our authentication method

- Let's check our kubeconfig file

- Do we have a certificate, a token, or something else?

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Inspecting a certificate

If we have a certificate, let's use the following command:

```bash
kubectl config view \
        --raw \
        -o json \
        | jq -r .users[0].user[\"client-certificate-data\"] \
        | openssl base64 -d -A \
        | openssl x509 -text \
        | grep Subject:
```

This command will show the `CN` and `O` fields for our certificate.

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Breaking down the command

- `kubectl config view` shows the Kubernetes user configuration
- `--raw` includes certificate information (which shows as REDACTED otherwise)
- `-o json` outputs the information in JSON format
- `| jq ...` extracts the field with the user certificate (in base64)
- `| openssl base64 -d -A` decodes the base64 format (now we have a PEM file)
- `| openssl x509 -text` parses the certificate and outputs it as plain text
- `| grep Subject:` shows us the line that interests us

→ We are user `kubernetes-admin`, in group `system:masters`.

(We will see later how and why this gives us the permissions that we have.)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Inspecting a token

If we have a token, let's use the following command:

```bash
kubectl config view \
        --raw \
        -o json \
        | jq -r .users[0].user.token \
        | base64 -d \
        | cut -d. -f2 \
        | base64 -d \
        | jq .
```

If our token is a JWT / OIDC token, this command will show its content.

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Other authentication methods

- Other types of tokens

  - these tokens are typically shorter than JWT or OIDC tokens

  - it is generally not possible to extract information from them

- Plugins

  - some clusters use external `exec` plugins

  - these plugins typically use API keys to generate or obtain tokens

  - example: the AWS EKS authenticator works this way

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Token authentication in practice

- We are going to list existing service accounts

- Then we will extract the token for a given service account

- And we will use that token to authenticate with the API

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Listing service accounts

.lab[

- The resource name is `serviceaccount` or `sa` for short:
  ```bash
  kubectl get sa
  ```

]

There should be just one service account in the default namespace: `default`.

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Finding the secret

.lab[

- List the secrets for the `default` service account:
  ```bash
  kubectl get sa default -o yaml
  SECRET=$(kubectl get sa default -o json | jq -r .secrets[0].name)
  ```

]

It should be named `default-token-XXXXX`.

When running Kubernetes 1.24 and above, this Secret won't exist.
<br/>
Instead, create a token with `kubectl create token default`.

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Extracting the token

- The token is stored in the secret, wrapped with base64 encoding

.lab[

- View the secret:
  ```bash
  kubectl get secret $SECRET -o yaml
  ```

- Extract the token and decode it:
  ```bash
  TOKEN=$(kubectl get secret $SECRET -o json \
          | jq -r .data.token | openssl base64 -d -A)
  ```

]

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Using the token

- Let's send a request to the API, without and with the token

.lab[

- Find the ClusterIP for the `kubernetes` service:
  ```bash
  kubectl get svc kubernetes
  API=$(kubectl get svc kubernetes -o json | jq -r .spec.clusterIP)
  ```

- Connect without the token:
  ```bash
  curl -k https://$API
  ```

- Connect with the token:
  ```bash
  curl -k -H "Authorization: Bearer $TOKEN" https://$API
  ```

]

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Results

- In both cases, we will get a "Forbidden" error

- Without authentication, the user is `system:anonymous`

- With authentication, it is shown as `system:serviceaccount:default:default`

- The API "sees" us as a different user

- But neither user has any rights, so we can't do nothin'

- Let's change that!

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Authorization in Kubernetes

- There are multiple ways to grant permissions in Kubernetes, called [authorizers](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#authorization-modules):

  - [Node Authorization](https://kubernetes.io/docs/reference/access-authn-authz/node/) (used internally by kubelet; we can ignore it)

  - [Attribute-based access control](https://kubernetes.io/docs/reference/access-authn-authz/abac/) (powerful but complex and static; ignore it too)

  - [Webhook](https://kubernetes.io/docs/reference/access-authn-authz/webhook/) (each API request is submitted to an external service for approval)

  - [Role-based access control](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) (associates permissions to users dynamically)

- The one we want is the last one, generally abbreviated as RBAC

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Role-based access control

- RBAC allows to specify fine-grained permissions

- Permissions are expressed as *rules*

- A rule is a combination of:

  - [verbs](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb) like create, get, list, update, delete...

  - resources (as in "API resource," like pods, nodes, services...)

  - resource names (to specify e.g. one specific pod instead of all pods)

  - in some case, [subresources](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-resources) (e.g. logs are subresources of pods)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Listing all possible verbs

- The Kubernetes API is self-documented

- We can ask it which resources, subresources, and verb exist

- One way to do this is to use:

  - `kubectl get --raw /api/v1` (for core resources with `apiVersion: v1`)

  - `kubectl get --raw /apis/<group>/<version>` (for other resources)

- The JSON response can be formatted with e.g. `jq` for readability

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Examples

- List all verbs across all `v1` resources

  ```bash
  kubectl get --raw /api/v1 | jq -r .resources[].verbs[] | sort -u
  ```

- List all resources and subresources in `apps/v1`

  ```bash
  kubectl get --raw /apis/apps/v1 | jq -r .resources[].name
  ```

- List which verbs are available on which resources in `networking.k8s.io`

  ```bash
  kubectl get --raw /apis/networking.k8s.io/v1 | \
          jq -r '.resources[] | .name + ": " + (.verbs | join(", "))'
  ```

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## From rules to roles to rolebindings

- A *role* is an API object containing a list of *rules*

  Example: role "external-load-balancer-configurator" can:
  - [list, get] resources [endpoints, services, pods]
  - [update] resources [services]

- A *rolebinding* associates a role with a user

  Example: rolebinding "external-load-balancer-configurator":
  - associates user "external-load-balancer-configurator"
  - with role "external-load-balancer-configurator"

- Yes, there can be users, roles, and rolebindings with the same name

- It's a good idea for 1-1-1 bindings; not so much for 1-N ones

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Cluster-scope permissions

- API resources Role and RoleBinding are for objects within a namespace

- We can also define API resources ClusterRole and ClusterRoleBinding

- These are a superset, allowing us to:

  - specify actions on cluster-wide objects (like nodes)

  - operate across all namespaces

- We can create Role and RoleBinding resources within a namespace

- ClusterRole and ClusterRoleBinding resources are global

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Pods and service accounts

- A pod can be associated with a service account

  - by default, it is associated with the `default` service account

  - as we saw earlier, this service account has no permissions anyway

- The associated token is exposed to the pod's filesystem

  (in `/var/run/secrets/kubernetes.io/serviceaccount/token`)

- Standard Kubernetes tooling (like `kubectl`) will look for it there

- So Kubernetes tools running in a pod will automatically use the service account

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## In practice

- We are going to run a pod

- This pod will use the default service account of its namespace

- We will check our API permissions

  (there shouldn't be any)

- Then we will bind a role to the service account

- We will check that we were granted the corresponding permissions

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Running a pod

- We'll use [Nixery](https://nixery.dev/) to run a pod with `curl` and `kubectl`

- Nixery automatically generates images with the requested packages

.lab[

- Run our pod:
  ```bash
  kubectl run eyepod --rm -ti --restart=Never \
          --image nixery.dev/shell/curl/kubectl -- bash
  ```

]

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Checking our permissions

- Normally, at this point, we don't have any API permission

.lab[

- Check our permissions with `kubectl`:
  ```bash
  kubectl get pods
  ```

]

- We should get a message telling us that our service account
  doesn't have permissions to list "pods" in the current namespace

- We can also make requests to the API server directly

  (use `kubectl -v6` to see the exact request URI!)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Binding a role to the service account

- Binding a role = creating a *rolebinding* object

- We will call that object `can-view`

  (but again, we could call it `view` or whatever we like)

.lab[

- Create the new role binding:
  ```bash
  kubectl create rolebinding can-view \
          --clusterrole=view \
          --serviceaccount=default:default
  ```

]

It's important to note a couple of details in these flags...

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Roles vs Cluster Roles

- We used `--clusterrole=view`

- What would have happened if we had used `--role=view`?

  - we would have bound the role `view` from the local namespace
    <br/>(instead of the cluster role `view`)

  - the command would have worked fine (no error)

  - but later, our API requests would have been denied

- This is a deliberate design decision

  (we can reference roles that don't exist, and create/update them later)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Users vs Service Accounts

- We used `--serviceaccount=default:default`

- What would have happened if we had used `--user=default:default`?

  - we would have bound the role to a user instead of a service account

  - again, the command would have worked fine (no error)

  - ...but our API requests would have been denied later

- What's about the `default:` prefix?

  - that's the namespace of the service account

  - yes, it could be inferred from context, but... `kubectl` requires it

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## Checking our new permissions

- We should be able to *view* things, but not to *edit* them

.lab[

- Check our permissions with `kubectl`:
  ```bash
  kubectl get pods
  ```

- Try to create something:
  ```bash
  kubectl create deployment can-i-do-this --image=nginx
  ```

- Exit the container with `exit` or `^D`

<!-- ```key ^D``` -->

]

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## `kubectl run --serviceaccount`

- `kubectl run` also has a `--serviceaccount` flag

- ...But it's supposed to be deprecated "soon"

  (see [kubernetes/kubernetes#99732](https://github.com/kubernetes/kubernetes/pull/99732) for details)

- It's possible to specify the service account with an override:
  ```bash
  kubectl run my-pod -ti --image=alpine --restart=Never \
          --overrides='{ "spec": { "serviceAccountName" : "my-service-account" } }'
  ```

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `kubectl auth` and other CLI tools

- The `kubectl auth can-i` command can tell us:

  - if we can perform an action

  - if someone else can perform an action

  - what actions we can perform

- There are also other very useful tools to work with RBAC

- Let's do a quick review!

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `kubectl auth can-i dothis onthat`

- These commands will give us a `yes`/`no` answer:

  ```bash
  kubectl auth can-i list nodes
  kubectl auth can-i create pods
  kubectl auth can-i get pod/name-of-pod
  kubectl auth can-i get /url-fragment-of-api-request/
  kubectl auth can-i '*' services
  kubectl auth can-i get coffee
  kubectl auth can-i drink coffee
  ```

- The RBAC system is flexible

- We can check permissions on resources that don't exist yet (e.g. CRDs)

- We can check permissions for arbitrary actions

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `kubectl auth can-i ... --as someoneelse`

- We can check permissions on behalf of other users

  ```bash
  kubectl auth can-i list nodes \
          --as some-user
  kubectl auth can-i list nodes \
          --as system:serviceaccount:<namespace>:<name-of-service-account>
  ```

- We can also use `--as-group` to check permissions for members of a group

- `--as` and `--as-group` leverage the *impersonation API*

- These flags can be used with many other `kubectl` commands

  (not just `auth can-i`)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `kubectl auth can-i --list`

- We can list the actions that are available to us:

  ```bash
  kubectl auth can-i --list
  ```

- ... Or to someone else (with `--as SomeOtherUser`)

- This is very useful to check users or service accounts for overly broad permissions

  (or when looking for ways to exploit a security vulnerability!)

- To learn more about Kubernetes attacks and threat models around RBAC:

  📽️ [Hacking into Kubernetes Security for Beginners](https://www.youtube.com/watch?v=mLsCm9GVIQg)
  by [V Körbes](https://twitter.com/veekorbes)
  and [Tabitha Sable](https://twitter.com/TabbySable)

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Other useful tools

- For auditing purposes, sometimes we want to know who can perform which actions

- There are a few tools to help us with that, available as `kubectl` plugins:

  - `kubectl who-can` / [kubectl-who-can](https://github.com/aquasecurity/kubectl-who-can) by Aqua Security

  - `kubectl access-matrix` / [Rakkess (Review Access)](https://github.com/corneliusweig/rakkess) by Cornelius Weig

  - `kubectl rbac-lookup` / [RBAC Lookup](https://github.com/FairwindsOps/rbac-lookup) by FairwindsOps

  - `kubectl rbac-tool` / [RBAC Tool](https://github.com/alcideio/rbac-tool) by insightCloudSec

- `kubectl` plugins can be installed and managed with `krew`

- They can also be installed and executed as standalone programs

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Where does this `view` role come from?

- Kubernetes defines a number of ClusterRoles intended to be bound to users

- `cluster-admin` can do *everything* (think `root` on UNIX)

- `admin` can do *almost everything* (except e.g. changing resource quotas and limits)

- `edit` is similar to `admin`, but cannot view or edit permissions

- `view` has read-only access to most resources, except permissions and secrets

*In many situations, these roles will be all you need.*

*You can also customize them!*

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Customizing the default roles

- If you need to *add* permissions to these default roles (or others),
  <br/>
  you can do it through the [ClusterRole Aggregation](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#aggregated-clusterroles) mechanism

- This happens by creating a ClusterRole with the following labels:
  ```yaml
    metadata:
      labels:
        rbac.authorization.k8s.io/aggregate-to-admin: "true"
        rbac.authorization.k8s.io/aggregate-to-edit: "true"
        rbac.authorization.k8s.io/aggregate-to-view: "true"
  ```

- This ClusterRole permissions will be added to `admin`/`edit`/`view` respectively

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## When should we use aggregation?

- By default, CRDs aren't included in `view` / `edit` / etc.

  (Kubernetes cannot guess which one are security sensitive and which ones are not)

- If we edit `view` / `edit` / etc directly, our edits will conflict

  (imagine if we have two CRDs and they both provide a custom `view` ClusterRole)

- Using aggregated roles lets us enrich the default roles without touching them

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## How aggregation works

- The corresponding roles will have `aggregationRules` like this:

   ```yaml
    aggregationRule:
      clusterRoleSelectors:
      - matchLabels:
          rbac.authorization.k8s.io/aggregate-to-view: "true"
   ```

- We can define our own custom roles with their own aggregation rules

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## Where do our permissions come from?

- When interacting with the Kubernetes API, we are using a client certificate

- We saw previously that this client certificate contained:

  `CN=kubernetes-admin` and `O=system:masters`

- Let's look for these in existing ClusterRoleBindings:
  ```bash
  kubectl get clusterrolebindings -o yaml |
    grep -e kubernetes-admin -e system:masters
  ```

  (`system:masters` should show up, but not `kubernetes-admin`.)

- Where does this match come from?

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: extra-details

## The `system:masters` group

- If we eyeball the output of `kubectl get clusterrolebindings -o yaml`, we'll find out!

- It is in the `cluster-admin` binding:
  ```bash
  kubectl describe clusterrolebinding cluster-admin
  ```

- This binding associates `system:masters` with the cluster role `cluster-admin`

- And the `cluster-admin` is, basically, `root`:
  ```bash
  kubectl describe clusterrole cluster-admin
  ```

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

## `list` vs. `get`

⚠️ `list` grants read permissions to resources!

- It's not possible to give permission to list resources without also reading them

- This has implications for e.g. Secrets

  (if a controller needs to be able to enumerate Secrets, it will be able to read them)

???

:EN:- Authentication and authorization in Kubernetes
:EN:- Authentication with tokens and certificates
:EN:- Authorization with RBAC (Role-Based Access Control)
:EN:- Restricting permissions with Service Accounts
:EN:- Working with Roles, Cluster Roles, Role Bindings, etc.

:FR:- Identification et droits d'accès dans Kubernetes
:FR:- Mécanismes d'identification par jetons et certificats
:FR:- Le modèle RBAC *(Role-Based Access Control)*
:FR:- Restreindre les permissions grâce aux *Service Accounts*
:FR:- Comprendre les *Roles*, *Cluster Roles*, *Role Bindings*, etc.

.debug[[k8s/authn-authz.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/authn-authz.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-generating-user-certificates
class: title

 Generating user certificates

.nav[
[Previous part](#toc-authentication-and-authorization)
|
[Back to table of contents](#toc-part-10)
|
[Next part](#toc-the-csr-api)
]

.debug[(automatically generated title slide)]

---
# Generating user certificates

- The most popular ways to authenticate users with Kubernetes are:

  - TLS certificates

  - JSON Web Tokens (OIDC or ServiceAccount tokens)

- We're going to see how to use TLS certificates

- We will generate a certificate for an user and give them some permissions

- Then we will use that certificate to access the cluster

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## Heads up!

- The demos in this section require that we have access to our cluster's CA

- This is easy if we are using a cluster deployed with `kubeadm`

- Otherwise, we may or may not have access to the cluster's CA

- We may or may not be able to use the CSR API instead

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## Check that we have access to the CA

- Make sure that you are logged on the node hosting the control plane

  (if a cluster has been provisioned for you for a training, it's `node1`)

.lab[

- Check that the CA key is here:
  ```bash
  sudo ls -l /etc/kubernetes/pki
  ```

]

The output should include `ca.key` and `ca.crt`.

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## How it works

- The API server is configured to accept all certificates signed by a given CA

- The certificate contains:

  - the user name (in the `CN` field)

  - the groups the user belongs to (as multiple `O` fields)

.lab[

- Check which CA is used by the Kubernetes API server:
  ```bash
  sudo grep crt /etc/kubernetes/manifests/kube-apiserver.yaml
  ```

]

This is the flag that we're looking for:
```
--client-ca-file=/etc/kubernetes/pki/ca.crt
```

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## Generating a key and CSR for our user

- These operations could be done on a separate machine

- We only need to transfer the CSR (Certificate Signing Request) to the CA

  (we never need to expoes the private key)

.lab[

- Generate a private key:
  ```bash
  openssl genrsa 4096 > user.key
  ```

- Generate a CSR:
  ```bash
  openssl req -new -key user.key -subj /CN=jerome/O=devs/O=ops > user.csr
  ```

]

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## Generating a signed certificate

- This has to be done on the machine holding the CA private key

  (copy the `user.csr` file if needed)

.lab[

- Verify the CSR paramters:
  ```bash
  openssl req -in user.csr  -text | head
  ```

- Generate the certificate:
  ```bash
  sudo openssl x509 -req \
      -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key \
      -in user.csr -days 1 -set_serial 1234 > user.crt
  ```

]

If you are using two separate machines, transfer `user.crt` to the other machine.

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## Adding the key and certificate to kubeconfig

- We have to edit our `.kube/config` file

- This can be done relatively easily with `kubectl config`

.lab[

- Create a new `user` entry in our `.kube/config` file:
  ```bash
  kubectl config set-credentials jerome \
      --client-key=user.key --client-certificate=user.crt 
  ```

]

The configuration file now points to our local files.

We could also embed the key and certs with the `--embed-certs` option.

(So that the kubeconfig file can be used without `user.key` and `user.crt`.)

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## Using the new identity

- At the moment, we probably use the admin certificate generated by `kubeadm`

  (with `CN=kubernetes-admin` and `O=system:masters`)

- Let's edit our *context* to use our new certificate instead!

.lab[

- Edit the context:
  ```bash
  kubectl config set-context --current --user=jerome 
  ```

- Try any command:
  ```bash
  kubectl get pods
  ```

]

Access will be denied, but we should see that were correctly *authenticated* as `jerome`.

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## Granting permissions

- Let's add some read-only permissions to the `devs` group (for instance)

.lab[

- Switch back to our admin identity:
  ```bash
  kubectl config set-context --current --user=kubernetes-admin 
  ```

- Grant permissions:
  ```bash
  kubectl create clusterrolebinding devs-can-view \
      --clusterrole=view --group=devs
  ```

]

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

## Testing the new permissions

- As soon as we create the ClusterRoleBinding, all users in the `devs` group get access

- Let's verify that we can e.g. list pods!

.lab[

- Switch to our user identity again:
  ```bash
  kubectl config set-context --current --user=jerome
  ```

- Test the permissions:
  ```bash
  kubectl get pods
  ```

]

???

:EN:- Authentication with user certificates
:FR:- Identification par certificat TLS

.debug[[k8s/user-cert.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/user-cert.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-the-csr-api
class: title

 The CSR API

.nav[
[Previous part](#toc-generating-user-certificates)
|
[Back to table of contents](#toc-part-10)
|
[Next part](#toc-openid-connect)
]

.debug[(automatically generated title slide)]

---
# The CSR API

- The Kubernetes API exposes CSR resources

- We can use these resources to issue TLS certificates

- First, we will go through a quick reminder about TLS certificates

- Then, we will see how to obtain a certificate for a user

- We will use that certificate to authenticate with the cluster

- Finally, we will grant some privileges to that user

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Reminder about TLS

- TLS (Transport Layer Security) is a protocol providing:

  - encryption (to prevent eavesdropping)

  - authentication (using public key cryptography)

- When we access an https:// URL, the server authenticates itself

  (it proves its identity to us; as if it were "showing its ID")

- But we can also have mutual TLS authentication (mTLS)

  (client proves its identity to server; server proves its identity to client)

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Authentication with certificates

- To authenticate, someone (client or server) needs:

  - a *private key* (that remains known only to them)

  - a *public key* (that they can distribute)

  - a *certificate* (associating the public key with an identity)

- A message encrypted with the private key can only be decrypted with the public key

  (and vice versa)

- If I use someone's public key to encrypt/decrypt their messages,
  <br/>
  I can be certain that I am talking to them / they are talking to me

- The certificate proves that I have the correct public key for them

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Certificate generation workflow

This is what I do if I want to obtain a certificate.

1. Create public and private keys.

2. Create a Certificate Signing Request (CSR).

   (The CSR contains the identity that I claim and a public key.)

3. Send that CSR to the Certificate Authority (CA).

4. The CA verifies that I can claim the identity in the CSR.

5. The CA generates my certificate and gives it to me.

The CA (or anyone else) never needs to know my private key.

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## The CSR API

- The Kubernetes API has a CertificateSigningRequest resource type

  (we can list them with e.g. `kubectl get csr`)

- We can create a CSR object

  (= upload a CSR to the Kubernetes API)

- Then, using the Kubernetes API, we can approve/deny the request

- If we approve the request, the Kubernetes API generates a certificate

- The certificate gets attached to the CSR object and can be retrieved

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Using the CSR API

- We will show how to use the CSR API to obtain user certificates

- This will be a rather complex demo

- ... And yet, we will take a few shortcuts to simplify it

  (but it will illustrate the general idea)

- The demo also won't be automated

  (we would have to write extra code to make it fully functional)

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Warning

- The CSR API isn't really suited to issue user certificates

- It is primarily intended to issue control plane certificates

  (for instance, deal with kubelet certificates renewal)

- The API was expanded a bit in Kubernetes 1.19 to encompass broader usage

- There are still lots of gaps in the spec

  (e.g. how to specify expiration in a standard way)

- ... And no other implementation to this date

  (but [cert-manager](https://cert-manager.io/docs/faq/#kubernetes-has-a-builtin-certificatesigningrequest-api-why-not-use-that) might eventually get there!)

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## General idea

- We will create a Namespace named "users"

- Each user will get a ServiceAccount in that Namespace

- That ServiceAccount will give read/write access to *one* CSR object

- Users will use that ServiceAccount's token to submit a CSR

- We will approve the CSR (or not)

- Users can then retrieve their certificate from their CSR object

- ...And use that certificate for subsequent interactions

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Resource naming

For a user named `jean.doe`, we will have:

- ServiceAccount `jean.doe` in Namespace `users`

- CertificateSigningRequest `user=jean.doe`

- ClusterRole `user=jean.doe` giving read/write access to that CSR

- ClusterRoleBinding `user=jean.doe` binding ClusterRole and ServiceAccount

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

class: extra-details

## About resource name constraints

- Most Kubernetes identifiers and names are fairly restricted

- They generally are DNS-1123 *labels* or *subdomains* (from [RFC 1123](https://tools.ietf.org/html/rfc1123))

- A label is lowercase letters, numbers, dashes; can't start or finish with a dash

- A subdomain is one or multiple labels separated by dots

- Some resources have more relaxed constraints, and can be "path segment names"

  (uppercase are allowed, as well as some characters like `#:?!,_`)

- This includes RBAC objects (like Roles, RoleBindings...) and CSRs

- See the [Identifiers and Names](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/identifiers.md) design document and the [Object Names and IDs](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#path-segment-names) documentation page for more details

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Creating the user's resources

.warning[If you want to use another name than `jean.doe`, update the YAML file!]

.lab[

- Create the global namespace for all users:
  ```bash
  kubectl create namespace users
  ```

- Create the ServiceAccount, ClusterRole, ClusterRoleBinding for `jean.doe`:
  ```bash
  kubectl apply -f ~/container.training/k8s/user=jean.doe.yaml
  ```

]

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Extracting the user's token

- Let's obtain the user's token and give it to them

  (the token will be their password)

.lab[

- List the user's secrets:
  ```bash
  kubectl --namespace=users describe serviceaccount jean.doe
  ```

- Show the user's token:
  ```bash
  kubectl --namespace=users describe secret `jean.doe-token-xxxxx`
  ```

]

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Configure `kubectl` to use the token

- Let's create a new context that will use that token to access the API

.lab[

- Add a new identity to our kubeconfig file:
  ```bash
  kubectl config set-credentials token:jean.doe --token=...
  ```

- Add a new context using that identity:
  ```bash
  kubectl config set-context jean.doe --user=token:jean.doe --cluster=`kubernetes`
  ```
  (Make sure to adapt the cluster name if yours is different!)

- Use that context:
  ```bash
  kubectl config use-context jean.doe
  ```

]

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Access the API with the token

- Let's check that our access rights are set properly

.lab[

- Try to access any resource:
  ```bash
  kubectl get pods
  ```
  (This should tell us "Forbidden")

- Try to access "our" CertificateSigningRequest:
  ```bash
  kubectl get csr user=jean.doe
  ```
  (This should tell us "NotFound")

]

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Create a key and a CSR

- There are many tools to generate TLS keys and CSRs

- Let's use OpenSSL; it's not the best one, but it's installed everywhere

  (many people prefer cfssl, easyrsa, or other tools; that's fine too!)

.lab[

- Generate the key and certificate signing request:
  ```bash
    openssl req -newkey rsa:2048 -nodes -keyout key.pem \
                -new -subj /CN=jean.doe/O=devs/ -out csr.pem
  ```

]

The command above generates:

- a 2048-bit RSA key, without encryption, stored in key.pem
- a CSR for the name `jean.doe` in group `devs`

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Inside the Kubernetes CSR object

- The Kubernetes CSR object is a thin wrapper around the CSR PEM file

- The PEM file needs to be encoded to base64 on a single line

  (we will use `base64 -w0` for that purpose)

- The Kubernetes CSR object also needs to list the right "usages"

  (these are flags indicating how the certificate can be used)

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Sending the CSR to Kubernetes

.lab[

- Generate and create the CSR resource:
  ```bash
    kubectl apply -f - <<EOF
    apiVersion: certificates.k8s.io/v1
    kind: CertificateSigningRequest
    metadata:
      name: user=jean.doe
    spec:
      request: $(base64 -w0 < csr.pem)
      signerName: kubernetes.io/kube-apiserver-client
      usages:
      - digital signature
      - key encipherment
      - client auth
    EOF
  ```

]

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Adjusting certificate expiration

- By default, the CSR API generates certificates valid 1 year

- We want to generate short-lived certificates, so we will lower that to 1 hour

- Fow now, this is configured [through an experimental controller manager flag](https://github.com/kubernetes/kubernetes/issues/67324)

.lab[

- Edit the static pod definition for the controller manager:
  ```bash
  sudo vim /etc/kubernetes/manifests/kube-controller-manager.yaml
  ```

- In the list of flags, add the following line:
  ```bash
  - --experimental-cluster-signing-duration=1h
  ```

]

*Kubernetes 1.22 supports a new `spec.expirationSeconds` field.*

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Verifying and approving the CSR

- Let's inspect the CSR, and if it is valid, approve it

.lab[

- Switch back to `cluster-admin`:
  ```bash
  kctx -
  ```

- Inspect the CSR:
  ```bash
  kubectl describe csr user=jean.doe
  ```

- Approve it:
  ```bash
  kubectl certificate approve user=jean.doe
  ```

]

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Obtaining the certificate

.lab[

- Switch back to the user's identity:
  ```bash
  kctx -
  ```

- Retrieve the updated CSR object and extract the certificate:
  ```bash
  kubectl get csr user=jean.doe \
          -o jsonpath={.status.certificate} \
          | base64 -d > cert.pem
  ```

- Inspect the certificate:
  ```bash
  openssl x509 -in cert.pem -text -noout
  ```

]

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Using the certificate

.lab[

- Add the key and certificate to kubeconfig:
  ```bash
  kubectl config set-credentials cert:jean.doe --embed-certs \
          --client-certificate=cert.pem --client-key=key.pem
  ```

- Update the user's context to use the key and cert to authenticate:
  ```bash
  kubectl config set-context jean.doe --user cert:jean.doe
  ```

- Confirm that we are seen as `jean.doe` (but don't have permissions):
  ```bash
  kubectl get pods
  ```

]

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## What's missing?

We have just shown, step by step, a method to issue short-lived certificates for users.

To be usable in real environments, we would need to add:

- a kubectl helper to automatically generate the CSR and obtain the cert

  (and transparently renew the cert when needed)

- a Kubernetes controller to automatically validate and approve CSRs

  (checking that the subject and groups are valid)

- a way for the users to know the groups to add to their CSR

  (e.g.: annotations on their ServiceAccount + read access to the ServiceAccount)

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

## Is this realistic?

- Larger organizations typically integrate with their own directory

- The general principle, however, is the same:

  - users have long-term credentials (password, token, ...)

  - they use these credentials to obtain other, short-lived credentials

- This provides enhanced security:

  - the long-term credentials can use long passphrases, 2FA, HSM...

  - the short-term credentials are more convenient to use

  - we get strong security *and* convenience

- Systems like Vault also have certificate issuance mechanisms

???

:EN:- Generating user certificates with the CSR API
:FR:- Génération de certificats utilisateur avec la CSR API

.debug[[k8s/csr-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/csr-api.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-openid-connect
class: title

 OpenID Connect

.nav[
[Previous part](#toc-the-csr-api)
|
[Back to table of contents](#toc-part-11)
|
[Next part](#toc-securing-the-control-plane)
]

.debug[(automatically generated title slide)]

---
# OpenID Connect

- The Kubernetes API server can perform authentication with OpenID connect

- This requires an *OpenID provider*

  (external authorization server using the OAuth 2.0 protocol)

- We can use a third-party provider (e.g. Google) or run our own (e.g. Dex)

- We are going to give an overview of the protocol

- We will show it in action (in a simplified scenario)

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Workflow overview

- We want to access our resources (a Kubernetes cluster)

- We authenticate with the OpenID provider

  - we can do this directly (e.g. by going to https://accounts.google.com)

  - or maybe a kubectl plugin can open a browser page on our behalf

- After authenticating us, the OpenID provider gives us:

  - an *id token* (a short-lived signed JSON Web Token, see next slide)

  - a *refresh token* (to renew the *id token* when needed)

- We can now issue requests to the Kubernetes API with the *id token*

- The API server will verify that token's content to authenticate us

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## JSON Web Tokens

- A JSON Web Token (JWT) has three parts:

  - a header specifying algorithms and token type

  - a payload (indicating who issued the token, for whom, which purposes...)

  - a signature generated by the issuer (the issuer = the OpenID provider)

- Anyone can verify a JWT without contacting the issuer

  (except to obtain the issuer's public key)

- Pro tip: we can inspect a JWT with https://jwt.io/

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## How the Kubernetes API uses JWT

- Server side

  - enable OIDC authentication

  - indicate which issuer (provider) should be allowed

  - indicate which audience (or "client id") should be allowed

  - optionally, map or prefix user and group names

- Client side

  - obtain JWT as described earlier

  - pass JWT as authentication token

  - renew JWT when needed (using the refresh token)

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Demo time!

- We will use [Google Accounts](https://accounts.google.com) as our OpenID provider

- We will use the [Google OAuth Playground](https://developers.google.com/oauthplayground) as the "audience" or "client id"

- We will obtain a JWT through Google Accounts and the OAuth Playground

- We will enable OIDC in the Kubernetes API server

- We will use the JWT to authenticate

.footnote[If you can't or won't use a Google account, you can try to adapt this to another provider.]

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Checking the API server logs

- The API server logs will be particularly useful in this section

  (they will indicate e.g. why a specific token is rejected)

- Let's keep an eye on the API server output!

.lab[

- Tail the logs of the API server:
  ```bash
  kubectl logs kube-apiserver-node1 --follow --namespace=kube-system
  ```

]

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Authenticate with the OpenID provider

- We will use the Google OAuth Playground for convenience

- In a real scenario, we would need our own OAuth client instead of the playground

  (even if we were still using Google as the OpenID provider)

.lab[

- Open the Google OAuth Playground:
  ```
  https://developers.google.com/oauthplayground/
  ```

- Enter our own custom scope in the text field:
  ```
  https://www.googleapis.com/auth/userinfo.email
  ```

- Click on "Authorize APIs" and allow the playground to access our email address

]

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Obtain our JSON Web Token

- The previous step gave us an "authorization code"

- We will use it to obtain tokens

.lab[

- Click on "Exchange authorization code for tokens"

]

- The JWT is the very long `id_token` that shows up on the right hand side

  (it is a base64-encoded JSON object, and should therefore start with `eyJ`)

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Using our JSON Web Token

- We need to create a context (in kubeconfig) for our token

  (if we just add the token or use `kubectl --token`, our certificate will still be used)

.lab[

- Create a new authentication section in kubeconfig:
  ```bash
  kubectl config set-credentials myjwt --token=eyJ...
  ```

- Try to use it:
  ```bash
  kubectl --user=myjwt get nodes
  ```

]

We should get an `Unauthorized` response, since we haven't enabled OpenID Connect in the API server yet. We should also see `invalid bearer token` in the API server log output.

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Enabling OpenID Connect

- We need to add a few flags to the API server configuration

- These two are mandatory:

  `--oidc-issuer-url` → URL of the OpenID provider

  `--oidc-client-id` → app requesting the authentication
  <br/>(in our case, that's the ID for the Google OAuth Playground)

- This one is optional:

  `--oidc-username-claim` → which field should be used as user name
  <br/>(we will use the user's email address instead of an opaque ID)

- See the [API server documentation](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#configuring-the-api-server
) for more details about all available flags

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Updating the API server configuration

- The instructions below will work for clusters deployed with kubeadm

  (or where the control plane is deployed in static pods)

- If your cluster is deployed differently, you will need to adapt them

.lab[

- Edit `/etc/kubernetes/manifests/kube-apiserver.yaml`

- Add the following lines to the list of command-line flags:
  ```yaml
  - --oidc-issuer-url=https://accounts.google.com
  - --oidc-client-id=407408718192.apps.googleusercontent.com
  - --oidc-username-claim=email
  ```
]

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Restarting the API server

- The kubelet monitors the files in `/etc/kubernetes/manifests`

- When we save the pod manifest, kubelet will restart the corresponding pod

  (using the updated command line flags)

.lab[

- After making the changes described on the previous slide, save the file

- Issue a simple command (like `kubectl version`) until the API server is back up

  (it might take between a few seconds and one minute for the API server to restart)

- Restart the `kubectl logs` command to view the logs of the API server

]

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Using our JSON Web Token

- Now that the API server is set up to recognize our token, try again!

.lab[

- Try an API command with our token:
  ```bash
  kubectl --user=myjwt get nodes
  kubectl --user=myjwt get pods
  ```

]

We should see a message like:
```
Error from server (Forbidden): nodes is forbidden: User "jean.doe@gmail.com"
cannot list resource "nodes" in API group "" at the cluster scope
```

→ We were successfully *authenticated*, but not *authorized*.

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## Authorizing our user

- As an extra step, let's grant read access to our user

- We will use the pre-defined ClusterRole `view`

.lab[

- Create a ClusterRoleBinding allowing us to view resources:
  ```bash
    kubectl create clusterrolebinding i-can-view \
            --user=`jean.doe@gmail.com` --clusterrole=view
  ```

  (make sure to put *your* Google email address there)

- Confirm that we can now list pods with our token:
   ```bash
  kubectl --user=myjwt get pods
  ```

]

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

## From demo to production

.warning[This was a very simplified demo! In a real deployment...]

- We wouldn't use the Google OAuth Playground

- We *probably* wouldn't even use Google at all

  (it doesn't seem to provide a way to include groups!)

- Some popular alternatives:

  - [Dex](https://github.com/dexidp/dex),
    [Keycloak](https://www.keycloak.org/)
    (self-hosted)

  - [Okta](https://developer.okta.com/docs/how-to/creating-token-with-groups-claim/#step-five-decode-the-jwt-to-verify)
    (SaaS)

- We would use a helper (like the [kubelogin](https://github.com/int128/kubelogin) plugin) to automatically obtain tokens

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

class: extra-details

## Service Account tokens

- The tokens used by Service Accounts are JWT tokens as well

- They are signed and verified using a special service account key pair

.lab[

- Extract the token of a service account in the current namespace:
  ```bash
  kubectl get secrets -o jsonpath={..token} | base64 -d
  ```

- Copy-paste the token to a verification service like https://jwt.io 

- Notice that it says "Invalid Signature"

]

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

class: extra-details

## Verifying Service Account tokens

- JSON Web Tokens embed the URL of the "issuer" (=OpenID provider)

- The issuer provides its public key through a well-known discovery endpoint

  (similar to https://accounts.google.com/.well-known/openid-configuration)

- There is no such endpoint for the Service Account key pair

- But we can provide the public key ourselves for verification

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

class: extra-details

## Verifying a Service Account token

- On clusters provisioned with kubeadm, the Service Account key pair is:

  `/etc/kubernetes/pki/sa.key` (used by the controller manager to generate tokens)

  `/etc/kubernetes/pki/sa.pub` (used by the API server to validate the same tokens)

.lab[

- Display the public key used to sign Service Account tokens:
  ```bash
  sudo cat /etc/kubernetes/pki/sa.pub
  ```

- Copy-paste the key in the "verify signature" area on https://jwt.io

- It should now say "Signature Verified"

]

???

:EN:- Authenticating with OIDC
:FR:- S'identifier avec OIDC

.debug[[k8s/openid-connect.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openid-connect.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-1.jpg)]

---

name: toc-securing-the-control-plane
class: title

 Securing the control plane

.nav[
[Previous part](#toc-openid-connect)
|
[Back to table of contents](#toc-part-11)
|
[Next part](#toc-network-policies)
]

.debug[(automatically generated title slide)]

---
# Securing the control plane

- Many components accept connections (and requests) from others:

  - API server

  - etcd

  - kubelet

- We must secure these connections:

  - to deny unauthorized requests

  - to prevent eavesdropping secrets, tokens, and other sensitive information

- Disabling authentication and/or authorization is **strongly discouraged**

  (but it's possible to do it, e.g. for learning / troubleshooting purposes)

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## Authentication and authorization

- Authentication (checking "who you are") is done with mutual TLS

 (both the client and the server need to hold a valid certificate)

- Authorization (checking "what you can do") is done in different ways

  - the API server implements a sophisticated permission logic (with RBAC)
  
  - some services will defer authorization to the API server (through webhooks)

  - some services require a certificate signed by a particular CA / sub-CA

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## In practice

- We will review the various communication channels in the control plane

- We will describe how they are secured

- When TLS certificates are used, we will indicate:

  - which CA signs them

  - what their subject (CN) should be, when applicable

- We will indicate how to configure security (client- and server-side)

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## etcd peers

- Replication and coordination of etcd happens on a dedicated port

  (typically port 2380; the default port for normal client connections is 2379)

- Authentication uses TLS certificates with a separate sub-CA

  (otherwise, anyone with a Kubernetes client certificate could access etcd!)

- The etcd command line flags involved are:

   `--peer-client-cert-auth=true` to activate it

   `--peer-cert-file`, `--peer-key-file`, `--peer-trusted-ca-file`

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## etcd clients

- The only¹ thing that connects to etcd is the API server

- Authentication uses TLS certificates with a separate sub-CA

  (for the same reasons as for etcd inter-peer authentication)

- The etcd command line flags involved are:

  `--client-cert-auth=true` to activate it

  `--trusted-ca-file`, `--cert-file`, `--key-file`

- The API server command line flags involved are:

  `--etcd-cafile`, `--etcd-certfile`, `--etcd-keyfile`

.footnote[¹Technically, there is also the etcd healthcheck. Let's ignore it for now.]

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## etcd authorization

- etcd supports RBAC, but Kubernetes doesn't use it by default

  (note: etcd RBAC is completely different from Kubernetes RBAC!)

- By default, etcd access is "all or nothing"

  (if you have a valid certificate, you get in)

- Be very careful if you use the same root CA for etcd and other things

  (if etcd trusts the root CA, then anyone with a valid cert gets full etcd access)

- For more details, check the following resources:

  - [etcd documentation on authentication](https://etcd.io/docs/current/op-guide/authentication/)

  - [PKI The Wrong Way](https://www.youtube.com/watch?v=gcOLDEzsVHI) at KubeCon NA 2020

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---


## API server clients

- The API server has a sophisticated authentication and authorization system

- For connections coming from other components of the control plane:

  - authentication uses certificates (trusting the certificates' subject or CN)

  - authorization uses whatever mechanism is enabled (most oftentimes, RBAC)

- The relevant API server flags are:

  `--client-ca-file`, `--tls-cert-file`, `--tls-private-key-file`

- Each component connecting to the API server takes a `--kubeconfig` flag

  (to specify a kubeconfig file containing the CA cert, client key, and client cert)

- Yes, that kubeconfig file follows the same format as our `~/.kube/config` file!

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## Kubelet and API server

- Communication between kubelet and API server can be established both ways

- Kubelet → API server:

  - kubelet registers itself ("hi, I'm node42, do you have work for me?")

  - connection is kept open and re-established if it breaks

  - that's how the kubelet knows which pods to start/stop

- API server → kubelet:

  - used to retrieve logs, exec, attach to containers

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## Kubelet → API server

- Kubelet is started with `--kubeconfig` with API server information

- The client certificate of the kubelet will typically have:

  `CN=system:node:<nodename>` and groups `O=system:nodes`

- Nothing special on the API server side

  (it will authenticate like any other client)

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## API server → kubelet

- Kubelet is started with the flag `--client-ca-file`

  (typically using the same CA as the API server)

- API server will use a dedicated key pair when contacting kubelet

  (specified with `--kubelet-client-certificate` and `--kubelet-client-key`)

- Authorization uses webhooks

  (enabled with `--authorization-mode=Webhook` on kubelet)

- The webhook server is the API server itself

  (the kubelet sends back a request to the API server to ask, "can this person do that?")

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## Scheduler

- The scheduler connects to the API server like an ordinary client

- The certificate of the scheduler will have `CN=system:kube-scheduler`

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## Controller manager

- The controller manager is also a normal client to the API server

- Its certificate will have `CN=system:kube-controller-manager`

- If we use the CSR API, the controller manager needs the CA cert and key

  (passed with flags `--cluster-signing-cert-file` and `--cluster-signing-key-file`)

- We usually want the controller manager to generate tokens for service accounts

- These tokens deserve some details (on the next slide!)

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

class: extra-details

## How are these permissions set up?

- A bunch of roles and bindings are defined as constants in the API server code:

  [auth/authorizer/rbac/bootstrappolicy/policy.go](https://github.com/kubernetes/kubernetes/blob/release-1.19/plugin/pkg/auth/authorizer/rbac/bootstrappolicy/policy.go#L188)

- They are created automatically when the API server starts:

  [registry/rbac/rest/storage_rbac.go](https://github.com/kubernetes/kubernetes/blob/release-1.19/pkg/registry/rbac/rest/storage_rbac.go#L140)

- We must use the correct Common Names (`CN`) for the control plane certificates

  (since the bindings defined above refer to these common names)

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## Service account tokens

- Each time we create a service account, the controller manager generates a token

- These tokens are JWT tokens, signed with a particular key

- These tokens are used for authentication with the API server

  (and therefore, the API server needs to be able to verify their integrity)

- This uses another keypair:

  - the private key (used for signature) is passed to the controller manager
    <br/>(using flags `--service-account-private-key-file` and `--root-ca-file`)

  - the public key (used for verification) is passed to the API server
    <br/>(using flag `--service-account-key-file`)

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## kube-proxy

- kube-proxy is "yet another API server client"

- In many clusters, it runs as a Daemon Set

- In that case, it will have its own Service Account and associated permissions

- It will authenticate using the token of that Service Account

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## Webhooks

- We mentioned webhooks earlier; how does that really work?

- The Kubernetes API has special resource types to check permissions

- One of them is SubjectAccessReview

- To check if a particular user can do a particular action on a particular resource:

  - we prepare a SubjectAccessReview object

  - we send that object to the API server

  - the API server responds with allow/deny (and optional explanations)

- Using webhooks for authorization = sending SAR to authorize each request

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

## Subject Access Review

Here is an example showing how to check if `jean.doe` can `get` some `pods` in `kube-system`:

```bash
kubectl -v9 create -f- <<EOF
apiVersion: authorization.k8s.io/v1
kind: SubjectAccessReview
spec:
  user: jean.doe
  groups:
  - foo
  - bar
  resourceAttributes:
    #group: blah.k8s.io
    namespace: kube-system
    resource: pods
    verb: get
    #name: web-xyz1234567-pqr89
EOF
```

???

:EN:- Control plane authentication
:FR:- Sécurisation du plan de contrôle

.debug[[k8s/control-plane-auth.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/control-plane-auth.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-2.jpg)]

---

name: toc-network-policies
class: title

 Network policies

.nav[
[Previous part](#toc-securing-the-control-plane)
|
[Back to table of contents](#toc-part-11)
|
[Next part](#toc-restricting-pod-permissions)
]

.debug[(automatically generated title slide)]

---
# Network policies

- Namespaces help us to *organize* resources

- Namespaces do not provide isolation

- By default, every pod can contact every other pod

- By default, every service accepts traffic from anyone

- If we want this to be different, we need *network policies*

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## What's a network policy?

A network policy is defined by the following things.

- A *pod selector* indicating which pods it applies to

  e.g.: "all pods in namespace `blue` with the label `zone=internal`"

- A list of *ingress rules* indicating which inbound traffic is allowed

  e.g.: "TCP connections to ports 8000 and 8080 coming from pods with label `zone=dmz`,
  and from the external subnet 4.42.6.0/24, except 4.42.6.5"

- A list of *egress rules* indicating which outbound traffic is allowed

A network policy can provide ingress rules, egress rules, or both.

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## How do network policies apply?

- A pod can be "selected" by any number of network policies

- If a pod isn't selected by any network policy, then its traffic is unrestricted

  (In other words: in the absence of network policies, all traffic is allowed)

- If a pod is selected by at least one network policy, then all traffic is blocked ...

  ... unless it is explicitly allowed by one of these network policies

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

class: extra-details

## Traffic filtering is flow-oriented

- Network policies deal with *connections*, not individual packets

- Example: to allow HTTP (80/tcp) connections to pod A, you only need an ingress rule

  (You do not need a matching egress rule to allow response traffic to go through)

- This also applies for UDP traffic

  (Allowing DNS traffic can be done with a single rule)

- Network policy implementations use stateful connection tracking

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Pod-to-pod traffic

- Connections from pod A to pod B have to be allowed by both pods:

  - pod A has to be unrestricted, or allow the connection as an *egress* rule

  - pod B has to be unrestricted, or allow the connection as an *ingress* rule

- As a consequence: if a network policy restricts traffic going from/to a pod,
  <br/>
  the restriction cannot be overridden by a network policy selecting another pod

- This prevents an entity managing network policies in namespace A
  (but without permission to do so in namespace B)
  from adding network policies giving them access to namespace B

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## The rationale for network policies

- In network security, it is generally considered better to "deny all, then allow selectively"

  (The other approach, "allow all, then block selectively" makes it too easy to leave holes)

- As soon as one network policy selects a pod, the pod enters this "deny all" logic

- Further network policies can open additional access

- Good network policies should be scoped as precisely as possible

- In particular: make sure that the selector is not too broad

  (Otherwise, you end up affecting pods that were otherwise well secured)

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Our first network policy

This is our game plan:

- run a web server in a pod

- create a network policy to block all access to the web server

- create another network policy to allow access only from specific pods

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Running our test web server

.lab[

- Let's use the `nginx` image:
  ```bash
  kubectl create deployment testweb --image=nginx
  ```

<!--
```bash
kubectl wait deployment testweb --for condition=available
```
-->

- Find out the IP address of the pod with one of these two commands:
  ```bash
  kubectl get pods -o wide -l app=testweb
  IP=$(kubectl get pods -l app=testweb -o json | jq -r .items[0].status.podIP)
  ```

- Check that we can connect to the server:
  ```bash
  curl $IP
  ```
]

The `curl` command should show us the "Welcome to nginx!" page.

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Adding a very restrictive network policy

- The policy will select pods with the label `app=testweb`

- It will specify an empty list of ingress rules (matching nothing)

.lab[

- Apply the policy in this YAML file:
  ```bash
    kubectl apply -f ~/container.training/k8s/netpol-deny-all-for-testweb.yaml
  ```

- Check if we can still access the server:
  ```bash
  curl $IP
  ```

<!--
```wait curl```
```key ^C```
-->

]

The `curl` command should now time out.

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Looking at the network policy

This is the file that we applied:

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-all-for-testweb
spec:
  podSelector:
    matchLabels:
      app: testweb
  ingress: []


```

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Allowing connections only from specific pods

- We want to allow traffic from pods with the label `run=testcurl`

- Reminder: this label is automatically applied when we do `kubectl run testcurl ...`

.lab[

- Apply another policy:
  ```bash
  kubectl apply -f ~/container.training/k8s/netpol-allow-testcurl-for-testweb.yaml
  ```

]

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Looking at the network policy

This is the second file that we applied:

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-testcurl-for-testweb
spec:
  podSelector:
    matchLabels:
      app: testweb
  ingress:
  - from:
    - podSelector:
        matchLabels:
          run: testcurl


```

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Testing the network policy

- Let's create pods with, and without, the required label

.lab[

- Try to connect to testweb from a pod with the `run=testcurl` label:
  ```bash
  kubectl run testcurl --rm -i --image=centos -- curl -m3 $IP
  ```

- Try to connect to testweb with a different label:
  ```bash
  kubectl run testkurl --rm -i --image=centos -- curl -m3 $IP
  ```

]

The first command will work (and show the "Welcome to nginx!" page).

The second command will fail and time out after 3 seconds.

(The timeout is obtained with the `-m3` option.)

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## An important warning

- Some network plugins only have partial support for network policies

- For instance, Weave added support for egress rules [in version 2.4](https://github.com/weaveworks/weave/pull/3313) (released in July 2018)

- But only recently added support for ipBlock [in version 2.5](https://github.com/weaveworks/weave/pull/3367) (released in Nov 2018)

- Unsupported features might be silently ignored

  (Making you believe that you are secure, when you're not)

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Network policies, pods, and services

- Network policies apply to *pods*

- A *service* can select multiple pods

  (And load balance traffic across them)

- It is possible that we can connect to some pods, but not some others

  (Because of how network policies have been defined for these pods)

- In that case, connections to the service will randomly pass or fail

  (Depending on whether the connection was sent to a pod that we have access to or not)

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Network policies and namespaces

- A good strategy is to isolate a namespace, so that:

  - all the pods in the namespace can communicate together

  - other namespaces cannot access the pods

  - external access has to be enabled explicitly

- Let's see what this would look like for the DockerCoins app!

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Network policies for DockerCoins

- We are going to apply two policies

- The first policy will prevent traffic from other namespaces

- The second policy will allow traffic to the `webui` pods

- That's all we need for that app!

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Blocking traffic from other namespaces

This policy selects all pods in the current namespace.

It allows traffic only from pods in the current namespace.

(An empty `podSelector` means "all pods.")

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-from-other-namespaces
spec:
  podSelector: {}
  ingress:
  - from:
    - podSelector: {}
```

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Allowing traffic to `webui` pods

This policy selects all pods with label `app=webui`.

It allows traffic from any source.

(An empty `from` field means "all sources.")

```yaml
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-webui
spec:
  podSelector:
    matchLabels:
      app: webui
  ingress:
  - from: []
```

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Applying both network policies

- Both network policies are declared in the file [k8s/netpol-dockercoins.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/netpol-dockercoins.yaml)

.lab[

- Apply the network policies:
  ```bash
  kubectl apply -f ~/container.training/k8s/netpol-dockercoins.yaml
  ```

- Check that we can still access the web UI from outside
  <br/>
  (and that the app is still working correctly!)

- Check that we can't connect anymore to `rng` or `hasher` through their ClusterIP

]

Note: using `kubectl proxy` or `kubectl port-forward` allows us to connect
regardless of existing network policies. This allows us to debug and
troubleshoot easily, without having to poke holes in our firewall.

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Cleaning up our network policies

- The network policies that we have installed block all traffic to the default namespace

- We should remove them, otherwise further demos and exercises will fail!

.lab[

- Remove all network policies:
  ```bash
  kubectl delete networkpolicies --all
  ```

]

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Protecting the control plane

- Should we add network policies to block unauthorized access to the control plane?

  (etcd, API server, etc.)

--

- At first, it seems like a good idea ...

--

- But it *shouldn't* be necessary:

  - not all network plugins support network policies

  - the control plane is secured by other methods (mutual TLS, mostly)

  - the code running in our pods can reasonably expect to contact the API
    <br/>
    (and it can do so safely thanks to the API permission model)

- If we block access to the control plane, we might disrupt legitimate code

- ...Without necessarily improving security

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Tools and resources

- [Cilium Network Policy Editor](https://editor.cilium.io/)

- [Tufin Network Policy Viewer](https://orca.tufin.io/netpol/)

- [`kubectl np-viewer`](https://github.com/runoncloud/kubectl-np-viewer) (kubectl plugin)

- Two resources by [Ahmet Alp Balkan](https://ahmet.im/):

  - a [very good talk about network policies](https://www.youtube.com/watch?list=PLj6h78yzYM2P-3-xqvmWaZbbI1sW-ulZb&v=3gGpMmYeEO8) at KubeCon North America 2017

  - a repository of [ready-to-use recipes](https://github.com/ahmetb/kubernetes-network-policy-recipes) for network policies

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

## Documentation

- As always, the [Kubernetes documentation](https://kubernetes.io/docs/concepts/services-networking/network-policies/) is a good starting point

- The API documentation has a lot of detail about the format of various objects: <!-- ##VERSION## -->

  - [NetworkPolicy](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#networkpolicy-v1-networking-k8s-io)

  - [NetworkPolicySpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#networkpolicyspec-v1-networking-k8s-io)

  - [NetworkPolicyIngressRule](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#networkpolicyingressrule-v1-networking-k8s-io)

  - etc.

???

:EN:- Isolating workloads with Network Policies
:FR:- Isolation réseau avec les *network policies*

.debug[[k8s/netpol.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/netpol.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/two-containers-on-a-truck.jpg)]

---

name: toc-restricting-pod-permissions
class: title

 Restricting Pod Permissions

.nav[
[Previous part](#toc-network-policies)
|
[Back to table of contents](#toc-part-11)
|
[Next part](#toc-pod-security-policies)
]

.debug[(automatically generated title slide)]

---
# Restricting Pod Permissions

- By default, our pods and containers can do *everything*

  (including taking over the entire cluster)

- We are going to show an example of a malicious pod

  (which will give us root access to the whole cluster)

- Then we will explain how to avoid this with admission control

  (PodSecurityAdmission, PodSecurityPolicy, or external policy engine)

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## Setting up a namespace

- For simplicity, let's work in a separate namespace

- Let's create a new namespace called "green"

.lab[

- Create the "green" namespace:
  ```bash
  kubectl create namespace green
  ```

- Change to that namespace:
  ```bash
  kns green
  ```

]

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## Creating a basic Deployment

- Just to check that everything works correctly, deploy NGINX

.lab[

- Create a Deployment using the official NGINX image:
  ```bash
  kubectl create deployment web --image=nginx
  ```

- Confirm that the Deployment, ReplicaSet, and Pod exist, and that the Pod is running:
  ```bash
  kubectl get all
  ```

]

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## One example of malicious pods

- We will now show an escalation technique in action

- We will deploy a DaemonSet that adds our SSH key to the root account

  (on *each* node of the cluster)

- The Pods of the DaemonSet will do so by mounting `/root` from the host

.lab[

- Check the file `k8s/hacktheplanet.yaml` with a text editor:
  ```bash
  vim ~/container.training/k8s/hacktheplanet.yaml
  ```

- If you would like, change the SSH key (by changing the GitHub user name)

]

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## Deploying the malicious pods

- Let's deploy our "exploit"!

.lab[

- Create the DaemonSet:
  ```bash
  kubectl create -f ~/container.training/k8s/hacktheplanet.yaml
  ```

- Check that the pods are running:
  ```bash
  kubectl get pods
  ```

- Confirm that the SSH key was added to the node's root account:
  ```bash
  sudo cat /root/.ssh/authorized_keys
  ```

]

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## Mitigations

- This can be avoided with *admission control*

- Admission control = filter for (write) API requests

- Admission control can use:

  - plugins (compiled in API server; enabled/disabled by reconfiguration)

  - webhooks (registered dynamically)

- Admission control has many other uses

  (enforcing quotas, adding ServiceAccounts automatically, etc.)

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## Admission plugins

- [PodSecurityPolicy](https://kubernetes.io/docs/concepts/policy/pod-security-policy/) (was removed in Kubernetes 1.25)

  - create PodSecurityPolicy resources

  - create Role that can `use` a PodSecurityPolicy

  - create RoleBinding that grants the Role to a user or ServiceAccount

- [PodSecurityAdmission](https://kubernetes.io/docs/concepts/security/pod-security-admission/) (alpha since Kubernetes 1.22, stable since 1.25)

  - use pre-defined policies (privileged, baseline, restricted)

  - label namespaces to indicate which policies they can use

  - optionally, define default rules (in the absence of labels)

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## Dynamic admission

- Leverage ValidatingWebhookConfigurations

  (to register a validating webhook)

- Examples:

  [Kubewarden](https://www.kubewarden.io/)

  [Kyverno](https://kyverno.io/policies/pod-security/)

  [OPA Gatekeeper](https://github.com/open-policy-agent/gatekeeper)

- Pros: available today; very flexible and customizable

- Cons: performance and reliability of external webhook

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## Validating Admission Policies

- Alternative to validating admission webhooks

- Evaluated in the API server

  (don't require an external server; don't add network latency)

- Written in CEL (Common Expression Language)

- alpha in K8S 1.26; beta in K8S 1.28; GA in K8S 1.30

- Can replace validating webhooks at least in simple cases

- Can extend Pod Security Admission

- Check [the documentation][vapdoc] for examples

[vapdoc]: https://kubernetes.io/docs/reference/access-authn-authz/validating-admission-policy/

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

## Acronym salad

- PSP = Pod Security Policy **(deprecated)**

  - an admission plugin called PodSecurityPolicy

  - a resource named PodSecurityPolicy (`apiVersion: policy/v1beta1`)

- PSA = Pod Security Admission

  - an admission plugin called PodSecurity, enforcing PSS

- PSS = Pod Security Standards

  - a set of 3 policies (privileged, baseline, restricted)\

???

:EN:- Mechanisms to prevent pod privilege escalation
:FR:- Les mécanismes pour limiter les privilèges des pods

.debug[[k8s/pod-security-intro.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-intro.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/wall-of-containers.jpeg)]

---

name: toc-pod-security-policies
class: title

 Pod Security Policies

.nav[
[Previous part](#toc-restricting-pod-permissions)
|
[Back to table of contents](#toc-part-11)
|
[Next part](#toc-pod-security-admission)
]

.debug[(automatically generated title slide)]

---
# Pod Security Policies

- "Legacy" policies

  (deprecated since Kubernetes 1.21; removed in 1.25)

- Superseded by Pod Security Standards + Pod Security Admission

  (available in alpha since Kubernetes 1.22; stable since 1.25)

- **Since Kubernetes 1.24 was EOL in July 2023, nobody should use PSPs anymore!**

- This section is here mostly for historical purposes, and can be skipped

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Pod Security Policies in theory

- To use PSPs, we need to activate their specific *admission controller*

- That admission controller will intercept each pod creation attempt

- It will look at:

  - *who/what* is creating the pod

  - which PodSecurityPolicies they can use

  - which PodSecurityPolicies can be used by the Pod's ServiceAccount

- Then it will compare the Pod with each PodSecurityPolicy one by one

- If a PodSecurityPolicy accepts all the parameters of the Pod, it is created

- Otherwise, the Pod creation is denied and it won't even show up in `kubectl get pods`

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Pod Security Policies fine print

- With RBAC, using a PSP corresponds to the verb `use` on the PSP

  (that makes sense, right?)

- If no PSP is defined, no Pod can be created

  (even by cluster admins)

- Pods that are already running are *not* affected

- If we create a Pod directly, it can use a PSP to which *we* have access

- If the Pod is created by e.g. a ReplicaSet or DaemonSet, it's different:

  - the ReplicaSet / DaemonSet controllers don't have access to *our* policies

  - therefore, we need to give access to the PSP to the Pod's ServiceAccount

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Pod Security Policies in practice

- We are going to enable the PodSecurityPolicy admission controller

- At that point, we won't be able to create any more pods (!)

- Then we will create a couple of PodSecurityPolicies

- ...And associated ClusterRoles (giving `use` access to the policies)

- Then we will create RoleBindings to grant these roles to ServiceAccounts

- We will verify that we can't run our "exploit" anymore

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Enabling Pod Security Policies

- To enable Pod Security Policies, we need to enable their *admission plugin*

- This is done by adding a flag to the API server

- On clusters deployed with `kubeadm`, the control plane runs in static pods

- These pods are defined in YAML files located in `/etc/kubernetes/manifests`

- Kubelet watches this directory

- Each time a file is added/removed there, kubelet creates/deletes the corresponding pod

- Updating a file causes the pod to be deleted and recreated

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Updating the API server flags

- Let's edit the manifest for the API server pod

.lab[

- Have a look at the static pods:
  ```bash
  ls -l /etc/kubernetes/manifests
  ```

- Edit the one corresponding to the API server:
  ```bash
  sudo vim /etc/kubernetes/manifests/kube-apiserver.yaml
  ```

<!-- ```wait apiVersion``` -->

]

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Adding the PSP admission plugin

- There should already be a line with `--enable-admission-plugins=...`

- Let's add `PodSecurityPolicy` on that line

.lab[

- Locate the line with `--enable-admission-plugins=`

- Add `PodSecurityPolicy`

  It should read: `--enable-admission-plugins=NodeRestriction,PodSecurityPolicy`

- Save, quit

<!--
```keys /--enable-admission-plugins=```
```key ^J```
```key $```
```keys a,PodSecurityPolicy```
```key Escape```
```keys :wq```
```key ^J```
-->

]

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Waiting for the API server to restart

- The kubelet detects that the file was modified

- It kills the API server pod, and starts a new one

- During that time, the API server is unavailable

.lab[

- Wait until the API server is available again

]

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Check that the admission plugin is active

- Normally, we can't create any Pod at this point

.lab[

- Try to create a Pod directly:
  ```bash
  kubectl run testpsp1 --image=nginx --restart=Never
  ```

<!-- ```wait forbidden: no providers available``` -->

- Try to create a Deployment:
  ```bash
  kubectl create deployment testpsp2 --image=nginx
  ```

- Look at existing resources:
  ```bash
  kubectl get all
  ```

]

We can get hints at what's happening by looking at the ReplicaSet and Events.

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Introducing our Pod Security Policies

- We will create two policies:

  - privileged (allows everything)

  - restricted (blocks some unsafe mechanisms)

- For each policy, we also need an associated ClusterRole granting *use*

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Creating our Pod Security Policies

- We have a couple of files, each defining a PSP and associated ClusterRole:

  - k8s/psp-privileged.yaml: policy `privileged`, role `psp:privileged`
  - k8s/psp-restricted.yaml: policy `restricted`, role `psp:restricted`

.lab[

- Create both policies and their associated ClusterRoles:
  ```bash
  kubectl create -f ~/container.training/k8s/psp-restricted.yaml
  kubectl create -f ~/container.training/k8s/psp-privileged.yaml
  ```
]

- The privileged policy comes from [the Kubernetes documentation](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#example-policies)

- The restricted policy is inspired by that same documentation page

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Check that we can create Pods again

- We haven't bound the policy to any user yet

- But `cluster-admin` can implicitly `use` all policies

.lab[

- Check that we can now create a Pod directly:
  ```bash
  kubectl run testpsp3 --image=nginx --restart=Never
  ```

- Create a Deployment as well:
  ```bash
  kubectl create deployment testpsp4 --image=nginx
  ```

- Confirm that the Deployment is *not* creating any Pods:
  ```bash
  kubectl get all
  ```

]

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## What's going on?

- We can create Pods directly (thanks to our root-like permissions)

- The Pods corresponding to a Deployment are created by the ReplicaSet controller

- The ReplicaSet controller does *not* have root-like permissions

- We need to either:

  - grant permissions to the ReplicaSet controller

  *or*

  - grant permissions to our Pods' ServiceAccount

- The first option would allow *anyone* to create pods

- The second option will allow us to scope the permissions better

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Binding the restricted policy

- Let's bind the role `psp:restricted` to ServiceAccount `green:default`

  (aka the default ServiceAccount in the green Namespace)

- This will allow Pod creation in the green Namespace

  (because these Pods will be using that ServiceAccount automatically)

.lab[

- Create the following RoleBinding:
  ```bash
    kubectl create rolebinding psp:restricted \
            --clusterrole=psp:restricted \
            --serviceaccount=green:default
  ```

]

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Trying it out

- The Deployments that we created earlier will *eventually* recover

  (the ReplicaSet controller will retry to create Pods once in a while)

- If we create a new Deployment now, it should work immediately

.lab[

- Create a simple Deployment:
  ```bash
  kubectl create deployment testpsp5 --image=nginx
  ```

- Look at the Pods that have been created:
  ```bash
  kubectl get all
  ```

]

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Trying to hack the cluster

- Let's create the same DaemonSet we used earlier

.lab[

- Create a hostile DaemonSet:
  ```bash
  kubectl create -f ~/container.training/k8s/hacktheplanet.yaml
  ```

- Look at the state of the namespace:
  ```bash
  kubectl get all
  ```

]

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

class: extra-details

## What's in our restricted policy?

- The restricted PSP is similar to the one provided in the docs, but:

  - it allows containers to run as root

  - it doesn't drop capabilities

- Many containers run as root by default, and would require additional tweaks

- Many containers use e.g. `chown`, which requires a specific capability

  (that's the case for the NGINX official image, for instance)

- We still block: hostPath, privileged containers, and much more!

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

class: extra-details

## The case of static pods

- If we list the pods in the `kube-system` namespace, `kube-apiserver` is missing

- However, the API server is obviously running

  (otherwise, `kubectl get pods --namespace=kube-system` wouldn't work)

- The API server Pod is created directly by kubelet

  (without going through the PSP admission plugin)

- Then, kubelet creates a "mirror pod" representing that Pod in etcd

- That "mirror pod" creation goes through the PSP admission plugin

- And it gets blocked!

- This can be fixed by binding `psp:privileged` to group `system:nodes`

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## .warning[Before moving on...]

- Our cluster is currently broken

  (we can't create pods in namespaces kube-system, default, ...)

- We need to either:

  - disable the PSP admission plugin

  - allow use of PSP to relevant users and groups

- For instance, we could:

  - bind `psp:restricted` to the group `system:authenticated`

  - bind `psp:privileged` to the ServiceAccount `kube-system:default`

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

## Fixing the cluster

- Let's disable the PSP admission plugin

.lab[

- Edit the Kubernetes API server static pod manifest

- Remove the PSP admission plugin

- This can be done with this one-liner:
  ```bash
  sudo sed -i s/,PodSecurityPolicy// /etc/kubernetes/manifests/kube-apiserver.yaml
  ```

]

???

:EN:- Preventing privilege escalation with Pod Security Policies
:FR:- Limiter les droits des conteneurs avec les *Pod Security Policies*

.debug[[k8s/pod-security-policies.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-policies.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/catene-de-conteneurs.jpg)]

---

name: toc-pod-security-admission
class: title

 Pod Security Admission

.nav[
[Previous part](#toc-pod-security-policies)
|
[Back to table of contents](#toc-part-11)
|
[Next part](#toc-resource-limits)
]

.debug[(automatically generated title slide)]

---
# Pod Security Admission

- "New" policies

  (available in alpha since Kubernetes 1.22, and GA since Kubernetes 1.25)

- Easier to use

  (doesn't require complex interaction between policies and RBAC)

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## PSA in theory

- Leans on PSS (Pod Security Standards)

- Defines three policies:

  - `privileged` (can do everything; for system components)

  - `restricted` (no root user; almost no capabilities)

  - `baseline` (in-between with reasonable defaults)

- Label namespaces to indicate which policies are allowed there

- Also supports setting global defaults

- Supports `enforce`, `audit`, and `warn` modes

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## Pod Security Standards

- `privileged`

  - can do everything

- `baseline`

  - disables hostNetwork, hostPID, hostIPC, hostPorts, hostPath volumes
  - limits which SELinux/AppArmor profiles can be used
  - containers can still run as root and use most capabilities

- `restricted`

  - limits volumes to configMap, emptyDir, ephemeral, secret, PVC
  - containers can't run as root, only capability is NET_BIND_SERVICE
  - `baseline` (can't do privileged pods, hostPath, hostNetwork...)

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

class: extra-details

## Why `baseline` ≠ `restricted` ?

- `baseline` = should work for that vast majority of images

- `restricted` = better, but might break / require adaptation

- Many images run as root by default

- Some images use CAP_CHOWN (to `chown` files)

- Some programs use CAP_NET_RAW (e.g. `ping`)

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## Namespace labels

- Three optional labels can be added to namespaces:

  `pod-security.kubernetes.io/enforce`

  `pod-security.kubernetes.io/audit`

  `pod-security.kubernetes.io/warn`

- The values can be: `baseline`, `restricted`, `privileged`

  (setting it to `privileged` doesn't really do anything)

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## `enforce`, `audit`, `warn`

- `enforce` = prevents creation of pods

- `warn` = allow creation but include a warning in the API response

  (will be visible e.g. in `kubectl` output)

- `audit` = allow creation but generate an API audit event

  (will be visible if API auditing has been enabled and configured)

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## Blocking privileged pods

- Let's block `privileged` pods everywhere

- And issue warnings and audit for anything above the `restricted` level

.lab[

- Set up the default policy for all namespaces:
  ```bash
  kubectl label namespaces \
      pod-security.kubernetes.io/enforce=baseline \
      pod-security.kubernetes.io/audit=restricted \
      pod-security.kubernetes.io/warn=restricted \
      --all
  ```

]

Note: warnings will be issued for infringing pods, but they won't be affected yet.

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

class: extra-details

## Check before you apply

- When adding an `enforce` policy, we see warnings

  (for the pods that would infringe that policy)

- It's possible to do a `--dry-run=server` to see these warnings

  (without applying the label)

- It will only show warnings for `enforce` policies

  (not `warn` or `audit`)

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## Relaxing `kube-system`

- We have many system components in `kube-system`

- These pods aren't affected yet, but if there is a rolling update or something like that, the new pods won't be able to come up

.lab[

- Let's allow `privileged` pods in `kube-system`:
  ```bash
  kubectl label namespace kube-system \
      pod-security.kubernetes.io/enforce=privileged \
      pod-security.kubernetes.io/audit=privileged \
      pod-security.kubernetes.io/warn=privileged \
      --overwrite
  ```

]

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## What about new namespaces?

- If new namespaces are created, they will get default permissions

- We can change that by using an *admission configuration*

- Step 1: write an "admission configuration file"

- Step 2: make sure that file is readable by the API server

- Step 3: add a flag to the API server to read that file

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## Admission Configuration

Let's use [k8s/admission-configuration.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/admission-configuration.yaml):

```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: AdmissionConfiguration
plugins:
- name: PodSecurity
  configuration:
    apiVersion: pod-security.admission.config.k8s.io/v1alpha1
    kind: PodSecurityConfiguration
    defaults:
      enforce: baseline
      audit: baseline
      warn: baseline
    exemptions:
      usernames:
      - cluster-admin
      namespaces:
      - kube-system

```

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## Copy the file to the API server

- We need the file to be available from the API server pod

- For convenience, let's copy it do `/etc/kubernetes/pki`

  (it's definitely not where it *should* be, but that'll do!)


.lab[

- Copy the file:
  ```bash
    sudo cp ~/container.training/k8s/admission-configuration.yaml \
            /etc/kubernetes/pki
  ```

]

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## Reconfigure the API server

- We need to add a flag to the API server to use that file

.lab[

- Edit `/etc/kubernetes/manifests/kube-apiserver.yaml`

- In the list of `command` parameters, add:

  `--admission-control-config-file=/etc/kubernetes/pki/admission-configuration.yaml`

- Wait until the API server comes back online

]

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

## Test the new default policy

- Create a new Namespace

- Try to create the "hacktheplanet" DaemonSet in the new namespace

- We get a warning when creating the DaemonSet

- The DaemonSet is created

- But the Pods don't get created

???

:EN:- Preventing privilege escalation with Pod Security Admission
:FR:- Limiter les droits des conteneurs avec *Pod Security Admission*

.debug[[k8s/pod-security-admission.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pod-security-admission.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-resource-limits
class: title

 Resource Limits

.nav[
[Previous part](#toc-pod-security-admission)
|
[Back to table of contents](#toc-part-12)
|
[Next part](#toc-defining-min-max-and-default-resources)
]

.debug[(automatically generated title slide)]

---
# Resource Limits

- We can attach resource indications to our pods

  (or rather: to the *containers* in our pods)

- We can specify *limits* and/or *requests*

- We can specify quantities of CPU and/or memory and/or ephemeral storage

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Requests vs limits

- *Requests* are *guaranteed reservations* of resources

- They are used for scheduling purposes

- Kubelet will use cgroups to e.g. guarantee a minimum amount of CPU time

- A container **can** use more than its requested resources

- A container using *less* than what it requested should never be killed or throttled

- A node **cannot** be overcommitted with requests

  (the sum of all requests **cannot** be higher than resources available on the node)

- A small amount of resources is set aside for system components

  (this explains why there is a difference between "capacity" and "allocatable")

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Requests vs limits

- *Limits* are "hard limits" (a container **cannot** exceed its limits)

- They aren't taken into account by the scheduler

- A container exceeding its memory limit is killed instantly

  (by the kernel out-of-memory killer)

- A container exceeding its CPU limit is throttled

- A container exceeding its disk limit is killed

  (usually with a small delay, since this is checked periodically by kubelet)

- On a given node, the sum of all limits **can** be higher than the node size

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Compressible vs incompressible resources

- CPU is a *compressible resource*

  - it can be preempted immediately without adverse effect

  - if we have N CPU and need 2N, we run at 50% speed

- Memory is an *incompressible resource*

  - it needs to be swapped out to be reclaimed; and this is costly

  - if we have N GB RAM and need 2N, we might run at... 0.1% speed!

- Disk is also an *incompressible resource*

  - when the disk is full, writes will fail

  - applications may or may not crash but persistent apps will be in trouble

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Running low on CPU

- Two ways for a container to "run low" on CPU:

  - it's hitting its CPU limit

  - all CPUs on the node are at 100% utilization

- The app in the container will run slower

  (compared to running without a limit, or if CPU cycles were available)

- No other consequence

  (but this could affect SLA/SLO for latency-sensitive applications!)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## CPU limits implementation details

- A container with a CPU limit will be "rationed" by the kernel

- Every `cfs_period_us`, it will receive a CPU quota, like an "allowance"

  (that interval defaults to 100ms)

- Once it has used its quota, it will be stalled until the next period

- This can easily result in throttling for bursty workloads

  (see details on next slide)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## A bursty example

- Web service receives one request per minute

- Each request takes 1 second of CPU

- Average load: 1.66%

- Let's say we set a CPU limit of 10%

- This means CPU quotas of 10ms every 100ms

- Obtaining the quota for 1 second of CPU will take 10 seconds

- Observed latency will be 10 seconds (... actually 9.9s) instead of 1 second

  (real-life scenarios will of course be less extreme, but they do happen!)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## Multi-core scheduling details

- Each core gets a small share of the container's CPU quota

  (this avoids locking and contention on the "global" quota for the container)

- By default, the kernel distributes that quota to CPUs in 5ms increments

  (tunable with `kernel.sched_cfs_bandwidth_slice_us`)

- If a containerized process (or thread) uses up its local CPU quota:

  *it gets more from the "global" container quota (if there's some left)*

- If it "yields" (e.g. sleeps for I/O) before using its local CPU quota:

  *the quota is **soon** returned to the "global" container quota, **minus** 1ms*

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## Low quotas on machines with many cores

- The local CPU quota is not immediately returned to the global quota

  - this reduces locking and contention on the global quota

  - but this can cause starvation when many threads/processes become runnable

- That 1ms that "stays" on the local CPU quota is often useful

  - if the thread/process becomes runnable, it can be scheduled immediately

  - again, this reduces locking and contention on the global quota

  - but if the thread/process doesn't become runnable, it is wasted!

  - this can become a huge problem on machines with many cores

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## CPU limits in a nutshell

- Beware if you run small bursty workloads on machines with many cores!

  ("highly-threaded, user-interactive, non-cpu bound applications")

- Check the `nr_throttled` and `throttled_time` metrics in `cpu.stat`

- Possible solutions/workarounds:

  - be generous with the limits

  - make sure your kernel has the [appropriate patch](https://lkml.org/lkml/2019/5/17/581)

  - use [static CPU manager policy](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#static-policy)

For more details, check [this blog post](https://erickhun.com/posts/kubernetes-faster-services-no-cpu-limits/) or these ones ([part 1](https://engineering.indeedblog.com/blog/2019/12/unthrottled-fixing-cpu-limits-in-the-cloud/), [part 2](https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/)).

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Running low on memory

- When the kernel runs low on memory, it starts to reclaim used memory

- Option 1: free up some buffers and caches

  (fastest option; might affect performance if cache memory runs very low)

- Option 2: swap, i.e. write to disk some memory of one process to give it to another

  (can have a huge negative impact on performance because disks are slow)

- Option 3: terminate a process and reclaim all its memory

  (OOM or Out Of Memory Killer on Linux)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Memory limits on Kubernetes

- Kubernetes *does not support swap*

  (but it may support it in the future, thanks to [KEP 2400])

- If a container exceeds its memory *limit*, it gets killed immediately

- If a node memory usage gets too high, it will *evict* some pods

  (we say that the node is "under pressure", more on that in a bit!)

[KEP 2400]: https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md#implementation-history

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Running low on disk

- When the kubelet runs low on disk, it starts to reclaim disk space

  (similarly to what the kernel does, but in different categories)

- Option 1: garbage collect dead pods and containers

  (no consequence, but their logs will be deleted)

- Option 2: remove unused images

  (no consequence, but these images will have to be repulled if we need them later)

- Option 3: evict pods and remove them to reclaim their disk usage

- Note: this only applies to *ephemeral storage*, not to e.g. Persistent Volumes!

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Ephemeral storage?

- This includes:

  - the *read-write layer* of the container
    <br/>
    (any file creation/modification outside of its volumes)

  - `emptyDir` volumes mounted in the container

  - the container logs stored on the node

- This does not include:

  - the container image

  - other types of volumes (e.g. Persistent Volumes, `hostPath`, or `local` volumes)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## Disk limit enforcement

- Disk usage is periodically measured by kubelet

  (with something equivalent to `du`)

- There can be a small delay before pod termination when disk limit is exceeded

- It's also possible to enable filesystem *project quotas*

  (e.g. with EXT4 or XFS)

- Remember that container logs are also accounted for!

  (container log rotation/retention is managed by kubelet)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## `nodefs` and `imagefs`

- `nodefs` is the main filesystem of the node

  (holding, notably, `emptyDir` volumes and container logs)

- Optionally, the container engine can be configured to use an `imagefs`

- `imagefs` will store container images and container writable layers

- When there is a separate `imagefs`, its disk usage is tracked independently

- If `imagefs` usage gets too high, kubelet will remove old images first

  (conversely, if `nodefs` usage gets too high, kubelet won't remove old images)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## CPU and RAM reservation

- Kubernetes passes resources requests and limits to the container engine

- The container engine applies these requests and limits with specific mechanisms

- Example: on Linux, this is typically done with control groups aka cgroups

- Most systems use cgroups v1, but cgroups v2 are slowly being rolled out

  (e.g. available in Ubuntu 22.04 LTS)

- Cgroups v2 have new, interesting features for memory control:

  - ability to set "minimum" memory amounts (to effectively reserve memory)

  - better control on the amount of swap used by a container

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## What's the deal with swap?

- With cgroups v1, it's not possible to disable swap for a cgroup

  (the closest option is to [reduce "swappiness"](https://unix.stackexchange.com/questions/77939/turning-off-swapping-for-only-one-process-with-cgroups))

- It is possible with cgroups v2 (see the [kernel docs](https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html) and the [fbatx docs](https://facebookmicrosites.github.io/cgroup2/docs/memory-controller.html#using-swap))

- Cgroups v2 aren't widely deployed yet

- The architects of Kubernetes wanted to ensure that Guaranteed pods never swap

- The simplest solution was to disable swap entirely

- Kubelet will refuse to start if it detects that swap is enabled!

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Alternative point of view

- Swap enables paging¹ of anonymous² memory

- Even when swap is disabled, Linux will still page memory for:

  - executables, libraries

  - mapped files

- Disabling swap *will reduce performance and available resources*

- For a good time, read [kubernetes/kubernetes#53533](https://github.com/kubernetes/kubernetes/issues/53533)

- Also read this [excellent blog post about swap](https://jvns.ca/blog/2017/02/17/mystery-swap/)

¹Paging: reading/writing memory pages from/to disk to reclaim physical memory

²Anonymous memory: memory that is not backed by files or blocks

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Enabling swap anyway

- If you don't care that pods are swapping, you can enable swap

- You will need to add the flag `--fail-swap-on=false` to kubelet

  (remember: it won't otherwise start if it detects that swap is enabled)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Pod quality of service

Each pod is assigned a QoS class (visible in `status.qosClass`).

- If limits = requests:

  - as long as the container uses less than the limit, it won't be affected

  - if all containers in a pod have *(limits=requests)*, QoS is considered "Guaranteed"

- If requests &lt; limits:

  - as long as the container uses less than the request, it won't be affected

  - otherwise, it might be killed/evicted if the node gets overloaded

  - if at least one container has *(requests&lt;limits)*, QoS is considered "Burstable"

- If a pod doesn't have any request nor limit, QoS is considered "BestEffort"

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Quality of service impact

- When a node is overloaded, BestEffort pods are killed first

- Then, Burstable pods that exceed their requests

- Burstable and Guaranteed pods below their requests are never killed

  (except if their node fails)

- If we only use Guaranteed pods, no pod should ever be killed

  (as long as they stay within their limits)

(Pod QoS is also explained in [this page](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/) of the Kubernetes documentation and in [this blog post](https://medium.com/google-cloud/quality-of-service-class-qos-in-kubernetes-bb76a89eb2c6).)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Specifying resources

- Resource requests are expressed at the *container* level

- CPU is expressed in "virtual CPUs"

  (corresponding to the virtual CPUs offered by some cloud providers)

- CPU can be expressed with a decimal value, or even a "milli" suffix

  (so 100m = 0.1)

- Memory and ephemeral disk storage are expressed in bytes

- These can have k, M, G, T, ki, Mi, Gi, Ti suffixes

  (corresponding to 10^3, 10^6, 10^9, 10^12, 2^10, 2^20, 2^30, 2^40)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Specifying resources in practice

This is what the spec of a Pod with resources will look like:

```yaml
containers:
- name: blue
  image: jpetazzo/color
  resources:
    limits:
      cpu: "100m"
      ephemeral-storage: 10M
      memory: "100Mi"
    requests:
      cpu: "10m"
      ephemeral-storage: 10M
      memory: "100Mi"
```

This set of resources makes sure that this service won't be killed (as long as it stays below 100 MB of RAM), but allows its CPU usage to be throttled if necessary.

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Default values

- If we specify a limit without a request: 

  the request is set to the limit

- If we specify a request without a limit: 

  there will be no limit

  (which means that the limit will be the size of the node)

- If we don't specify anything:

  the request is zero and the limit is the size of the node

*Unless there are default values defined for our namespace!*

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## We need to specify resource values

- If we do not set resource values at all:

  - the limit is "the size of the node"

  - the request is zero

- This is generally *not* what we want

  - a container without a limit can use up all the resources of a node

  - if the request is zero, the scheduler can't make a smart placement decision

- This is fine when learning/testing, absolutely not in production!

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## How should we set resources?

- Option 1: manually, for each container

  - simple, effective, but tedious

- Option 2: automatically, with the [Vertical Pod Autoscaler (VPA)][vpa]

  - relatively simple, very minimal involvement beyond initial setup

  - not compatible with HPAv1, can disrupt long-running workloads (see [limitations][vpa-limitations])

- Option 3: semi-automatically, with tools like [Robusta KRR][robusta]

  - good compromise between manual work and automation

- Option 4: by creating LimitRanges in our Namespaces

  - relatively simple, but "one-size-fits-all" approach might not always work

[robusta]: https://github.com/robusta-dev/krr
[vpa]: https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler
[vpa-limitations]: https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#known-limitations

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-defining-min-max-and-default-resources
class: title

 Defining min, max, and default resources

.nav[
[Previous part](#toc-resource-limits)
|
[Back to table of contents](#toc-part-12)
|
[Next part](#toc-namespace-quotas)
]

.debug[(automatically generated title slide)]

---

# Defining min, max, and default resources

- We can create LimitRange objects to indicate any combination of:

  - min and/or max resources allowed per pod

  - default resource *limits*

  - default resource *requests*

  - maximal burst ratio (*limit/request*)

- LimitRange objects are namespaced

- They apply to their namespace only

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## LimitRange example

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: my-very-detailed-limitrange
spec:
  limits:
  - type: Container
    min:
      cpu: "100m"
    max:
      cpu: "2000m"
      memory: "1Gi"
    default:
      cpu: "500m"
      memory: "250Mi"
    defaultRequest:
      cpu: "500m"
```

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Example explanation

The YAML on the previous slide shows an example LimitRange object specifying very detailed limits on CPU usage,
and providing defaults on RAM usage.

Note the `type: Container` line: in the future,
it might also be possible to specify limits
per Pod, but it's not [officially documented yet](https://github.com/kubernetes/website/issues/9585).

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## LimitRange details

- LimitRange restrictions are enforced only when a Pod is created

  (they don't apply retroactively)

- They don't prevent creation of e.g. an invalid Deployment or DaemonSet

  (but the pods will not be created as long as the LimitRange is in effect)

- If there are multiple LimitRange restrictions, they all apply together

  (which means that it's possible to specify conflicting LimitRanges,
  <br/>preventing any Pod from being created)

- If a LimitRange specifies a `max` for a resource but no `default`,
  <br/>that `max` value becomes the `default` limit too

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-namespace-quotas
class: title

 Namespace quotas

.nav[
[Previous part](#toc-defining-min-max-and-default-resources)
|
[Back to table of contents](#toc-part-12)
|
[Next part](#toc-limiting-resources-in-practice)
]

.debug[(automatically generated title slide)]

---

# Namespace quotas

- We can also set quotas per namespace

- Quotas apply to the total usage in a namespace

  (e.g. total CPU limits of all pods in a given namespace)

- Quotas can apply to resource limits and/or requests

  (like the CPU and memory limits that we saw earlier)

- Quotas can also apply to other resources:

  - "extended" resources (like GPUs)

  - storage size

  - number of objects (number of pods, services...)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Creating a quota for a namespace

- Quotas are enforced by creating a ResourceQuota object

- ResourceQuota objects are namespaced, and apply to their namespace only

- We can have multiple ResourceQuota objects in the same namespace

- The most restrictive values are used

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Limiting total CPU/memory usage

- The following YAML specifies an upper bound for *limits* and *requests*:
  ```yaml
    apiVersion: v1
    kind: ResourceQuota
    metadata:
      name: a-little-bit-of-compute
    spec:
      hard:
        requests.cpu: "10"
        requests.memory: 10Gi
        limits.cpu: "20"
        limits.memory: 20Gi
  ```

These quotas will apply to the namespace where the ResourceQuota is created.

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Limiting number of objects

- The following YAML specifies how many objects of specific types can be created:
  ```yaml
    apiVersion: v1
    kind: ResourceQuota
    metadata:
      name: quota-for-objects
    spec:
      hard:
        pods: 100
        services: 10
        secrets: 10
        configmaps: 10
        persistentvolumeclaims: 20
        services.nodeports: 0
        services.loadbalancers: 0
        count/roles.rbac.authorization.k8s.io: 10
  ```

(The `count/` syntax allows limiting arbitrary objects, including CRDs.)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## YAML vs CLI

- Quotas can be created with a YAML definition

- ...Or with the `kubectl create quota` command

- Example:
  ```bash
  kubectl create quota my-resource-quota --hard=pods=300,limits.memory=300Gi
  ```

- With both YAML and CLI form, the values are always under the `hard` section

  (there is no `soft` quota)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Viewing current usage

When a ResourceQuota is created, we can see how much of it is used:

```
kubectl describe resourcequota my-resource-quota

Name:                            my-resource-quota
Namespace:                       default
Resource                         Used  Hard
--------                         ----  ----
pods                             12    100
services                         1     5
services.loadbalancers           0     0
services.nodeports               0     0
```

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Advanced quotas and PriorityClass

- Pods can have a *priority*

- The priority is a number from 0 to 1000000000

  (or even higher for system-defined priorities)

- High number = high priority = "more important" Pod

- Pods with a higher priority can *preempt* Pods with lower priority

  (= low priority pods will be *evicted* if needed)

- Useful when mixing workloads in resource-constrained environments

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Setting the priority of a Pod

- Create a PriorityClass

  (or use an existing one)

- When creating the Pod, set the field `spec.priorityClassName`

- If the field is not set:

  - if there is a PriorityClass with `globalDefault`, it is used

  - otherwise, the default priority will be zero

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: extra-details

## PriorityClass and ResourceQuotas

- A ResourceQuota can include a list of *scopes* or a *scope selector*

- In that case, the quota will only apply to the scoped resources

- Example: limit the resources allocated to "high priority" Pods

- In that case, make sure that the quota is created in every Namespace

  (or use *admission configuration* to enforce it)

- See the [resource quotas documentation][quotadocs] for details

[quotadocs]: https://kubernetes.io/docs/concepts/policy/resource-quotas/#resource-quota-per-priorityclass

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-limiting-resources-in-practice
class: title

 Limiting resources in practice

.nav[
[Previous part](#toc-namespace-quotas)
|
[Back to table of contents](#toc-part-12)
|
[Next part](#toc-checking-node-and-pod-resource-usage)
]

.debug[(automatically generated title slide)]

---

# Limiting resources in practice

- We have at least three mechanisms:

  - requests and limits per Pod

  - LimitRange per namespace

  - ResourceQuota per namespace

- Let's see one possible strategy to get started with resource limits

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Set a LimitRange

- In each namespace, create a LimitRange object

- Set a small default CPU request and CPU limit

  (e.g. "100m")

- Set a default memory request and limit depending on your most common workload

  - for Java, Ruby: start with "1G"

  - for Go, Python, PHP, Node: start with "250M"

- Set upper bounds slightly below your expected node size

  (80-90% of your node size, with at least a 500M memory buffer)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Set a ResourceQuota

- In each namespace, create a ResourceQuota object

- Set generous CPU and memory limits

  (e.g. half the cluster size if the cluster hosts multiple apps)

- Set generous objects limits

  - these limits should not be here to constrain your users

  - they should catch a runaway process creating many resources

  - example: a custom controller creating many pods

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Observe, refine, iterate

- Observe the resource usage of your pods

  (we will see how in the next chapter)

- Adjust individual pod limits

- If you see trends: adjust the LimitRange

  (rather than adjusting every individual set of pod limits)

- Observe the resource usage of your namespaces

  (with `kubectl describe resourcequota ...`)

- Rinse and repeat regularly

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Underutilization

- Remember: when assigning a pod to a node, the scheduler looks at *requests*

  (not at current utilization on the node)

- If pods request resources but don't use them, this can lead to underutilization

  (because the scheduler will consider that the node is full and can't fit new pods)

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Viewing a namespace limits and quotas

- `kubectl describe namespace` will display resource limits and quotas

.lab[

- Try it out:
  ```bash
  kubectl describe namespace default
  ```

- View limits and quotas for *all* namespaces:
  ```bash
  kubectl describe namespace
  ```

]

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

## Additional resources

- [A Practical Guide to Setting Kubernetes Requests and Limits](http://blog.kubecost.com/blog/requests-and-limits/)

  - explains what requests and limits are

  - provides guidelines to set requests and limits

  - gives PromQL expressions to compute good values
    <br/>(our app needs to be running for a while)

- [Kube Resource Report](https://codeberg.org/hjacobs/kube-resource-report)

  - generates web reports on resource usage

- [nsinjector](https://github.com/blakelead/nsinjector)

  - controller to automatically populate a Namespace when it is created

???

:EN:- Setting compute resource limits
:EN:- Defining default policies for resource usage
:EN:- Managing cluster allocation and quotas
:EN:- Resource management in practice

:FR:- Allouer et limiter les ressources des conteneurs
:FR:- Définir des ressources par défaut
:FR:- Gérer les quotas de ressources au niveau du cluster
:FR:- Conseils pratiques

.debug[[k8s/resource-limits.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/resource-limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-checking-node-and-pod-resource-usage
class: title

 Checking Node and Pod resource usage

.nav[
[Previous part](#toc-limiting-resources-in-practice)
|
[Back to table of contents](#toc-part-12)
|
[Next part](#toc-cluster-sizing)
]

.debug[(automatically generated title slide)]

---
# Checking Node and Pod resource usage

- We've installed a few things on our cluster so far

- How much resources (CPU, RAM) are we using?

- We need metrics!

.lab[

- Let's try the following command:
  ```bash
  kubectl top nodes
  ```
]

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Is metrics-server installed?

- If we see a list of nodes, with CPU and RAM usage:

  *great, metrics-server is installed!*

- If we see `error: Metrics API not available`:

  *metrics-server isn't installed, so we'll install it!*

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## The resource metrics pipeline

- The `kubectl top` command relies on the Metrics API

- The Metrics API is part of the "[resource metrics pipeline]"

- The Metrics API isn't served (built into) the Kubernetes API server

- It is made available through the [aggregation layer]

- It is usually served by a component called metrics-server

- It is optional (Kubernetes can function without it)

- It is necessary for some features (like the Horizontal Pod Autoscaler)

[resource metrics pipeline]: https://kubernetes.io/docs/tasks/debug-application-cluster/resource-metrics-pipeline/
[aggregation layer]: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Other ways to get metrics

- We could use a SAAS like Datadog, New Relic...

- We could use a self-hosted solution like Prometheus

- Or we could use metrics-server

- What's special about metrics-server?

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Pros/cons

Cons:

- no data retention (no history data, just instant numbers)

- only CPU and RAM of nodes and pods (no disk or network usage or I/O...)

Pros:

- very lightweight

- doesn't require storage

- used by Kubernetes autoscaling

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Why metrics-server

- We may install something fancier later

  (think: Prometheus with Grafana)

- But metrics-server will work in *minutes*

- It will barely use resources on our cluster

- It's required for autoscaling anyway

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## How metric-server works

- It runs a single Pod

- That Pod will fetch metrics from all our Nodes

- It will expose them through the Kubernetes API aggregation layer

  (we won't say much more about that aggregation layer; that's fairly advanced stuff!)

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Installing metrics-server

- In a lot of places, this is done with a little bit of custom YAML

  (derived from the [official installation instructions](https://github.com/kubernetes-sigs/metrics-server#installation))

- We can also use a Helm chart:
  ```bash
    helm upgrade --install metrics-server metrics-server \
      --create-namespace --namespace metrics-server \
      --repo https://kubernetes-sigs.github.io/metrics-server/ \
      --set args={--kubelet-insecure-tls=true}
  ```

- The `args` flag specified above should be sufficient on most clusters

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

class: extra-details

## Kubelet insecure TLS?

- The metrics-server collects metrics by connecting to kubelet

- The connection is secured by TLS

- This requires a valid certificate

- In some cases, the certificate is self-signed

- In other cases, it might be valid, but include only the node name

  (not its IP address, which is used by default by metrics-server)

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Testing metrics-server

- After a minute or two, metrics-server should be up

- We should now be able to check Nodes resource usage:
  ```bash
  kubectl top nodes
  ```

- And Pods resource usage, too:
  ```bash
  kubectl top pods --all-namespaces
  ```

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Keep some padding

- The RAM usage that we see should correspond more or less to the Resident Set Size

- Our pods also need some extra space for buffers, caches...

- Do not aim for 100% memory usage!

- Some more realistic targets:

  50% (for workloads with disk I/O and leveraging caching)

  90% (on very big nodes with mostly CPU-bound workloads)

  75% (anywhere in between!)

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

## Other tools

- kube-capacity is a great CLI tool to view resources

  (https://github.com/robscott/kube-capacity)

- It can show resource and limits, and compare them with usage

- It can show utilization per node, or per pod

- kube-resource-report can generate HTML reports

  (https://codeberg.org/hjacobs/kube-resource-report)

???

:EN:- The resource metrics pipeline
:EN:- Installing metrics-server

:EN:- Le *resource metrics pipeline*
:FR:- Installtion de metrics-server

.debug[[k8s/metrics-server.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/metrics-server.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-cluster-sizing
class: title

 Cluster sizing

.nav[
[Previous part](#toc-checking-node-and-pod-resource-usage)
|
[Back to table of contents](#toc-part-12)
|
[Next part](#toc-disruptions)
]

.debug[(automatically generated title slide)]

---
# Cluster sizing

- What happens when the cluster gets full?

- How can we scale up the cluster?

- Can we do it automatically?

- What are other methods to address capacity planning?

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## When are we out of resources?

- kubelet monitors node resources:

  - memory

  - node disk usage (typically the root filesystem of the node)

  - image disk usage (where container images and RW layers are stored)

- For each resource, we can provide two thresholds:

  - a hard threshold (if it's met, it provokes immediate action)

  - a soft threshold (provokes action only after a grace period)

- Resource thresholds and grace periods are configurable

  (by passing kubelet command-line flags)

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## What happens then?

- If disk usage is too high:

  - kubelet will try to remove terminated pods

  - then, it will try to *evict* pods

- If memory usage is too high:

  - it will try to evict pods

- The node is marked as "under pressure"

- This temporarily prevents new pods from being scheduled on the node

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## Which pods get evicted?

- kubelet looks at the pods' QoS and PriorityClass

- First, pods with BestEffort QoS are considered

- Then, pods with Burstable QoS exceeding their *requests*

  (but only if the exceeding resource is the one that is low on the node)

- Finally, pods with Guaranteed QoS, and Burstable pods within their requests

- Within each group, pods are sorted by PriorityClass

- If there are pods with the same PriorityClass, they are sorted by usage excess

  (i.e. the pods whose usage exceeds their requests the most are evicted first)

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

class: extra-details

## Eviction of Guaranteed pods

- *Normally*, pods with Guaranteed QoS should not be evicted

- A chunk of resources is reserved for node processes (like kubelet)

- It is expected that these processes won't use more than this reservation

- If they do use more resources anyway, all bets are off!

- If this happens, kubelet must evict Guaranteed pods to preserve node stability

  (or Burstable pods that are still within their requested usage)

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## What happens to evicted pods?

- The pod is terminated

- It is marked as `Failed` at the API level

- If the pod was created by a controller, the controller will recreate it

- The pod will be recreated on another node, *if there are resources available!*

- For more details about the eviction process, see:

  - [this documentation page](https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/) about resource pressure and pod eviction,

  - [this other documentation page](https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/) about pod priority and preemption.

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## What if there are no resources available?

- Sometimes, a pod cannot be scheduled anywhere:

  - all the nodes are under pressure,

  - or the pod requests more resources than are available

- The pod then remains in `Pending` state until the situation improves

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## Cluster scaling

- One way to improve the situation is to add new nodes

- This can be done automatically with the [Cluster Autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler)

- The autoscaler will automatically scale up:

  - if there are pods that failed to be scheduled

- The autoscaler will automatically scale down:

  - if nodes have a low utilization for an extended period of time

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## Restrictions, gotchas ...

- The Cluster Autoscaler only supports a few cloud infrastructures

  (see the [kubernetes/autoscaler repo][kubernetes-autoscaler-repo] for a list)

- The Cluster Autoscaler cannot scale down nodes that have pods using:

  - local storage

  - affinity/anti-affinity rules preventing them from being rescheduled

  - a restrictive PodDisruptionBudget

[kubernetes-autoscaler-repo]: https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/cloudprovider

.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

## Other way to do capacity planning

- "Running Kubernetes without nodes"

- Systems like [Virtual Kubelet](https://virtual-kubelet.io/) or [Kiyot](https://static.elotl.co/docs/latest/kiyot/kiyot.html) can run pods using on-demand resources

  - Virtual Kubelet can leverage e.g. ACI or Fargate to run pods

  - Kiyot runs pods in ad-hoc EC2 instances (1 instance per pod)

- Economic advantage (no wasted capacity)

- Security advantage (stronger isolation between pods)

Check [this blog post](http://jpetazzo.github.io/2019/02/13/running-kubernetes-without-nodes-with-kiyot/) for more details.

???

:EN:- What happens when the cluster is at, or over, capacity
:EN:- Cluster sizing and scaling

:FR:- Ce qui se passe quand il n'y a plus assez de ressources
:FR:- Dimensionner et redimensionner ses clusters


.debug[[k8s/cluster-sizing.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/cluster-sizing.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-disruptions
class: title

 Disruptions

.nav[
[Previous part](#toc-cluster-sizing)
|
[Back to table of contents](#toc-part-12)
|
[Next part](#toc-the-horizontal-pod-autoscaler)
]

.debug[(automatically generated title slide)]

---
# Disruptions

In a perfect world...

- hardware never fails

- software never has bugs

- ...and never needs to be updated

- ...and uses a predictable amount of resources

- ...and these resources are infinite anyways

- network latency and packet loss are zero

- humans never make mistakes

--

😬

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Disruptions

In the real world...

- hardware will fail randomly (without advance notice)

- software has bugs

- ...and we constantly add new features

- ...and will sometimes use more resources than expected

- ...and these resources are limited

- network latency and packet loss are NOT zero

- humans make mistake (shutting down the wrong machine, the wrong app...)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Disruptions

- In Kubernetes, a "disruption" is something that stops the execution of a Pod

- There are **voluntary** and **involuntary** disruptions

  - voluntary = directly initiated by humans (including by mistake!)

  - involuntary = everything else

- In this section, we're going to see what they are and how to prevent them

  (or at least, mitigate their effects)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Node outage

- Example: hardware failure (server or network), low-level error

  (includes kernel bugs, issues affecting underlying hypervisors or infrastructure...)

- **Involuntary** disruption (even if it results from human error!)

- Consequence: all workloads on that node become unresponsive

- Mitigations:

  - scale workloads to at least 2 replicas (or more if quorum is needed)

  - add anti-affinity scheduling constraints (to avoid having all pods on the same node)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Node outage play-by-play

- Node goes down (or disconnected from network)

- Its lease (in Namespace `kube-node-lease`) doesn't get renewed

- Controller manager detects that and mark the node as "unreachable"

  (this adds both a `NoSchedule` and `NoExecute` taints to the node)

- Eventually, the `NoExecute` taint will evict these pods

- This will trigger creation of replacement pods by owner controllers

  (except for pods with a stable network identity, e.g. in a Stateful Set!)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Node outage notes

- By default, pods will tolerate the `unreachable:NoExecute` taint for 5 minutes

  (toleration automatically added by Admission controller `DefaultTolerationSeconds`)

- Pods of a Stateful Set don't recover automatically:

  - as long as the Pod exists, a replacement Pod can't be created

  - the Pod will exist as long as its Node exists

  - deleting the Node (manually or automatically) will recover the Pod

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Memory/disk pressure

- Example: available memory on a node goes below a specific threshold

  (because a pod is using too much memory and no limit was set)

- **Involuntary** disruption

- Consequence: kubelet starts to *evict* some pods

- Mitigations:

  - set *resource limits* on containers to prevent them from using too much resources

  - set *resource requests* on containers to make sure they don't get evicted
    <br/>
    (as long as they use less than what they requested)

  - make sure that apps don't use more resources than what they've requested

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Memory/disk pressure play-by-play

- Memory leak in an application container, slowly causing very high memory usage

- Overall free memory on the node goes below the *soft* or the *hard* threshold

  (default hard threshold = 100Mi; default soft threshold = none)

- When reaching the *soft* threshold:

  - kubelet waits until the "eviction soft grace period" expires

  - then (if resource usage is still above the threshold) it gracefully evicts pods

- When reaching the *hard* threshold:

  - kubelet immediately and forcefully evicts pods

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Which pods are evicted?

- Kubelet only considers pods that are using *more* than what they requested

  (and only for the resource that is under pressure, e.g. RAM or disk usage)

- First, it sorts pods by *priority¹* (as set with the `priorityClassName` in the pod spec)

- Then, by how much their resource usage exceeds their request

  (again, for the resource that is under pressure)

- It evicts pods until enough resources have been freed up

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Soft (graceful) vs hard (forceful) eviction

- Soft eviction = graceful shutdown of the pod

  (honor's the pod `terminationGracePeriodSeconds` timeout)

- Hard eviction = immediate shutdown of the pod

  (kills all containers immediately)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Memory/disk pressure notes

- If resource usage increases *very fast*, kubelet might not catch it fast enough

- For memory: this will trigger the kernel out-of-memory killer

  - containers killed by OOM are automatically restarted (no eviction)

  - eviction might happen at a later point though (if memory usage stays high)

- For disk: there is no "out-of-disk" killer, but writes will fail

  - the `write` system call fails with `errno = ENOSPC` / `No space left on device`

  - eviction typically happens shortly after (when kubelet catches up)

- When relying on disk/memory bursts a lot, using `priorityClasses` might help

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Memory/disk pressure delays

- By default, no soft threshold is defined

- Defining it requires setting both the threshold and the grace period

- Grace periods can be different for the different types of resources

- When a node is under pressure, kubelet places a `NoSchedule` taint

  (to avoid adding more pods while the pod is under pressure)

- Once the node is no longer under pressure, kubelet clears the taint

  (after waiting an extra timeout, `evictionPressureTransitionPeriod`, 5 min by default)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Accidental deletion

- Example: developer deletes the wrong Deployment, the wrong Namespace...

- **Voluntary** disruption

  (from Kubernetes' perspective!)

- Consequence: application is down

- Mitigations:

  - only deploy to production systems through e.g. gitops workflows

  - enforce peer review of changes

  - only give users limited (e.g. read-only) access to production systems

  - use canary deployments (might not catch all mistakes though!)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Bad code deployment

- Example: critical bug introduced, application crashes immediately or is non-functional

- **Voluntary** disruption

  (again, from Kubernetes' perspective!)

- Consequence: application is down

- Mitigations:

  - readiness probes can mitigate immediate crashes
    <br/>
    (rolling update continues only when enough pods are ready)

  - delayed crashes will require a rollback
    <br/>
    (manual intervention, or automated by a canary system)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Node shutdown

- Example: scaling down a cluster to save money

- **Voluntary** disruption

- Consequence:

  - all workloads running on that node are terminated

  - this might disrupt workloads that have too many replicas on that node

  - or workloads that should not be interrupted at all

- Mitigations:

  - terminate workloads one at a time, coordinating with users

--

🤔

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Node shutdown

- Example: scaling down a cluster to save money

- **Voluntary** disruption

- Consequence:

  - all workloads running on that node are terminated

  - this might disrupt workloads that have too many replicas on that node

  - or workloads that should not be interrupted at all

- Mitigations:

  - ~~terminate workloads one at a time, coordinating with users~~

  - use Pod Disruption Budgets

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Pod Disruption Budgets

- A PDB is a kind of *contract* between:

  - "admins" = folks maintaining the cluster (e.g. adding/removing/updating nodes)

  - "users" = folks deploying apps and workloads on the cluster

- A PDB expresses something like:

  *in that particular set of pods, do not "disrupt" more than X at a time*

- Examples:

  - in that set of frontend pods, do not disrupt more than 1 at a time

  - in that set of worker pods, always have at least 10 ready
    <br/>
    (do not disrupt them if it would bring down the number of ready pods below 10)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## PDB - user side

- Cluster users create a PDB with a manifest like this one:

```yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: my-pdb
spec:
  #minAvailable: 2
  #minAvailable: 90%
  maxUnavailable: 1
  #maxUnavailable: 10%
  selector:
    matchLabels:
      app: my-app


```

- The PDB must indicate either `minAvailable` or `maxUnavailable`

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Rounding logic

- Percentages are rounded **up**

- When specifying `maxUnavailble` as a percentage, this can result in a higher perecentage

  (e.g. `maxUnavailable: 50%` with 3 pods can result in 2 pods being unavailable!)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Unmanaged pods

- Specifying `minAvailable: X` works all the time

- Specifying `minAvailable: X%` or `maxUnavaiable` requires *managed pods*

  (pods that belong to a controller, e.g. Replica Set, Stateful Set...)

- This is because the PDB controller needs to know the total number of pods

  (given by the `replicas` field, not merely by counting pod objects)

- The PDB controller will try to resolve the controller using the pod selector

- If that fails, the PDB controller will emit warning events

  (visible with `kubectl describe pdb ...`)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Zero

- `maxUnavailable: 0` means "do not disrupt my pods"

- Same thing if `minAvailable` is greater than or equal to the number of pods

- In that case, cluster admins are supposed to get in touch with cluster users

- This will prevent fully automated operation

  (and some cluster admins automated systems might not honor that request)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## PDB - admin side

- As a cluster admin, we need to follow certain rules

- Only shut down (or restart) a node when no pods are running on that node

  (except system pods belonging to Daemon Sets)

- To remove pods running on a node, we should use the *eviction API*

  (which will check PDB constraints and honor them)

- To prevent new pods from being scheduled on a node, we can use a *taint*

- These operations are streamlined by `kubectl drain`, which will:

  - *cordon* the node (add a `NoSchedule` taint)

  - invoke the *eviction API* to remove pods while respecting their PDBs

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Theory vs practice

- `kubectl drain` won't evict pods using `emptyDir` volumes

  (unless the `--delete-emptydir-data` flag is passed as well)

- Make sure that `emptyDir` volumes don't hold anything important

  (they shouldn't, but... who knows!)

- Kubernetes lacks a standard way for users to express:

  *this `emptyDir` volume can/cannot be safely deleted*

- If a PDB forbids an eviction, this requires manual coordination

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

class: extra-details

## Unhealthy pod eviction policy

- By default, unhealthy pods can only be evicted if PDB allows it

  (unhealthy = running, but not ready)

- In many cases, unhealthy pods aren't healthy anyway, and can be removed

- This behavior is enabled by setting the appropriate field in the PDB manifest:
 
```yaml
spec:
  unhealthyPodEvictionPolicy: AlwaysAllow
```

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Node upgrade

- Example: upgrading kubelet or the Linux kernel on a node

- **Voluntary** disruption

- Consequence:

  - all workloads running on that node are temporarily interrupted, and restarted

  - this might disrupt these workloads

- Mitigations:

  - migrate workloads off the done first (as if we were shutting it down)

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Node upgrade notes

- Is it necessary to drain a node before doing an upgrade?

- From [the documentation][node-upgrade-docs]:

  *Draining nodes before upgrading kubelet ensures that pods are re-admitted and containers are re-created, which may be necessary to resolve some security issues or other important bugs.*

- It's *probably* safe to upgrade in-place for:

  - kernel upgrades

  - kubelet patch-level upgrades (1.X.Y → 1.X.Z)

- It's *probably* better to drain the node for minor revisions kubelet upgrades (1.X → 1.Y)

- In doubt, test extensively in staging environments!

[node-upgrade-docs]: https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/#manual-deployments

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

## Manual rescheduling

- Example: moving workloads around to accommodate noisy neighbors or other issues

  (e.g. pod X is doing a lot of disk I/O and this is starving other pods)

- **Voluntary** disruption

- Consequence:

  - the moved workloads are temporarily interrupted

- Mitigations:

  - define an appropriate number of replicas, declare PDBs

  - use the [eviction API][eviction-API] to move workloads

[eviction-API]: https://kubernetes.io/docs/concepts/scheduling-eviction/api-eviction/

???

:EN:- Voluntary and involuntary disruptions
:EN:- Pod Disruption Budgets
:FR:- "Disruptions" volontaires et involontaires
:FR:- Pod Disruption Budgets

.debug[[k8s/disruptions.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/disruptions.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-the-horizontal-pod-autoscaler
class: title

 The Horizontal Pod Autoscaler

.nav[
[Previous part](#toc-disruptions)
|
[Back to table of contents](#toc-part-12)
|
[Next part](#toc-collecting-metrics-with-prometheus)
]

.debug[(automatically generated title slide)]

---
# The Horizontal Pod Autoscaler

- What is the Horizontal Pod Autoscaler, or HPA?

- It is a controller that can perform *horizontal* scaling automatically

- Horizontal scaling = changing the number of replicas

  (adding/removing pods)

- Vertical scaling = changing the size of individual replicas

  (increasing/reducing CPU and RAM per pod)

- Cluster scaling = changing the size of the cluster

  (adding/removing nodes)

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Principle of operation

- Each HPA resource (or "policy") specifies:

  - which object to monitor and scale (e.g. a Deployment, ReplicaSet...)

  - min/max scaling ranges (the max is a safety limit!)

  - a target resource usage (e.g. the default is CPU=80%)

- The HPA continuously monitors the CPU usage for the related object

- It computes how many pods should be running:

  `TargetNumOfPods = ceil(sum(CurrentPodsCPUUtilization) / Target)`

- It scales the related object up/down to this target number of pods

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Pre-requirements

- The metrics server needs to be running

  (i.e. we need to be able to see pod metrics with `kubectl top pods`)

- The pods that we want to autoscale need to have resource requests

  (because the target CPU% is not absolute, but relative to the request)

- The latter actually makes a lot of sense:

  - if a Pod doesn't have a CPU request, it might be using 10% of CPU...

  - ...but only because there is no CPU time available!

  - this makes sure that we won't add pods to nodes that are already resource-starved

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Testing the HPA

- We will start a CPU-intensive web service

- We will send some traffic to that service

- We will create an HPA policy

- The HPA will automatically scale up the service for us

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## A CPU-intensive web service

- Let's use `jpetazzo/busyhttp`

  (it is a web server that will use 1s of CPU for each HTTP request)

.lab[

- Deploy the web server:
  ```bash
  kubectl create deployment busyhttp --image=jpetazzo/busyhttp
  ```

- Expose it with a ClusterIP service:
  ```bash
  kubectl expose deployment busyhttp --port=80
  ```

- Get the ClusterIP allocated to the service:
  ```bash
  kubectl get svc busyhttp
  ```

]

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Monitor what's going on

- Let's start a bunch of commands to watch what is happening

.lab[

- Monitor pod CPU usage:
  ```bash
  watch kubectl top pods -l app=busyhttp
  ```

<!--
```wait NAME```
```tmux split-pane -v```
```bash CLUSTERIP=$(kubectl get svc busyhttp -o jsonpath={.spec.clusterIP})```
-->

- Monitor service latency:
  ```bash
  httping http://`$CLUSTERIP`/
  ```

<!--
```wait connected to```
```tmux split-pane -v```
-->

- Monitor cluster events:
  ```bash
  kubectl get events -w
  ```

<!--
```wait Normal```
```tmux split-pane -v```
```bash CLUSTERIP=$(kubectl get svc busyhttp -o jsonpath={.spec.clusterIP})```
-->

]

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Send traffic to the service

- We will use `ab` (Apache Bench) to send traffic

.lab[

- Send a lot of requests to the service, with a concurrency level of 3:
  ```bash
  ab -c 3 -n 100000 http://`$CLUSTERIP`/
  ```

<!--
```wait be patient```
```tmux split-pane -v```
```tmux selectl even-vertical```
-->

]

The latency (reported by `httping`) should increase above 3s.

The CPU utilization should increase to 100%.

(The server is single-threaded and won't go above 100%.)

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Create an HPA policy

- There is a helper command to do that for us: `kubectl autoscale`

.lab[

- Create the HPA policy for the `busyhttp` deployment:
  ```bash
  kubectl autoscale deployment busyhttp --max=10
  ```

]

By default, it will assume a target of 80% CPU usage.

This can also be set with `--cpu-percent=`.

--

*The autoscaler doesn't seem to work. Why?*

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## What did we miss?

- The events stream gives us a hint, but to be honest, it's not very clear:

  `missing request for cpu`

- We forgot to specify a resource request for our Deployment!

- The HPA target is not an absolute CPU%

- It is relative to the CPU requested by the pod

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Adding a CPU request

- Let's edit the deployment and add a CPU request

- Since our server can use up to 1 core, let's request 1 core

.lab[

- Edit the Deployment definition:
  ```bash
  kubectl edit deployment busyhttp
  ```

<!--
```wait Please edit```
```keys /resources```
```key ^J```
```keys $xxxo  requests:```
```key ^J```
```key Space```
```key Space```
```keys cpu: "1"```
```key Escape```
```keys :wq```
```key ^J```
-->

- In the `containers` list, add the following block:
  ```yaml
    resources:
      requests:
        cpu: "1"
  ```

]

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Results

- After saving and quitting, a rolling update happens

  (if `ab` or `httping` exits, make sure to restart it)

- It will take a minute or two for the HPA to kick in:

  - the HPA runs every 30 seconds by default

  - it needs to gather metrics from the metrics server first

- If we scale further up (or down), the HPA will react after a few minutes:

  - it won't scale up if it already scaled in the last 3 minutes

  - it won't scale down if it already scaled in the last 5 minutes

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## What about other metrics?

- The HPA in API group `autoscaling/v1` only supports CPU scaling

- The HPA in API group `autoscaling/v2beta2` supports metrics from various API groups:

  - metrics.k8s.io, aka metrics server (per-Pod CPU and RAM)

  - custom.metrics.k8s.io, custom metrics per Pod

  - external.metrics.k8s.io, external metrics (not associated to Pods)

- Kubernetes doesn't implement any of these API groups

- Using these metrics requires [registering additional APIs](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-metrics-apis)

- The metrics provided by metrics server are standard; everything else is custom

- For more details, see [this great blog post](https://medium.com/uptime-99/kubernetes-hpa-autoscaling-with-custom-and-external-metrics-da7f41ff7846) or [this talk](https://www.youtube.com/watch?v=gSiGFH4ZnS8)

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

## Cleanup

- Since `busyhttp` uses CPU cycles, let's stop it before moving on

.lab[

- Delete the `busyhttp` Deployment:
  ```bash
  kubectl delete deployment busyhttp
  ```

<!--
```key ^D```
```key ^C```
```key ^D```
```key ^C```
```key ^D```
```key ^C```
```key ^D```
```key ^C```
-->

]

???

:EN:- Auto-scaling resources
:FR:- *Auto-scaling* (dimensionnement automatique) des ressources

.debug[[k8s/horizontal-pod-autoscaler.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/horizontal-pod-autoscaler.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-collecting-metrics-with-prometheus
class: title

 Collecting metrics with Prometheus

.nav[
[Previous part](#toc-the-horizontal-pod-autoscaler)
|
[Back to table of contents](#toc-part-13)
|
[Next part](#toc-extending-the-kubernetes-api)
]

.debug[(automatically generated title slide)]

---
# Collecting metrics with Prometheus

- Prometheus is an open-source monitoring system including:

  - multiple *service discovery* backends to figure out which metrics to collect

  - a *scraper* to collect these metrics

  - an efficient *time series database* to store these metrics

  - a specific query language (PromQL) to query these time series

  - an *alert manager* to notify us according to metrics values or trends

- We are going to use it to collect and query some metrics on our Kubernetes cluster

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Why Prometheus?

- We don't endorse Prometheus more or less than any other system

- It's relatively well integrated within the cloud-native ecosystem

- It can be self-hosted (this is useful for tutorials like this)

- It can be used for deployments of varying complexity:

  - one binary and 10 lines of configuration to get started

  - all the way to thousands of nodes and millions of metrics

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Exposing metrics to Prometheus

- Prometheus obtains metrics and their values by querying *exporters*

- An exporter serves metrics over HTTP, in plain text

- This is what the *node exporter* looks like:

  http://demo.robustperception.io:9100/metrics

- Prometheus itself exposes its own internal metrics, too:

  http://demo.robustperception.io:9090/metrics

- If you want to expose custom metrics to Prometheus:

  - serve a text page like these, and you're good to go

  - libraries are available in various languages to help with quantiles etc.

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## How Prometheus gets these metrics

- The *Prometheus server* will *scrape* URLs like these at regular intervals

  (by default: every minute; can be more/less frequent)

- The list of URLs to scrape (the *scrape targets*) is defined in configuration

.footnote[Worried about the overhead of parsing a text format?
<br/>
Check this [comparison](https://github.com/RichiH/OpenMetrics/blob/master/markdown/protobuf_vs_text.md) of the text format with the (now deprecated) protobuf format!]

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Defining scrape targets

This is maybe the simplest configuration file for Prometheus:
```yaml
scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
```

- In this configuration, Prometheus collects its own internal metrics

- A typical configuration file will have multiple `scrape_configs`

- In this configuration, the list of targets is fixed

- A typical configuration file will use dynamic service discovery

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Service discovery

This configuration file will leverage existing DNS `A` records:
```yaml
scrape_configs:
  - ...
  - job_name: 'node'
    dns_sd_configs:
      - names: ['api-backends.dc-paris-2.enix.io']
        type: 'A'
        port: 9100
```

- In this configuration, Prometheus resolves the provided name(s)

  (here, `api-backends.dc-paris-2.enix.io`)

- Each resulting IP address is added as a target on port 9100

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Dynamic service discovery

- In the DNS example, the names are re-resolved at regular intervals

- As DNS records are created/updated/removed, scrape targets change as well

- Existing data (previously collected metrics) is not deleted

- Other service discovery backends work in a similar fashion

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Other service discovery mechanisms

- Prometheus can connect to e.g. a cloud API to list instances

- Or to the Kubernetes API to list nodes, pods, services ...

- Or a service like Consul, Zookeeper, etcd, to list applications

- The resulting configurations files are *way more complex*

  (but don't worry, we won't need to write them ourselves)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Time series database

- We could wonder, "why do we need a specialized database?"

- One metrics data point = metrics ID + timestamp + value

- With a classic SQL or noSQL data store, that's at least 160 bits of data + indexes

- Prometheus is way more efficient, without sacrificing performance

  (it will even be gentler on the I/O subsystem since it needs to write less)

- Would you like to know more? Check this video:

  [Storage in Prometheus 2.0](https://www.youtube.com/watch?v=C4YV-9CrawA) by [Goutham V](https://twitter.com/putadent) at DC17EU

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Checking if Prometheus is installed

- Before trying to install Prometheus, let's check if it's already there

.lab[

- Look for services with a label `app=prometheus` across all namespaces:
  ```bash
  kubectl get services --selector=app=prometheus --all-namespaces
  ```

]

If we see a `NodePort` service called `prometheus-server`, we're good!

(We can then skip to "Connecting to the Prometheus web UI".)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Running Prometheus on our cluster

We need to:

- Run the Prometheus server in a pod

  (using e.g. a Deployment to ensure that it keeps running)

- Expose the Prometheus server web UI (e.g. with a NodePort)

- Run the *node exporter* on each node (with a Daemon Set)

- Set up a Service Account so that Prometheus can query the Kubernetes API

- Configure the Prometheus server

  (storing the configuration in a Config Map for easy updates)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Helm charts to the rescue

- To make our lives easier, we are going to use a Helm chart

- The Helm chart will take care of all the steps explained above

  (including some extra features that we don't need, but won't hurt)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Step 1: install Helm

- If we already installed Helm earlier, this command won't break anything

.lab[

- Install the Helm CLI:
  ```bash
  curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get-helm-3 \
  | bash
  ```

]

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Step 2: install Prometheus

- The following command, just like the previous ones, is idempotent

  (it won't error out if Prometheus is already installed)

.lab[

- Install Prometheus on our cluster:
  ```bash
    helm upgrade prometheus --install prometheus \
        --repo https://prometheus-community.github.io/helm-charts \
        --namespace prometheus --create-namespace \
        --set server.service.type=NodePort \
        --set server.service.nodePort=30090 \
        --set server.persistentVolume.enabled=false \
        --set alertmanager.enabled=false
  ```

]

Curious about all these flags? They're explained in the next slide.

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Explaining all the Helm flags

- `helm upgrade prometheus` → upgrade the release named `prometheus`
  <br/>
  (a "release" is an instance of an app deployed with Helm)

- `--install` → if it doesn't exist, install it (instead of upgrading)

- `prometheus` → use the chart named `prometheus`

- `--repo ...` → the chart is located on the following repository

- `--namespace prometheus` → put it in that specific namespace

- `--create-namespace` → create the namespace if it doesn't exist

- `--set ...` → here are some *values* to be used when rendering the chart's templates

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Values for the Prometheus chart

Helm *values* are parameters to customize our installation.

- `server.service.type=NodePort` → expose the Prometheus server with a NodePort

- `server.service.nodePort=30090` → set the specific NodePort number to use

- `server.persistentVolume.enabled=false` → do not use a PersistentVolumeClaim

- `alertmanager.enabled=false` → disable the alert manager entirely

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Connecting to the Prometheus web UI

- Let's connect to the web UI and see what we can do

.lab[

- Figure out the NodePort that was allocated to the Prometheus server:
  ```bash
  kubectl get svc --all-namespaces | grep prometheus-server
  ```

- With your browser, connect to that port


- It should be 30090 if we just installed Prometheus with the Helm chart!

]

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Querying some metrics

- This is easy... if you are familiar with PromQL

.lab[

- Click on "Graph", and in "expression", paste the following:
  ```
    sum by (instance) (
      irate(
        container_cpu_usage_seconds_total{
          pod=~"worker.*"
          }[5m]
      )
    )
  ```

]

- Click on the blue "Execute" button and on the "Graph" tab just below

- We see the cumulated CPU usage of worker pods for each node
  <br/>
  (if we just deployed Prometheus, there won't be much data to see, though)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Getting started with PromQL

- We can't learn PromQL in just 5 minutes

- But we can cover the basics to get an idea of what is possible

  (and have some keywords and pointers)

- We are going to break down the query above

  (building it one step at a time)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Graphing one metric across all tags

This query will show us CPU usage across all containers:
```
container_cpu_usage_seconds_total
```

- The suffix of the metrics name tells us:

  - the unit (seconds of CPU)

  - that it's the total used since the container creation

- Since it's a "total," it is an increasing quantity

  (we need to compute the derivative if we want e.g. CPU % over time)

- We see that the metrics retrieved have *tags* attached to them

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Selecting metrics with tags

This query will show us only metrics for worker containers:
```
container_cpu_usage_seconds_total{pod=~"worker.*"}
```

- The `=~` operator allows regex matching

- We select all the pods with a name starting with `worker`

  (it would be better to use labels to select pods; more on that later)

- The result is a smaller set of containers

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Transforming counters in rates

This query will show us CPU usage % instead of total seconds used:
```
100*irate(container_cpu_usage_seconds_total{pod=~"worker.*"}[5m])
```

- The [`irate`](https://prometheus.io/docs/prometheus/latest/querying/functions/#irate) operator computes the "per-second instant rate of increase"

  - `rate` is similar but allows decreasing counters and negative values

  - with `irate`, if a counter goes back to zero, we don't get a negative spike

- The `[5m]` tells how far to look back if there is a gap in the data

- And we multiply with `100*` to get CPU % usage

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Aggregation operators

This query sums the CPU usage per node:
```
sum by (instance) (
  irate(container_cpu_usage_seconds_total{pod=~"worker.*"}[5m])
)
```

- `instance` corresponds to the node on which the container is running

- `sum by (instance) (...)` computes the sum for each instance

- Note: all the other tags are collapsed

  (in other words, the resulting graph only shows the `instance` tag)

- PromQL supports many more [aggregation operators](https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## What kind of metrics can we collect?

- Node metrics (related to physical or virtual machines)

- Container metrics (resource usage per container)

- Databases, message queues, load balancers, ...

  (check out this [list of exporters](https://prometheus.io/docs/instrumenting/exporters/)!)

- Instrumentation (=deluxe `printf` for our code)

- Business metrics (customers served, revenue, ...)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Node metrics

- CPU, RAM, disk usage on the whole node

- Total number of processes running, and their states

- Number of open files, sockets, and their states

- I/O activity (disk, network), per operation or volume

- Physical/hardware (when applicable): temperature, fan speed...

- ...and much more!

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Container metrics

- Similar to node metrics, but not totally identical

- RAM breakdown will be different

  - active vs inactive memory
  - some memory is *shared* between containers, and specially accounted for

- I/O activity is also harder to track

  - async writes can cause deferred "charges"
  - some page-ins are also shared between containers

For details about container metrics, see:
<br/>
http://jpetazzo.github.io/2013/10/08/docker-containers-metrics/

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Application metrics

- Arbitrary metrics related to your application and business

- System performance: request latency, error rate...

- Volume information: number of rows in database, message queue size...

- Business data: inventory, items sold, revenue...

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## Detecting scrape targets

- Prometheus can leverage Kubernetes service discovery

  (with proper configuration)

- Services or pods can be annotated with:

  - `prometheus.io/scrape: true` to enable scraping
  - `prometheus.io/port: 9090` to indicate the port number
  - `prometheus.io/path: /metrics` to indicate the URI (`/metrics` by default)

- Prometheus will detect and scrape these (without needing a restart or reload)

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## Querying labels

- What if we want to get metrics for containers belonging to a pod tagged `worker`?

- The cAdvisor exporter does not give us Kubernetes labels

- Kubernetes labels are exposed through another exporter

- We can see Kubernetes labels through metrics `kube_pod_labels`

  (each container appears as a time series with constant value of `1`)

- Prometheus *kind of* supports "joins" between time series

- But only if the names of the tags match exactly

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: extra-details

## What if the tags don't match?

- Older versions of cAdvisor exporter used tag `pod_name` for the name of a pod

- The Kubernetes service endpoints exporter uses tag `pod` instead

- See [this blog post](https://www.robustperception.io/exposing-the-software-version-to-prometheus) or [this other one](https://www.weave.works/blog/aggregating-pod-resource-cpu-memory-usage-arbitrary-labels-prometheus/) to see how to perform "joins"

- Note that Prometheus cannot "join" time series with different labels

  (see [Prometheus issue #2204](https://github.com/prometheus/prometheus/issues/2204) for the rationale)

- There is a workaround involving relabeling, but it's "not cheap"

  - see [this comment](https://github.com/prometheus/prometheus/issues/2204#issuecomment-261515520) for an overview

  - or [this blog post](https://5pi.de/2017/11/09/use-prometheus-vector-matching-to-get-kubernetes-utilization-across-any-pod-label/) for a complete description of the process

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

## In practice

- Grafana is a beautiful (and useful) frontend to display all kinds of graphs

- Not everyone needs to know Prometheus, PromQL, Grafana, etc.

- But in a team, it is valuable to have at least one person who know them

- That person can set up queries and dashboards for the rest of the team

- It's a little bit like knowing how to optimize SQL queries, Dockerfiles...

  Don't panic if you don't know these tools!

  ...But make sure at least one person in your team is on it 💯

???

:EN:- Collecting metrics with Prometheus
:FR:- Collecter des métriques avec Prometheus

.debug[[k8s/prometheus.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/prometheus.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-extending-the-kubernetes-api
class: title

 Extending the Kubernetes API

.nav[
[Previous part](#toc-collecting-metrics-with-prometheus)
|
[Back to table of contents](#toc-part-13)
|
[Next part](#toc-custom-resource-definitions)
]

.debug[(automatically generated title slide)]

---
# Extending the Kubernetes API

There are multiple ways to extend the Kubernetes API.

We are going to cover:

- Controllers

- Dynamic Admission Webhooks

- Custom Resource Definitions (CRDs)

- The Aggregation Layer

But first, let's re(re)visit the API server ...

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Revisiting the API server

- The Kubernetes API server is a central point of the control plane

- Everything connects to the API server:

  - users (that's us, but also automation like CI/CD)

  - kubelets

  - network components (e.g. `kube-proxy`, pod network, NPC)

  - controllers; lots of controllers

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Some controllers

- `kube-controller-manager` runs built-on controllers

  (watching Deployments, Nodes, ReplicaSets, and much more)

- `kube-scheduler` runs the scheduler

  (it's conceptually not different from another controller)

- `cloud-controller-manager` takes care of "cloud stuff"

  (e.g. provisioning load balancers, persistent volumes...)

- Some components mentioned above are also controllers

  (e.g. Network Policy Controller)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## More controllers

- Cloud resources can also be managed by additional controllers

  (e.g. the [AWS Load Balancer Controller](https://github.com/kubernetes-sigs/aws-load-balancer-controller))

- Leveraging Ingress resources requires an Ingress Controller

  (many options available here; we can even install multiple ones!)

- Many add-ons (including CRDs and operators) have controllers as well

🤔 *What's even a controller ?!?*

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## What's a controller?

According to the [documentation](https://kubernetes.io/docs/concepts/architecture/controller/):

*Controllers are **control loops** that<br/>
**watch** the state of your cluster,<br/>
then make or request changes where needed.*

*Each controller tries to move the current cluster state closer to the desired state.*

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## What controllers do

- Watch resources

- Make changes:

  - purely at the API level (e.g. Deployment, ReplicaSet controllers)

  - and/or configure resources (e.g. `kube-proxy`)

  - and/or provision resources (e.g. load balancer controller)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Extending Kubernetes with controllers

- Random example:

  - watch resources like Deployments, Services ...

  - read annotations to configure monitoring

- Technically, this is not extending the API

  (but it can still be very useful!)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Other ways to extend Kubernetes

- Prevent or alter API requests before resources are committed to storage:

  *Admission Control*

- Create new resource types leveraging Kubernetes storage facilities:

  *Custom Resource Definitions*

- Create new resource types with different storage or different semantics:

  *Aggregation Layer*

- Spoiler alert: often, we will combine multiple techniques

  (and involve controllers as well!)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Admission controllers

- Admission controllers can vet or transform API requests

- The diagram on the next slide shows the path of an API request

  (courtesy of Banzai Cloud)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

class: pic

![API request lifecycle](images/api-request-lifecycle.png)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Types of admission controllers

- *Validating* admission controllers can accept/reject the API call

- *Mutating* admission controllers can modify the API request payload

- Both types can also trigger additional actions

  (e.g. automatically create a Namespace if it doesn't exist)

- There are a number of built-in admission controllers

  (see [documentation](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do) for a list)

- We can also dynamically define and register our own

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

class: extra-details

## Some built-in admission controllers

- ServiceAccount:

  automatically adds a ServiceAccount to Pods that don't explicitly specify one

- LimitRanger:

  applies resource constraints specified by LimitRange objects when Pods are created

- NamespaceAutoProvision:

  automatically creates namespaces when an object is created in a non-existent namespace

*Note: #1 and #2 are enabled by default; #3 is not.*

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Dynamic Admission Control

- We can set up *admission webhooks* to extend the behavior of the API server

- The API server will submit incoming API requests to these webhooks

- These webhooks can be *validating* or *mutating*

- Webhooks can be set up dynamically (without restarting the API server)

- To setup a dynamic admission webhook, we create a special resource:

  a `ValidatingWebhookConfiguration` or a `MutatingWebhookConfiguration`

- These resources are created and managed like other resources

  (i.e. `kubectl create`, `kubectl get`...)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Webhook Configuration

- A ValidatingWebhookConfiguration or MutatingWebhookConfiguration contains:

  - the address of the webhook

  - the authentication information to use with the webhook

  - a list of rules

- The rules indicate for which objects and actions the webhook is triggered

  (to avoid e.g. triggering webhooks when setting up webhooks)

- The webhook server can be hosted in or out of the cluster

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Dynamic Admission Examples

- Policy control

  ([Kyverno](https://kyverno.io/),
  [Open Policy Agent](https://www.openpolicyagent.org/docs/latest/))

- Sidecar injection

  (Used by some service meshes)

- Type validation

  (More on this later, in the CRD section)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Kubernetes API types

- Almost everything in Kubernetes is materialized by a resource

- Resources have a type (or "kind")

  (similar to strongly typed languages)

- We can see existing types with `kubectl api-resources`

- We can list resources of a given type with `kubectl get <type>`

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Creating new types

- We can create new types with Custom Resource Definitions (CRDs)

- CRDs are created dynamically

  (without recompiling or restarting the API server)

- CRDs themselves are resources:

  - we can create a new type with `kubectl create` and some YAML

  - we can see all our custom types with `kubectl get crds`

- After we create a CRD, the new type works just like built-in types

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Examples

- Representing composite resources

  (e.g. clusters like databases, messages queues ...)

- Representing external resources

  (e.g. virtual machines, object store buckets, domain names ...)

- Representing configuration for controllers and operators

  (e.g. custom Ingress resources, certificate issuers, backups ...)

- Alternate representations of other objects; services and service instances

  (e.g. encrypted secret, git endpoints ...)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## The aggregation layer

- We can delegate entire parts of the Kubernetes API to external servers

- This is done by creating APIService resources

  (check them with `kubectl get apiservices`!)

- The APIService resource maps a type (kind) and version to an external service

- All requests concerning that type are sent (proxied) to the external service

- This allows to have resources like CRDs, but that aren't stored in etcd

- Example: `metrics-server`

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Why?

- Using a CRD for live metrics would be extremely inefficient

  (etcd **is not** a metrics store; write performance is way too slow)

- Instead, `metrics-server`:

  - collects metrics from kubelets

  - stores them in memory

  - exposes them as PodMetrics and NodeMetrics (in API group metrics.k8s.io)

  - is registered as an APIService

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Drawbacks

- Requires a server

- ... that implements a non-trivial API (aka the Kubernetes API semantics)

- If we need REST semantics, CRDs are probably way simpler

- *Sometimes* synchronizing external state with CRDs might do the trick

  (unless we want the external state to be our single source of truth)

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

## Documentation

- [Custom Resource Definitions: when to use them](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)

- [Custom Resources Definitions: how to use them](https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/)

- [Built-in Admission Controllers](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/)

- [Dynamic Admission Controllers](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/)

- [Aggregation Layer](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)

???

:EN:- Overview of Kubernetes API extensions
:FR:- Comment étendre l'API Kubernetes

.debug[[k8s/extending-api.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/extending-api.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-custom-resource-definitions
class: title

 Custom Resource Definitions

.nav[
[Previous part](#toc-extending-the-kubernetes-api)
|
[Back to table of contents](#toc-part-13)
|
[Next part](#toc-operators)
]

.debug[(automatically generated title slide)]

---
# Custom Resource Definitions

- CRDs are one of the (many) ways to extend the API

- CRDs can be defined dynamically

  (no need to recompile or reload the API server)

- A CRD is defined with a CustomResourceDefinition resource

  (CustomResourceDefinition is conceptually similar to a *metaclass*)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Creating a CRD

- We will create a CRD to represent different recipes of pizzas

- We will be able to run `kubectl get pizzas` and it will list the recipes

- Creating/deleting recipes won't do anything else

  (because we won't implement a *controller*)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## A bit of history

Things related to Custom Resource Definitions:

- Kubernetes 1.??: `apiextensions.k8s.io/v1beta1` introduced

- Kubernetes 1.16: `apiextensions.k8s.io/v1` introduced

- Kubernetes 1.22: `apiextensions.k8s.io/v1beta1` [removed][changes-in-122]

- Kubernetes 1.25: [CEL validation rules available in beta][crd-validation-rules-beta]

- Kubernetes 1.28: [validation ratcheting][validation-ratcheting] in [alpha][feature-gates]

- Kubernetes 1.29: [CEL validation rules available in GA][cel-validation-rules]

- Kubernetes 1.30: [validation ratcheting][validation-ratcheting] in [beta][feature-gates]; enabled by default

[crd-validation-rules-beta]: https://kubernetes.io/blog/2022/09/23/crd-validation-rules-beta/
[cel-validation-rules]: https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation-rules
[validation-ratcheting]: https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/4008-crd-ratcheting
[feature-gates]: https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/#feature-gates-for-alpha-or-beta-features
[changes-in-122]: https://kubernetes.io/blog/2021/07/14/upcoming-changes-in-kubernetes-1-22/

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## First slice of pizza

```yaml
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: pizzas.container.training
spec:
  group: container.training
  version: v1alpha1
  scope: Namespaced
  names:
    plural: pizzas
    singular: pizza
    kind: Pizza
    shortNames:
    - piz

```

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## The joys of API deprecation

- Unfortunately, the CRD manifest on the previous slide is deprecated!

- It is using `apiextensions.k8s.io/v1beta1`, which is dropped in Kubernetes 1.22

- We need to use `apiextensions.k8s.io/v1`, which is a little bit more complex

  (a few optional things become mandatory, see [this guide](https://kubernetes.io/docs/reference/using-api/deprecation-guide/#customresourcedefinition-v122) for details)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Second slice of pizza

- The next slide will show file [k8s/pizza-2.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/pizza-2.yaml)

- Note the `spec.versions` list

  - we need exactly one version with `storage: true`

  - we can have multiple versions with `served: true`

- `spec.versions[].schema.openAPI3Schema` is required

  (and must be a valid OpenAPI schema; here it's a trivial one)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: pizzas.container.training
spec:
  group: container.training
  scope: Namespaced
  names:
    plural: pizzas
    singular: pizza
    kind: Pizza
    shortNames:
    - piz
  versions:
  - name: v1alpha1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object

```

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Baking some pizza

- Let's create the Custom Resource Definition for our Pizza resource

.lab[

- Load the CRD:
  ```bash
  kubectl apply -f ~/container.training/k8s/pizza-2.yaml
  ```

- Confirm that it shows up:
  ```bash
  kubectl get crds
  ```

]

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Creating custom resources

The YAML below defines a resource using the CRD that we just created:

```yaml
kind: Pizza
apiVersion: container.training/v1alpha1
metadata:
  name: hawaiian
spec:
  toppings: [ cheese, ham, pineapple ]
```

.lab[

- Try to create a few pizza recipes:
  ```bash
  kubectl apply -f ~/container.training/k8s/pizzas.yaml
  ```

]

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Type validation

- Recent versions of Kubernetes will issue errors about unknown fields

- We need to improve our OpenAPI schema

  (to add e.g. the `spec.toppings` field used by our pizza resources)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Creating a bland pizza

- Let's try to create a pizza anyway!

.lab[

- Only provide the most basic YAML manifest:
  ```bash
    kubectl create -f- <<EOF
    kind: Pizza
    apiVersion: container.training/v1alpha1
    metadata:
      name: hawaiian
    EOF
  ```

]

- That should work! (As long as we don't try to add pineapple😁)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Third slice of pizza

- Let's add a full OpenAPI v3 schema to our Pizza CRD

- We'll require a field `spec.sauce` which will be a string

- And a field `spec.toppings` which will have to be a list of strings

.lab[

- Update our pizza CRD:
  ```bash
  kubectl apply -f ~/container.training/k8s/pizza-3.yaml
  ```

- Load our pizza recipes:
  ```bash
  kubectl apply -f ~/container.training/k8s/pizzas.yaml
  ```

]

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Viewing custom resources

- By default, `kubectl get` only shows name and age of custom resources

.lab[

- View the pizza recipes that we just created:
  ```bash
  kubectl get pizzas
  ```

]

- Let's see how we can improve that display!

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Additional printer columns

- We can tell Kubernetes which columns to show:
  ```yaml
    additionalPrinterColumns:
    - jsonPath: .spec.sauce
      name: Sauce
      type: string
    - jsonPath: .spec.toppings
      name: Toppings
      type: string
  ```

- There is an updated CRD in [k8s/pizza-4.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/pizza-4.yaml)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Using additional printer columns

- Let's update our CRD!

.lab[

- Update the CRD:
  ```bash
  kubectl apply -f ~/container.training/k8s/pizza-4.yaml
  ```

- Look at our Pizza resources:
  ```bash
  kubectl get pizzas
  ```

]

Note: we can update a CRD without having to re-create the corresponding resources.

(Good news, right?)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Validation woes

- Let's check what happens if we try to update our pizzas

.lab[

- Try to add a label:
  ```bash
  kubectl label pizza --all deliciousness=9001
  ```

]

--

- It works for the pizzas that have `sauce` and `toppings`, but not the other one!

- The other one doesn't pass validation, and *can't be modified*

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## First, let's fix this!

- Option 1: delete the pizza

  *(deletion isn't subject to validation)*

- Option 2: update the pizza to add `sauce` and `toppings`

  *(writing a pizza that passes validation is fine)*

- Option 3: relax the validation rules

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Next, explain what's happening

- Some of the pizzas that we defined earlier *do not* pass validation

- How is that possible?

--

- Validation happens at *admission*

  (when resources get written into the database)

- Therefore, we can have "invalid" resources in etcd

  (they are invalid from the CRD perspective, but the CRD can be changed)

🤔 How should we handle that ?

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Versions

- If the data format changes, we can roll out a new version of the CRD

  (e.g. go from `v1alpha1` to `v1alpha2`)

- In a CRD we can specify the versions that exist, that are *served*, and *stored*

  - multiple versions can be *served*

  - only one can be *stored*

- Kubernetes doesn't automatically migrate the content of the database

- However, it can convert between versions when resources are read/written

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Conversion

- When *creating* a new resource, the *stored* version is used

  (if we create it with another version, it gets converted)

- When *getting* or *watching* resources, the *requested* version is used

  (if it is stored with another version, it gets converted)

- By default, "conversion" only changes the `apiVersion` field

- ... But we can register *conversion webhooks*

  (see [that doc page](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#webhook-conversion) for details)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

class: extra-details

## Migrating database content

- We need to *serve* a version as long as we *store* objects in that version

  (=as long as the database has at least one object with that version)

- If we want to "retire" a version, we need to migrate these objects first

- All we have to do is to read and re-write them

  (the [kube-storage-version-migrator](https://github.com/kubernetes-sigs/kube-storage-version-migrator) tool can help)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Validation ratcheting

- Good news: it's not always necessary to introduce new versions

  (and to write the associated conversion webhooks)

- *Validation ratcheting allows updates to custom resources that fail validation to succeed if the validation errors were on unchanged keypaths*

- In other words: allow changes that don't introduce further validation errors

- This was introduced in Kubernetes 1.28 (alpha), enabled by default in 1.30 (beta)

- The rules are actually a bit more complex

- Another (maybe more accurate) explanation: allow to tighten or loosen some field definitions

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Validation ratcheting example

- Let's change the data schema so that the sauce can only be `red` or `white`

- This will be implemented by [k8s/pizza-5.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/pizza-5.yaml)

.lab[

- Update the Pizza CRD:
  ```bash
  kubectl apply -f ~/container.training/k8s/pizza-5.yaml
  ```

]

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Testing validation ratcheting

- This should work with Kubernetes 1.30 and above

  (but give an error for the `brownie` pizza with previous versions of K8S)

.lab[

- Add another label:
  ```bash
  kubectl label pizzas --all food=definitely
  ```

]

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## Even better data validation

- If we need more complex data validation, we can use a validating webhook

- Use cases:

  - validating a "version" field for a database engine

  - validating that the number of e.g. coordination nodes is even

  - preventing inconsistent or dangerous changes
    <br/>
    (e.g. major version downgrades)

  - checking a key or certificate format or validity

  - and much more!

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## CRDs in the wild

- [gitkube](https://storage.googleapis.com/gitkube/gitkube-setup-stable.yaml)

- [A redis operator](https://github.com/amaizfinance/redis-operator/blob/master/deploy/crds/k8s_v1alpha1_redis_crd.yaml)

- [cert-manager](https://github.com/jetstack/cert-manager/releases/download/v1.0.4/cert-manager.yaml)

*How big are these YAML files?*

*What's the size (e.g. in lines) of each resource?*

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## CRDs in practice

- Production-grade CRDs can be extremely verbose

  (because of the openAPI schema validation)

- This can (and usually will) be managed by a framework

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## (Ab)using the API server

- If we need to store something "safely" (as in: in etcd), we can use CRDs

- This gives us primitives to read/write/list objects (and optionally validate them)

- The Kubernetes API server can run on its own

  (without the scheduler, controller manager, and kubelets)

- By loading CRDs, we can have it manage totally different objects

  (unrelated to containers, clusters, etc.)

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

## What's next?

- Creating a basic CRD is relatively straightforward

- But CRDs generally require a *controller* to do anything useful

- The controller will typically *watch* our custom resources

  (and take action when they are created/updated)

- Most serious use-cases will also require *validation web hooks*

- When our CRD data format evolves, we'll also need *conversion web hooks*

- Doing all that work manually is tedious; use a framework!

???

:EN:- Custom Resource Definitions (CRDs)
:FR:- Les CRDs *(Custom Resource Definitions)*

.debug[[k8s/crd.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/crd.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-1.jpg)]

---

name: toc-operators
class: title

 Operators

.nav[
[Previous part](#toc-custom-resource-definitions)
|
[Back to table of contents](#toc-part-13)
|
[Next part](#toc-an-elasticsearch-operator)
]

.debug[(automatically generated title slide)]

---
# Operators

The Kubernetes documentation describes the [Operator pattern] as follows:

*Operators are software extensions to Kubernetes that make use of custom resources to manage applications and their components. Operators follow Kubernetes principles, notably the control loop.*

Another good definition from [CoreOS](https://coreos.com/blog/introducing-operators.html):

*An operator represents **human operational knowledge in software,**
<br/>
to reliably manage an application.*

There are many different use cases spanning different domains; but the general idea is:

*Manage some resources (that reside inside our outside the cluster),
<br/>
using Kubernetes manifests and tooling.*

[Operator pattern]: https://kubernetes.io/docs/concepts/extend-kubernetes/operator/

.debug[[k8s/operators.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators.md)]
---

## Some uses cases

- Managing external resources ([AWS], [GCP], [KubeVirt]...)

- Setting up database replication or distributed systems
  <br/>
  (Cassandra, Consul, CouchDB, ElasticSearch, etcd, Kafka, MongoDB, MySQL, PostgreSQL, RabbitMQ, Redis, ZooKeeper...)

- Running and configuring CI/CD
  <br/>
  ([ArgoCD], [Flux]), backups ([Velero]), policies ([Gatekeeper], [Kyverno])...

- Automating management of certificates and secrets
  <br/>
  ([cert-manager]), secrets ([External Secrets Operator], [Sealed Secrets]...)

- Configuration of cluster components ([Istio], [Prometheus])

- etc.

[ArgoCD]: https://github.com/argoproj/argo-cd
[AWS]: https://aws-controllers-k8s.github.io/community/docs/community/services/
[cert-manager]: https://cert-manager.io/
[External Secrets Operator]: https://external-secrets.io/
[Flux]: https://fluxcd.io/
[Gatekeeper]: https://open-policy-agent.github.io/gatekeeper/website/docs/
[GCP]: https://github.com/paulczar/gcp-cloud-compute-operator
[Istio]: https://istio.io/latest/docs/setup/install/operator/
[KubeVirt]: https://kubevirt.io/
[Kyverno]: https://kyverno.io/
[Prometheus]: https://prometheus-operator.dev/
[Sealed Secrets]: https://github.com/bitnami-labs/sealed-secrets
[Velero]: https://velero.io/

.debug[[k8s/operators.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators.md)]
---

## What are they made from?

- Operators combine two things:

  - Custom Resource Definitions

  - controller code watching the corresponding resources and acting upon them

- A given operator can define one or multiple CRDs

- The controller code (control loop) typically runs within the cluster

  (running as a Deployment with 1 replica is a common scenario)

- But it could also run elsewhere

  (nothing mandates that the code run on the cluster, as long as it has API access)

.debug[[k8s/operators.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators.md)]
---

## Operators for e.g. replicated databases

- Kubernetes gives us Deployments, StatefulSets, Services ...

- These mechanisms give us building blocks to deploy applications

- They work great for services that are made of *N* identical containers

  (like stateless ones)

- They also work great for some stateful applications like Consul, etcd ...

  (with the help of highly persistent volumes)

- They're not enough for complex services:

  - where different containers have different roles

  - where extra steps have to be taken when scaling or replacing containers

.debug[[k8s/operators.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators.md)]
---

## How operators work

- An operator creates one or more CRDs

  (i.e., it creates new "Kinds" of resources on our cluster)

- The operator also runs a *controller* that will watch its resources

- Each time we create/update/delete a resource, the controller is notified

  (we could write our own cheap controller with `kubectl get --watch`)

.debug[[k8s/operators.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators.md)]
---

## Operators are not magic

- Look at this ElasticSearch resource definition:

  [k8s/eck-elasticsearch.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/eck-elasticsearch.yaml)

- What should happen if we flip the TLS flag? Twice?

- What should happen if we add another group of nodes?

- What if we want different images or parameters for the different nodes?

*Operators can be very powerful.
<br/>
But we need to know exactly the scenarios that they can handle.*

???

:EN:- Kubernetes operators
:FR:- Les opérateurs

.debug[[k8s/operators.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-2.jpg)]

---

name: toc-an-elasticsearch-operator
class: title

 An ElasticSearch Operator

.nav[
[Previous part](#toc-operators)
|
[Back to table of contents](#toc-part-13)
|
[Next part](#toc-designing-an-operator)
]

.debug[(automatically generated title slide)]

---
# An ElasticSearch Operator

- We will install [Elastic Cloud on Kubernetes](https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-quickstart.html), an ElasticSearch operator

- This operator requires PersistentVolumes

- We will install Rancher's [local path storage provisioner](https://github.com/rancher/local-path-provisioner) to automatically create these

- Then, we will create an ElasticSearch resource

- The operator will detect that resource and provision the cluster

- We will integrate that ElasticSearch cluster with other resources

  (Kibana, Filebeat, Cerebro ...)

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Installing a Persistent Volume provisioner

(This step can be skipped if you already have a dynamic volume provisioner.)

- This provisioner creates Persistent Volumes backed by `hostPath`

  (local directories on our nodes)

- It doesn't require anything special ...

- ... But losing a node = losing the volumes on that node!

.lab[

- Install the local path storage provisioner:
  ```bash
  kubectl apply -f ~/container.training/k8s/local-path-storage.yaml
  ```

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Making sure we have a default StorageClass

- The ElasticSearch operator will create StatefulSets

- These StatefulSets will instantiate PersistentVolumeClaims

- These PVCs need to be explicitly associated with a StorageClass

- Or we need to tag a StorageClass to be used as the default one

.lab[

- List StorageClasses:
  ```bash
  kubectl get storageclasses
  ```

]

We should see the `local-path` StorageClass.

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Setting a default StorageClass

- This is done by adding an annotation to the StorageClass:

  `storageclass.kubernetes.io/is-default-class: true`

.lab[

- Tag the StorageClass so that it's the default one:
  ```bash
  kubectl annotate storageclass local-path \
            storageclass.kubernetes.io/is-default-class=true
  ```

- Check the result:
  ```bash
  kubectl get storageclasses
  ```

]

Now, the StorageClass should have `(default)` next to its name.

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Install the ElasticSearch operator

- The operator provides:

  - a few CustomResourceDefinitions
  - a Namespace for its other resources
  - a ValidatingWebhookConfiguration for type checking
  - a StatefulSet for its controller and webhook code
  - a ServiceAccount, ClusterRole, ClusterRoleBinding for permissions

- All these resources are grouped in a convenient YAML file

.lab[

- Install the operator:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-operator.yaml
  ```

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Check our new custom resources

- Let's see which CRDs were created

.lab[

- List all CRDs:
  ```bash
  kubectl get crds
  ```

]

This operator supports ElasticSearch, but also Kibana and APM. Cool!

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Create the `eck-demo` namespace

- For clarity, we will create everything in a new namespace, `eck-demo`

- This namespace is hard-coded in the YAML files that we are going to use

- We need to create that namespace

.lab[

- Create the `eck-demo` namespace:
  ```bash
  kubectl create namespace eck-demo
  ```

- Switch to that namespace:
  ```bash
  kns eck-demo
  ```

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

class: extra-details

## Can we use a different namespace?

Yes, but then we need to update all the YAML manifests that we
are going to apply in the next slides.

The `eck-demo` namespace is hard-coded in these YAML manifests.

Why?

Because when defining a ClusterRoleBinding that references a
ServiceAccount, we have to indicate in which namespace the
ServiceAccount is located.

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Create an ElasticSearch resource

- We can now create a resource with `kind: ElasticSearch`

- The YAML for that resource will specify all the desired parameters:

  - how many nodes we want
  - image to use
  - add-ons (kibana, cerebro, ...)
  - whether to use TLS or not
  - etc.

.lab[

- Create our ElasticSearch cluster:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-elasticsearch.yaml
  ```

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Operator in action

- Over the next minutes, the operator will create our ES cluster

- It will report our cluster status through the CRD

.lab[

- Check the logs of the operator:
  ```bash
  stern --namespace=elastic-system operator
  ```

<!--
```wait elastic-operator-0```
```tmux split-pane -v```
--->

- Watch the status of the cluster through the CRD:
  ```bash
  kubectl get es -w
  ```

<!--
```longwait green```
```key ^C```
```key ^D```
```key ^C```
-->

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Connecting to our cluster

- It's not easy to use the ElasticSearch API from the shell

- But let's check at least if ElasticSearch is up!

.lab[

- Get the ClusterIP of our ES instance:
  ```bash
  kubectl get services
  ```

- Issue a request with `curl`:
  ```bash
  curl http://`CLUSTERIP`:9200
  ```

]

We get an authentication error. Our cluster is protected!

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Obtaining the credentials

- The operator creates a user named `elastic`

- It generates a random password and stores it in a Secret

.lab[

- Extract the password:
  ```bash
    kubectl get secret demo-es-elastic-user \
            -o go-template="{{ .data.elastic | base64decode }} "
  ```

- Use it to connect to the API:
  ```bash
  curl -u elastic:`PASSWORD` http://`CLUSTERIP`:9200
  ```

]

We should see a JSON payload with the `"You Know, for Search"` tagline.

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Sending data to the cluster

- Let's send some data to our brand new ElasticSearch cluster!

- We'll deploy a filebeat DaemonSet to collect node logs

.lab[

- Deploy filebeat:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-filebeat.yaml
  ```

- Wait until some pods are up:
  ```bash
  watch kubectl get pods -l k8s-app=filebeat
  ```

<!--
```wait Running```
```key ^C```
-->

- Check that a filebeat index was created:
  ```bash
  curl -u elastic:`PASSWORD` http://`CLUSTERIP`:9200/_cat/indices
  ```

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Deploying an instance of Kibana

- Kibana can visualize the logs injected by filebeat

- The ECK operator can also manage Kibana

- Let's give it a try!

.lab[

- Deploy a Kibana instance:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-kibana.yaml
  ```

- Wait for it to be ready:
  ```bash
  kubectl get kibana -w
  ```

<!--
```longwait green```
```key ^C```
-->

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Connecting to Kibana

- Kibana is automatically set up to conect to ElasticSearch

  (this is arranged by the YAML that we're using)

- However, it will ask for authentication

- It's using the same user/password as ElasticSearch

.lab[

- Get the NodePort allocated to Kibana:
  ```bash
  kubectl get services
  ```

- Connect to it with a web browser

- Use the same user/password as before

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Setting up Kibana

After the Kibana UI loads, we need to click around a bit

.lab[

- Pick "explore on my own"

- Click on Use Elasticsearch data / Connect to your Elasticsearch index"

- Enter `filebeat-*` for the index pattern and click "Next step"

- Select `@timestamp` as time filter field name

- Click on "discover" (the small icon looking like a compass on the left bar)

- Play around!

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Scaling up the cluster

- At this point, we have only one node

- We are going to scale up

- But first, we'll deploy Cerebro, an UI for ElasticSearch

- This will let us see the state of the cluster, how indexes are sharded, etc.

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Deploying Cerebro

- Cerebro is stateless, so it's fairly easy to deploy

  (one Deployment + one Service)

- However, it needs the address and credentials for ElasticSearch

- We prepared yet another manifest for that!

.lab[

- Deploy Cerebro:
  ```bash
  kubectl apply -f ~/container.training/k8s/eck-cerebro.yaml
  ```

- Lookup the NodePort number and connect to it:
  ```bash
  kubectl get services
  ```

]

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

## Scaling up the cluster

- We can see on Cerebro that the cluster is "yellow"

  (because our index is not replicated)

- Let's change that!

.lab[

- Edit the ElasticSearch cluster manifest:
  ```bash
  kubectl edit es demo
  ```

- Find the field `count: 1` and change it to 3

- Save and quit

<!--
```wait Please edit```
```keys /count:```
```key ^J```
```keys $r3:x```
```key ^J```
-->

]

???

:EN:- Deploying ElasticSearch with ECK
:FR:- Déployer ElasticSearch avec ECK

.debug[[k8s/eck.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/eck.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/two-containers-on-a-truck.jpg)]

---

name: toc-designing-an-operator
class: title

 Designing an operator

.nav[
[Previous part](#toc-an-elasticsearch-operator)
|
[Back to table of contents](#toc-part-13)
|
[Next part](#toc-writing-a-tiny-operator)
]

.debug[(automatically generated title slide)]

---
# Designing an operator

- Once we understand CRDs and operators, it's tempting to use them everywhere

- Yes, we can do (almost) everything with operators ...

- ... But *should we?*

- Very often, the answer is **“no!”**

- Operators are powerful, but significantly more complex than other solutions

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## When should we (not) use operators?

- Operators are great if our app needs to react to cluster events

  (nodes or pods going down, and requiring extensive reconfiguration)

- Operators *might* be helpful to encapsulate complexity

  (manipulate one single custom resource for an entire stack)

- Operators are probably overkill if a Helm chart would suffice

- That being said, if we really want to write an operator ...

  Read on!

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## What does it take to write an operator?

- Writing a quick-and-dirty operator, or a POC/MVP, is easy

- Writing a robust operator is hard

- We will describe the general idea

- We will identify some of the associated challenges

- We will list a few tools that can help us

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Top-down vs. bottom-up

- Both approaches are possible

- Let's see what they entail, and their respective pros and cons

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Top-down approach

- Start with high-level design (see next slide)

- Pros:

  - can yield cleaner design that will be more robust

- Cons:

  - must be able to anticipate all the events that might happen

  - design will be better only to the extent of what we anticipated

  - hard to anticipate if we don't have production experience

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## High-level design

- What are we solving?

  (e.g.: geographic databases backed by PostGIS with Redis caches)

- What are our use-cases, stories?

  (e.g.: adding/resizing caches and read replicas; load balancing queries)

- What kind of outage do we want to address?

  (e.g.: loss of individual node, pod, volume)

- What are our *non-features*, the things we don't want to address?

  (e.g.: loss of datacenter/zone; differentiating between read and write queries;
  <br/>
  cache invalidation; upgrading to newer major versions of Redis, PostGIS, PostgreSQL)

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Low-level design

- What Custom Resource Definitions do we need?

  (one, many?)

- How will we store configuration information?

  (part of the CRD spec fields, annotations, other?)

- Do we need to store state? If so, where?

  - state that is small and doesn't change much can be stored via the Kubernetes API
    <br/>
    (e.g.: leader information, configuration, credentials)

  - things that are big and/or change a lot should go elsewhere
    <br/>
    (e.g.: metrics, bigger configuration file like GeoIP)

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

class: extra-details

## What can we store via the Kubernetes API?

- The API server stores most Kubernetes resources in etcd

- Etcd is designed for reliability, not for performance

- If our storage needs exceed what etcd can offer, we need to use something else:

  - either directly

  - or by extending the API server
    <br/>(for instance by using the aggregation layer, like [metrics server](https://github.com/kubernetes-incubator/metrics-server) does)

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Bottom-up approach

- Start with existing Kubernetes resources (Deployment, Stateful Set...)

- Run the system in production

- Add scripts, automation, to facilitate day-to-day operations

- Turn the scripts into an operator

- Pros: simpler to get started; reflects actual use-cases

- Cons: can result in convoluted designs requiring extensive refactor

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## General idea

- Our operator will watch its CRDs *and associated resources*

- Drawing state diagrams and finite state automata helps a lot

- It's OK if some transitions lead to a big catch-all "human intervention"

- Over time, we will learn about new failure modes and add to these diagrams

- It's OK to start with CRD creation / deletion and prevent any modification

  (that's the easy POC/MVP we were talking about)

- *Presentation* and *validation* will help our users

  (more on that later)

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Challenges

- Reacting to infrastructure disruption can seem hard at first

- Kubernetes gives us a lot of primitives to help:

  - Pods and Persistent Volumes will *eventually* recover

  - Stateful Sets give us easy ways to "add N copies" of a thing

- The real challenges come with configuration changes

  (i.e., what to do when our users update our CRDs)

- Keep in mind that [some] of the [largest] cloud [outages] haven't been caused by [natural catastrophes], or even code bugs, but by configuration changes

[some]: https://www.datacenterdynamics.com/news/gcp-outage-mainone-leaked-google-cloudflare-ip-addresses-china-telecom/
[largest]: https://aws.amazon.com/message/41926/
[outages]: https://aws.amazon.com/message/65648/
[natural catastrophes]: https://www.datacenterknowledge.com/amazon/aws-says-it-s-never-seen-whole-data-center-go-down

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Configuration changes

- It is helpful to analyze and understand how Kubernetes controllers work:

  - watch resource for modifications

  - compare desired state (CRD) and current state

  - issue actions to converge state

- Configuration changes will probably require *another* state diagram or FSA

- Again, it's OK to have transitions labeled as "unsupported"

  (i.e. reject some modifications because we can't execute them)

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Tools

- CoreOS / RedHat Operator Framework

  [GitHub](https://github.com/operator-framework)
  |
  [Blog](https://developers.redhat.com/blog/2018/12/18/introduction-to-the-kubernetes-operator-framework/)
  |
  [Intro talk](https://www.youtube.com/watch?v=8k_ayO1VRXE)
  |
  [Deep dive talk](https://www.youtube.com/watch?v=fu7ecA2rXmc)
  |
  [Simple example](https://medium.com/faun/writing-your-first-kubernetes-operator-8f3df4453234)

- Kubernetes Operator Pythonic Framework (KOPF)

  [GitHub](https://github.com/nolar/kopf)
  |
  [Docs](https://kopf.readthedocs.io/)
  |
  [Step-by-step tutorial](https://kopf.readthedocs.io/en/stable/walkthrough/problem/)

- Mesosphere Kubernetes Universal Declarative Operator (KUDO)

  [GitHub](https://github.com/kudobuilder/kudo)
  |
  [Blog](https://mesosphere.com/blog/announcing-maestro-a-declarative-no-code-approach-to-kubernetes-day-2-operators/)
  |
  [Docs](https://kudo.dev/)
  |
  [Zookeeper example](https://github.com/kudobuilder/frameworks/tree/master/repo/stable/zookeeper)

- Kubebuilder (Go, very close to the Kubernetes API codebase)

  [GitHub](https://github.com/kubernetes-sigs/kubebuilder)
  |
  [Book](https://book.kubebuilder.io/)

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Validation

- By default, a CRD is "free form"

  (we can put pretty much anything we want in it)

- When creating a CRD, we can provide an OpenAPI v3 schema
  ([Example](https://github.com/amaizfinance/redis-operator/blob/master/deploy/crds/k8s_v1alpha1_redis_crd.yaml#L34))

- The API server will then validate resources created/edited with this schema

- If we need a stronger validation, we can use a Validating Admission Webhook:

  - run an [admission webhook server](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server) to receive validation requests

  - register the webhook by creating a [ValidatingWebhookConfiguration](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#configure-admission-webhooks-on-the-fly)

  - each time the API server receives a request matching the configuration,
    <br/>the request is sent to our server for validation

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Presentation

- By default, `kubectl get mycustomresource` won't display much information

  (just the name and age of each resource)

- When creating a CRD, we can specify additional columns to print
  ([Example](https://github.com/amaizfinance/redis-operator/blob/master/deploy/crds/k8s_v1alpha1_redis_crd.yaml#L6),
  [Docs](https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/#additional-printer-columns))

- By default, `kubectl describe mycustomresource` will also be generic

- `kubectl describe` can show events related to our custom resources

  (for that, we need to create Event resources, and fill the `involvedObject` field)

- For scalable resources, we can define a `scale` sub-resource

- This will enable the use of `kubectl scale` and other scaling-related operations

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## About scaling

- It is possible to use the HPA (Horizontal Pod Autoscaler) with CRDs

- But it is not always desirable

- The HPA works very well for homogenous, stateless workloads

- For other workloads, your mileage may vary

- Some systems can scale across multiple dimensions

  (for instance: increase number of replicas, or number of shards?)

- If autoscaling is desired, the operator will have to take complex decisions

  (example: Zalando's Elasticsearch Operator ([Video](https://www.youtube.com/watch?v=lprE0J0kAq0)))

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Versioning

- As our operator evolves over time, we may have to change the CRD

  (add, remove, change fields)

- Like every other resource in Kubernetes, [custom resources are versioned](https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definition-versioning/
)

- When creating a CRD, we need to specify a *list* of versions

- Versions can be marked as `stored` and/or `served`

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Stored version

- Exactly one version has to be marked as the `stored` version

- As the name implies, it is the one that will be stored in etcd

- Resources in storage are never converted automatically

  (we need to read and re-write them ourselves)

- Yes, this means that we can have different versions in etcd at any time

- Our code needs to handle all the versions that still exist in storage

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Served versions

- By default, the Kubernetes API will serve resources "as-is"

  (using their stored version)

- It will assume that all versions are compatible storage-wise

  (i.e. that the spec and fields are compatible between versions)

- We can provide [conversion webhooks](https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definition-versioning/#webhook-conversion) to "translate" requests

  (the alternative is to upgrade all stored resources and stop serving old versions)

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Operator reliability

- Remember that the operator itself must be resilient

  (e.g.: the node running it can fail)

- Our operator must be able to restart and recover gracefully

- Do not store state locally

  (unless we can reconstruct that state when we restart)

- As indicated earlier, we can use the Kubernetes API to store data:

  - in the custom resources themselves

  - in other resources' annotations

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

## Beyond CRDs

- CRDs cannot use custom storage (e.g. for time series data)

- CRDs cannot support arbitrary subresources (like logs or exec for Pods)

- CRDs cannot support protobuf (for faster, more efficient communication)

- If we need these things, we can use the [aggregation layer](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/) instead

- The aggregation layer proxies all requests below a specific path to another server

  (this is used e.g. by the metrics server)

- [This documentation page](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#choosing-a-method-for-adding-custom-resources) compares the features of CRDs and API aggregation

???

:EN:- Guidelines to design our own operators
:FR:- Comment concevoir nos propres opérateurs

.debug[[k8s/operators-design.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-design.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/wall-of-containers.jpeg)]

---

name: toc-writing-a-tiny-operator
class: title

 Writing a tiny operator

.nav[
[Previous part](#toc-designing-an-operator)
|
[Back to table of contents](#toc-part-13)
|
[Next part](#toc-last-words)
]

.debug[(automatically generated title slide)]

---
# Writing a tiny operator

- Let's look at a simple operator

- It does have:

  - a control loop
  - resource lifecycle management
  - basic logging

- It doesn't have:

  - CRDs (and therefore, resource versioning, conversion webhooks...)
  - advanced observability (metrics, Kubernetes Events)

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

## Use case

*When I push code to my source control system, I want that code
to be built into a container image, and that image to be deployed
in a staging environment. I want each branch/tag/commit (depending
on my needs) to be deployed into its specific Kubernetes Namespace.*

- The last part requires the CI/CD pipeline to manage Namespaces

- ...And permissions in these Namespaces

- This requires elevated privileges for the CI/CD pipeline

  (read: `cluster-admin`)

- If the CI/CD pipeline is compromised, this can lead to cluster compromise

- This can be a concern if the CI/CD pipeline is part of the repository

  (which is the default modus operandi with GitHub, GitLab, Bitbucket...)

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

## Proposed solution

- On-demand creation of Namespaces

- Creation is triggered by creating a ConfigMap in a dedicated Namespace

- Namespaces are set up with basic permissions

- Credentials are generated for each Namespace

- Credentials only give access to their Namespace

- Credentials are exposed back to the dedicated configuration Namespace

- Operator implemented as a shell script

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

## An operator in shell... Really?

- About 150 lines of code

  (including comments + white space)

- Performance doesn't matter

  - operator work will be a tiny fraction of CI/CD pipeline work

  - uses *watch* semantics to minimize control plane load

- Easy to understand, easy to audit, easy to tweak

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

## Show me the code!

- GitHub repository and documentation:

  https://github.com/jpetazzo/nsplease

- Operator source code:

  https://github.com/jpetazzo/nsplease/blob/main/nsplease.sh

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

## Main loop

```bash
  info "Waiting for ConfigMap events in $REQUESTS_NAMESPACE..."
  kubectl --namespace $REQUESTS_NAMESPACE get configmaps \
    --watch --output-watch-events -o json \
    | jq --unbuffered --raw-output '[.type,.object.metadata.name] | @tsv' \
    | while read TYPE NAMESPACE; do

      debug "Got event: $TYPE $NAMESPACE"
```

- `--watch` to avoid active-polling the control plane

- `--output-watch-events` to disregard e.g. resource deletion, edition

- `jq` to process JSON easily

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

## Resource ownership

- Check out the `kubectl patch` commands

- The created Namespace "owns" the corresponding ConfigMap and Secret

- This means that deleting the Namespace will delete the ConfigMap and Secret

- We don't need to watch for object deletion to clean up

- Clean up will we done automatically even if operator is not running

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

## Why no CRD?

- It's easier to create a ConfigMap

  (e.g. `kubectl create configmap --from-literal=` one-liner)

- We don't need the features of CRDs

  (schemas, printer columns, versioning...)

- “This CRD could have been a ConfigMap!”

  (this doesn't mean *all* CRDs could be ConfigMaps, of course)

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

## Discussion

- A lot of simple, yet efficient logic, can be implemented in shell scripts

- These can be used to prototype more complex operators

- Not all use-cases require CRDs

  (keep in mind that correct CRDs are *a lot* of work!)

- If the algorithms are correct, shell performance won't matter at all

  (but it will be difficult to keep a resource cache in shell)

- Improvement idea: this operator could generate *events*

  (visible with `kubectl get events` and `kubectl describe`)

???

:EN:- How to write a simple operator with shell scripts
:FR:- Comment écrire un opérateur simple en shell script

.debug[[k8s/operators-example.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/operators-example.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/catene-de-conteneurs.jpg)]

---

name: toc-last-words
class: title

 Last words

.nav[
[Previous part](#toc-writing-a-tiny-operator)
|
[Back to table of contents](#toc-part-14)
|
[Next part](#toc-links-and-resources)
]

.debug[(automatically generated title slide)]

---
# Last words

- Congratulations!

- We learned a lot about Kubernetes, its internals, its advanced concepts

--

- That was just the easy part

- The hard challenges will revolve around *culture* and *people*

--

- ... What does that mean?

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Running an app involves many steps

- Write the app

- Tests, QA ...

- Ship *something* (more on that later)

- Provision resources (e.g. VMs, clusters)

- Deploy the *something* on the resources

- Manage, maintain, monitor the resources

- Manage, maintain, monitor the app

- And much more

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Who does what?

- The old "devs vs ops" division has changed

- In some organizations, "ops" are now called "SRE" or "platform" teams

  (and they have very different sets of skills)

- Do you know which team is responsible for each item on the list on the previous page?

- Acknowledge that a lot of tasks are outsourced

  (e.g. if we add "buy/rack/provision machines" in that list)

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## What do we ship?

- Some organizations embrace "you build it, you run it"

- When "build" and "run" are owned by different teams, where's the line?

- What does the "build" team ship to the "run" team?

- Let's see a few options, and what they imply

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Shipping code

- Team "build" ships code

  (hopefully in a repository, identified by a commit hash)

- Team "run" containerizes that code

✔️ no extra work for developers

❌ very little advantage of using containers

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Shipping container images

- Team "build" ships container images

  (hopefully built automatically from a source repository)

- Team "run" uses theses images to create e.g. Kubernetes resources

✔️ universal artefact (support all languages uniformly)

✔️ easy to start a single component (good for monoliths)

❌ complex applications will require a lot of extra work

❌ adding/removing components in the stack also requires extra work

❌ complex applications will run very differently between dev and prod

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Shipping Compose files

(Or another kind of dev-centric manifest)

- Team "build" ships a manifest that works on a single node

  (as well as images, or ways to build them)

- Team "run" adapts that manifest to work on a cluster

✔️ all teams can start the stack in a reliable, deterministic manner

❌ adding/removing components still requires *some* work (but less than before)

❌ there will be *some* differences between dev and prod

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Shipping Kubernetes manifests

- Team "build" ships ready-to-run manifests

  (YAML, Helm charts, Kustomize ...)

- Team "run" adjusts some parameters and monitors the application

✔️ parity between dev and prod environments

✔️ "run" team can focus on SLAs, SLOs, and overall quality

❌ requires *a lot* of extra work (and new skills) from the "build" team

❌ Kubernetes is not a very convenient development platform (at least, not yet)

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## What's the right answer?

- It depends on our teams

  - existing skills (do they know how to do it?)

  - availability (do they have the time to do it?)

  - potential skills (can they learn to do it?)

- It depends on our culture

  - owning "run" often implies being on call

  - do we reward on-call duty without encouraging hero syndrome?

  - do we give people resources (time, money) to learn?

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

class: extra-details

## Tools to develop on Kubernetes

*If we decide to make Kubernetes the primary development platform, here
are a few tools that can help us.*

- Docker Desktop

- Draft

- Minikube

- Skaffold

- Tilt

- ...

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Where do we run?

- Managed vs. self-hosted

- Cloud vs. on-premises

- If cloud: public vs. private

- Which vendor/distribution to pick?

- Which versions/features to enable?

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Developer experience

*These questions constitute a quick "smoke test" for our strategy:*

- How do we on-board a new developer?

- What do they need to install to get a dev stack?

- How does a code change make it from dev to prod?

- How does someone add a component to a stack?

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

## Some guidelines

- Start small

- Outsource what we don't know

- Start simple, and stay simple as long as possible

  (try to stay away from complex features that we don't need)

- Automate

  (regularly check that we can successfully redeploy by following scripts)

- Transfer knowledge

  (make sure everyone is on the same page/level)

- Iterate!

.debug[[k8s/lastwords.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/lastwords.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-links-and-resources
class: title

 Links and resources

.nav[
[Previous part](#toc-last-words)
|
[Back to table of contents](#toc-part-14)
|
[Next part](#toc-all-content-after-this-slide-is-bonus-material)
]

.debug[(automatically generated title slide)]

---
# Links and resources

All things Kubernetes:

- [Kubernetes Community](https://kubernetes.io/community/) - Slack, Google Groups, meetups
- [Kubernetes on StackOverflow](https://stackoverflow.com/questions/tagged/kubernetes)
- [Play With Kubernetes Hands-On Labs](https://medium.com/@marcosnils/introducing-pwk-play-with-k8s-159fcfeb787b)

All things Docker:

- [Docker documentation](http://docs.docker.com/)
- [Docker Hub](https://hub.docker.com)
- [Docker on StackOverflow](https://stackoverflow.com/questions/tagged/docker)
- [Play With Docker Hands-On Labs](http://training.play-with-docker.com/)

Everything else:

- [Local meetups](https://www.meetup.com/)

.footnote[These slides (and future updates) are on → http://container.training/]

.debug[[k8s/links.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/links.md)]
---
class: title, self-paced

Thank you!

.debug[[shared/thankyou.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/thankyou.md)]
---

class: title, in-person

That's all, folks! <br/> Questions?

![end](images/end.jpg)

.debug[[shared/thankyou.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/shared/thankyou.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-all-content-after-this-slide-is-bonus-material
class: title

 (All content after this slide is bonus material)

.nav[
[Previous part](#toc-links-and-resources)
|
[Back to table of contents](#toc-part-14)
|
[Next part](#toc-volumes)
]

.debug[(automatically generated title slide)]

---
# (All content after this slide is bonus material)

.debug[[imie.yml](https://github.com/jpetazzo/container.training.git/tree/main/slides/imie.yml)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-volumes
class: title

 Volumes

.nav[
[Previous part](#toc-all-content-after-this-slide-is-bonus-material)
|
[Back to table of contents](#toc-part-15)
|
[Next part](#toc-managing-configuration)
]

.debug[(automatically generated title slide)]

---
# Volumes

- Volumes are special directories that are mounted in containers

- Volumes can have many different purposes:

  - share files and directories between containers running on the same machine

  - share files and directories between containers and their host

  - centralize configuration information in Kubernetes and expose it to containers

  - manage credentials and secrets and expose them securely to containers

  - store persistent data for stateful services

  - access storage systems (like Ceph, EBS, NFS, Portworx, and many others)

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

class: extra-details

## Kubernetes volumes vs. Docker volumes

- Kubernetes and Docker volumes are very similar

  (the [Kubernetes documentation](https://kubernetes.io/docs/concepts/storage/volumes/) says otherwise ...
  <br/>
  but it refers to Docker 1.7, which was released in 2015!)

- Docker volumes allow us to share data between containers running on the same host

- Kubernetes volumes allow us to share data between containers in the same pod

- Both Docker and Kubernetes volumes enable access to storage systems

- Kubernetes volumes are also used to expose configuration and secrets

- Docker has specific concepts for configuration and secrets
  <br/>
  (but under the hood, the technical implementation is similar)

- If you're not familiar with Docker volumes, you can safely ignore this slide!

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Volumes ≠ Persistent Volumes

- Volumes and Persistent Volumes are related, but very different!

- *Volumes*:

  - appear in Pod specifications (we'll see that in a few slides)

  - do not exist as API resources (**cannot** do `kubectl get volumes`)

- *Persistent Volumes*:

  - are API resources (**can** do `kubectl get persistentvolumes`)

  - correspond to concrete volumes (e.g. on a SAN, EBS, etc.)

  - cannot be associated with a Pod directly; but through a Persistent Volume Claim

  - won't be discussed further in this section

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Adding a volume to a Pod

- We will start with the simplest Pod manifest we can find

- We will add a volume to that Pod manifest

- We will mount that volume in a container in the Pod

- By default, this volume will be an `emptyDir`

  (an empty directory)

- It will "shadow" the directory where it's mounted

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Our basic Pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-without-volume
spec:
  containers:
  - name: nginx
    image: nginx
```

This is a MVP! (Minimum Viable Pod😉)

It runs a single NGINX container.

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Trying the basic pod

.lab[

- Create the Pod:
  ```bash
  kubectl create -f ~/container.training/k8s/nginx-1-without-volume.yaml
  ```

<!-- ```bash kubectl wait pod/nginx-without-volume --for condition=ready ``` -->

- Get its IP address:
  ```bash
  IPADDR=$(kubectl get pod nginx-without-volume -o jsonpath={.status.podIP})
  ```

- Send a request with curl:
  ```bash
  curl $IPADDR
  ```

]

(We should see the "Welcome to NGINX" page.)

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Adding a volume

- We need to add the volume in two places:

  - at the Pod level (to declare the volume)

  - at the container level (to mount the volume)

- We will declare a volume named `www`

- No type is specified, so it will default to `emptyDir`

  (as the name implies, it will be initialized as an empty directory at pod creation)

- In that pod, there is also a container named `nginx`

- That container mounts the volume `www` to path `/usr/share/nginx/html/`

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## The Pod with a volume

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-with-volume
spec:
  volumes:
  - name: www
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: www
      mountPath: /usr/share/nginx/html/
```

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Trying the Pod with a volume

.lab[

- Create the Pod:
  ```bash
  kubectl create -f ~/container.training/k8s/nginx-2-with-volume.yaml
  ```

<!-- ```bash kubectl wait pod/nginx-with-volume --for condition=ready ``` -->

- Get its IP address:
  ```bash
  IPADDR=$(kubectl get pod nginx-with-volume -o jsonpath={.status.podIP})
  ```

- Send a request with curl:
  ```bash
  curl $IPADDR
  ```

]

(We should now see a "403 Forbidden" error page.)

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Populating the volume with another container

- Let's add another container to the Pod

- Let's mount the volume in *both* containers

- That container will populate the volume with static files

- NGINX will then serve these static files

- To populate the volume, we will clone the Spoon-Knife repository

  - this repository is https://github.com/octocat/Spoon-Knife

  - it's very popular (more than 100K stars!)

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Sharing a volume between two containers

.small[
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-with-git
spec:
  volumes:
  - name: www
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: www
      mountPath: /usr/share/nginx/html/
  - name: git
    image: alpine
    command: [ "sh", "-c", "apk add git && git clone https://github.com/octocat/Spoon-Knife /www" ]
    volumeMounts:
    - name: www
      mountPath: /www/
  restartPolicy: OnFailure
```
]

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Sharing a volume, explained

- We added another container to the pod

- That container mounts the `www` volume on a different path (`/www`)

- It uses the `alpine` image

- When started, it installs `git` and clones the `octocat/Spoon-Knife` repository

  (that repository contains a tiny HTML website)

- As a result, NGINX now serves this website

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Trying the shared volume

- This one will be time-sensitive!

- We need to catch the Pod IP address *as soon as it's created*

- Then send a request to it *as fast as possible*

.lab[

- Watch the pods (so that we can catch the Pod IP address)
  ```bash
  kubectl get pods -o wide --watch
  ```

<!--
```wait NAME```
```tmux split-pane -v```
-->

]

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Shared volume in action

.lab[

- Create the pod:
  ```bash
  kubectl create -f ~/container.training/k8s/nginx-3-with-git.yaml
  ```

<!--
```bash kubectl wait pod/nginx-with-git --for condition=initialized```
```bash IP=$(kubectl get pod nginx-with-git -o jsonpath={.status.podIP})```
-->

- As soon as we see its IP address, access it:
  ```bash
  curl `$IP`
  ```

<!-- ```bash /bin/sleep 5``` -->

- A few seconds later, the state of the pod will change; access it again:
  ```bash
  curl `$IP`
  ```

]

The first time, we should see "403 Forbidden".

The second time, we should see the HTML file from the Spoon-Knife repository.

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Explanations

- Both containers are started at the same time

- NGINX starts very quickly

  (it can serve requests immediately)

- But at this point, the volume is empty

  (NGINX serves "403 Forbidden")

- The other containers installs git and clones the repository

  (this takes a bit longer)

- When the other container is done, the volume holds the repository

  (NGINX serves the HTML file)

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## The devil is in the details

- The default `restartPolicy` is `Always`

- This would cause our `git` container to run again ... and again ... and again

  (with an exponential back-off delay, as explained [in the documentation](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy))

- That's why we specified `restartPolicy: OnFailure`

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Inconsistencies

- There is a short period of time during which the website is not available

  (because the `git` container hasn't done its job yet)

- With a bigger website, we could get inconsistent results

  (where only a part of the content is ready)

- In real applications, this could cause incorrect results

- How can we avoid that?

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Init Containers

- We can define containers that should execute *before* the main ones

- They will be executed in order

  (instead of in parallel)

- They must all succeed before the main containers are started

- This is *exactly* what we need here!

- Let's see one in action

.footnote[See [Init Containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) documentation for all the details.]

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Defining Init Containers

.small[
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-with-init
spec:
  volumes:
  - name: www
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: www
      mountPath: /usr/share/nginx/html/
  initContainers:
  - name: git
    image: alpine
    command: [ "sh", "-c", "apk add git && git clone https://github.com/octocat/Spoon-Knife /www" ]
    volumeMounts:
    - name: www
      mountPath: /www/
```
]

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Trying the init container

.lab[

- Create the pod:
  ```bash
  kubectl create -f ~/container.training/k8s/nginx-4-with-init.yaml
  ```

- Try to send HTTP requests as soon as the pod comes up

<!--
```key ^D```
```key ^C```
-->

]

- This time, instead of "403 Forbidden" we get a "connection refused"

- NGINX doesn't start until the git container has done its job

- We never get inconsistent results

  (a "half-ready" container)

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Other uses of init containers

- Load content

- Generate configuration (or certificates)

- Database migrations

- Waiting for other services to be up

  (to avoid flurry of connection errors in main container)

- etc.

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

## Volume lifecycle

- The lifecycle of a volume is linked to the pod's lifecycle

- This means that a volume is created when the pod is created

- This is mostly relevant for `emptyDir` volumes

  (other volumes, like remote storage, are not "created" but rather "attached" )

- A volume survives across container restarts

- A volume is destroyed (or, for remote storage, detached) when the pod is destroyed

???

:EN:- Sharing data between containers with volumes
:EN:- When and how to use Init Containers

:FR:- Partager des données grâce aux volumes
:FR:- Quand et comment utiliser un *Init Container*

.debug[[k8s/volumes.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volumes.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-managing-configuration
class: title

 Managing configuration

.nav[
[Previous part](#toc-volumes)
|
[Back to table of contents](#toc-part-15)
|
[Next part](#toc-managing-secrets)
]

.debug[(automatically generated title slide)]

---
# Managing configuration

- Some applications need to be configured (obviously!)

- There are many ways for our code to pick up configuration:

  - command-line arguments

  - environment variables

  - configuration files

  - configuration servers (getting configuration from a database, an API...)

  - ... and more (because programmers can be very creative!)

- How can we do these things with containers and Kubernetes?

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Passing configuration to containers

- There are many ways to pass configuration to code running in a container:

  - baking it into a custom image

  - command-line arguments

  - environment variables

  - injecting configuration files

  - exposing it over the Kubernetes API

  - configuration servers

- Let's review these different strategies!

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Baking custom images

- Put the configuration in the image

  (it can be in a configuration file, but also `ENV` or `CMD` actions)

- It's easy! It's simple!

- Unfortunately, it also has downsides:

  - multiplication of images

  - different images for dev, staging, prod ...

  - minor reconfigurations require a whole build/push/pull cycle

- Avoid doing it unless you don't have the time to figure out other options

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Command-line arguments

- Indicate what should run in the container

- Pass `command` and/or `args` in the container options in a Pod's template

- Both `command` and `args` are arrays

- Example ([source](https://github.com/jpetazzo/container.training/blob/main/k8s/consul-1.yaml#L70)):
  ```yaml
    args:
    - "agent"
    - "-bootstrap-expect=3"
    - "-retry-join=provider=k8s label_selector=\"app=consul\" namespace=\"$(NS)\""
    - "-client=0.0.0.0"
    - "-data-dir=/consul/data"
    - "-server"
    - "-ui"
  ```

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## `args` or `command`?

- Use `command` to override the `ENTRYPOINT` defined in the image

- Use `args` to keep the `ENTRYPOINT` defined in the image

  (the parameters specified in `args` are added to the `ENTRYPOINT`)

- In doubt, use `command`

- It is also possible to use *both* `command` and `args`

  (they will be strung together, just like `ENTRYPOINT` and `CMD`)

- See the [docs](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes) to see how they interact together

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Command-line arguments, pros & cons

- Works great when options are passed directly to the running program

  (otherwise, a wrapper script can work around the issue)

- Works great when there aren't too many parameters

  (to avoid a 20-lines `args` array)

- Requires documentation and/or understanding of the underlying program

  ("which parameters and flags do I need, again?")

- Well-suited for mandatory parameters (without default values)

- Not ideal when we need to pass a real configuration file anyway

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Environment variables

- Pass options through the `env` map in the container specification

- Example:
  ```yaml
      env:
      - name: ADMIN_PORT
        value: "8080"
      - name: ADMIN_AUTH
        value: Basic
      - name: ADMIN_CRED
        value: "admin:0pensesame!"
  ```

.warning[`value` must be a string! Make sure that numbers and fancy strings are quoted.]

🤔 Why this weird `{name: xxx, value: yyy}` scheme? It will be revealed soon!

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## The downward API

- In the previous example, environment variables have fixed values

- We can also use a mechanism called the *downward API*

- The downward API allows exposing pod or container information

  - either through special files (we won't show that for now)

  - or through environment variables

- The value of these environment variables is computed when the container is started

- Remember: environment variables won't (can't) change after container start

- Let's see a few concrete examples!

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Exposing the pod's namespace

```yaml
    - name: MY_POD_NAMESPACE
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
```

- Useful to generate FQDN of services

  (in some contexts, a short name is not enough)

- For instance, the two commands should be equivalent:
  ```
  curl api-backend
  curl api-backend.$MY_POD_NAMESPACE.svc.cluster.local
  ```

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Exposing the pod's IP address

```yaml
    - name: MY_POD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
```

- Useful if we need to know our IP address

  (we could also read it from `eth0`, but this is more solid)

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Exposing the container's resource limits

```yaml
    - name: MY_MEM_LIMIT
      valueFrom:
        resourceFieldRef:
          containerName: test-container
          resource: limits.memory
```

- Useful for runtimes where memory is garbage collected

- Example: the JVM

  (the memory available to the JVM should be set with the `-Xmx ` flag)

- Best practice: set a memory limit, and pass it to the runtime

- Note: recent versions of the JVM can do this automatically

  (see [JDK-8146115](https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8146115))
  and
  [this blog post](https://very-serio.us/2017/12/05/running-jvms-in-kubernetes/)
  for detailed examples)

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## More about the downward API

- [This documentation page](https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/) tells more about these environment variables

- And [this one](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/) explains the other way to use the downward API

  (through files that get created in the container filesystem)

- That second link also includes a list of all the fields that can be used with the downward API

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Environment variables, pros and cons

- Works great when the running program expects these variables

- Works great for optional parameters with reasonable defaults

  (since the container image can provide these defaults)

- Sort of auto-documented

  (we can see which environment variables are defined in the image, and their values)

- Can be (ab)used with longer values ...

- ... You *can* put an entire Tomcat configuration file in an environment ...

- ... But *should* you?

(Do it if you really need to, we're not judging! But we'll see better ways.)

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Injecting configuration files

- Sometimes, there is no way around it: we need to inject a full config file

- Kubernetes provides a mechanism for that purpose: `configmaps`

- A configmap is a Kubernetes resource that exists in a namespace

- Conceptually, it's a key/value map

  (values are arbitrary strings)

- We can think about them in (at least) two different ways:

  - as holding entire configuration file(s)

  - as holding individual configuration parameters

*Note: to hold sensitive information, we can use "Secrets", which
are another type of resource behaving very much like configmaps.
We'll cover them just after!*

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Configmaps storing entire files

- In this case, each key/value pair corresponds to a configuration file

- Key = name of the file

- Value = content of the file

- There can be one key/value pair, or as many as necessary

  (for complex apps with multiple configuration files)

- Examples:
  ```
  # Create a configmap with a single key, "app.conf"
  kubectl create configmap my-app-config --from-file=app.conf
  # Create a configmap with a single key, "app.conf" but another file
  kubectl create configmap my-app-config --from-file=app.conf=app-prod.conf
  # Create a configmap with multiple keys (one per file in the config.d directory)
  kubectl create configmap my-app-config --from-file=config.d/
  ```

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Configmaps storing individual parameters

- In this case, each key/value pair corresponds to a parameter

- Key = name of the parameter

- Value = value of the parameter

- Examples:
  ```
  # Create a configmap with two keys
  kubectl create cm my-app-config \
      --from-literal=foreground=red \
      --from-literal=background=blue
  
  # Create a configmap from a file containing key=val pairs
  kubectl create cm my-app-config \
      --from-env-file=app.conf
  ```

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Exposing configmaps to containers

- Configmaps can be exposed as plain files in the filesystem of a container

  - this is achieved by declaring a volume and mounting it in the container

  - this is particularly effective for configmaps containing whole files

- Configmaps can be exposed as environment variables in the container

  - this is achieved with the downward API

  - this is particularly effective for configmaps containing individual parameters

- Let's see how to do both!

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Example: HAProxy configuration

- We are going to deploy HAProxy, a popular load balancer

- It expects to find its configuration in a specific place:

  `/usr/local/etc/haproxy/haproxy.cfg`

- We will create a ConfigMap holding the configuration file

- Then we will mount that ConfigMap in a Pod running HAProxy

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Blue/green load balancing

- In this example, we will deploy two versions of our app:

  - the "blue" version in the `blue` namespace

  - the "green" version in the `green` namespace

- In both namespaces, we will have a Deployment and a Service

  (both named `color`)

- We want to load balance traffic between both namespaces

  (we can't do that with a simple service selector: these don't cross namespaces)

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Deploying the app

- We're going to use the image `jpetazzo/color`

  (it is a simple "HTTP echo" server showing which pod served the request)

- We can create each Namespace, Deployment, and Service by hand, or...

.lab[

- We can deploy the app with a YAML manifest:
  ```bash
  kubectl apply -f ~/container.training/k8s/rainbow.yaml
  ```

]

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Testing the app

- Reminder: Service `x` in Namespace `y` is available through:

  `x.y`, `x.y.svc`, `x.y.svc.cluster.local`

- Since the `cluster.local` suffix can change, we'll use `x.y.svc`

.lab[

- Check that the app is up and running:
  ```bash
    kubectl run --rm -it --restart=Never --image=nixery.dev/curl my-test-pod \
            curl color.blue.svc
  ```

]

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Creating the HAProxy configuration

Here is the file that we will use, [k8s/haproxy.cfg](https://github.com/jpetazzo/container.training/tree/master/k8s/haproxy.cfg):

```
global
  daemon

defaults
  mode tcp
  timeout connect 5s
  timeout client 50s
  timeout server 50s

listen very-basic-load-balancer
  bind *:80
  server blue color.blue.svc:80
  server green color.green.svc:80

# Note: the services above must exist,
# otherwise HAproxy won't start.

```

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Creating the ConfigMap

.lab[

- Create a ConfigMap named `haproxy` and holding the configuration file:
  ```bash
  kubectl create configmap haproxy --from-file=~/container.training/k8s/haproxy.cfg
  ```

- Check what our configmap looks like:
  ```bash
  kubectl get configmap haproxy -o yaml
  ```

]

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Using the ConfigMap

Here is [k8s/haproxy.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/haproxy.yaml), a Pod manifest using that ConfigMap:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: haproxy
spec:
  volumes:
  - name: config
    configMap:
      name: haproxy
  containers:
  - name: haproxy
    image: haproxy:1
    volumeMounts:
    - name: config
      mountPath: /usr/local/etc/haproxy/


```

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Creating the Pod

.lab[

- Create the HAProxy Pod:
  ```bash
  kubectl apply -f ~/container.training/k8s/haproxy.yaml
  ```

<!-- ```hide kubectl wait pod haproxy --for condition=ready``` -->

- Check the IP address allocated to the pod:
  ```bash
  kubectl get pod haproxy -o wide
  IP=$(kubectl get pod haproxy -o json | jq -r .status.podIP)
  ```

]

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Testing our load balancer

- If everything went well, when we should see a perfect round robin

  (one request to `blue`, one request to `green`, one request to `blue`, etc.)

.lab[

- Send a few requests:
  ```bash
  for i in $(seq 10); do
  curl $IP
  done
  ```

]

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Exposing configmaps with the downward API

- We are going to run a Docker registry on a custom port

- By default, the registry listens on port 5000

- This can be changed by setting environment variable `REGISTRY_HTTP_ADDR`

- We are going to store the port number in a configmap

- Then we will expose that configmap as a container environment variable

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Creating the configmap

.lab[

- Our configmap will have a single key, `http.addr`:
  ```bash
  kubectl create configmap registry --from-literal=http.addr=0.0.0.0:80
  ```

- Check our configmap:
  ```bash
  kubectl get configmap registry -o yaml
  ```

]

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Using the configmap

We are going to use the following pod definition:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: registry
spec:
  containers:
  - name: registry
    image: registry
    env:
    - name: REGISTRY_HTTP_ADDR
      valueFrom:
        configMapKeyRef:
          name: registry
          key: http.addr


```

.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

## Using the configmap

- The resource definition from the previous slide is in [k8s/registry.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/registry.yaml)

.lab[

- Create the registry pod:
  ```bash
  kubectl apply -f ~/container.training/k8s/registry.yaml
  ```

<!-- ```hide kubectl wait pod registry --for condition=ready``` -->

- Check the IP address allocated to the pod:
  ```bash
  kubectl get pod registry -o wide
  IP=$(kubectl get pod registry -o json | jq -r .status.podIP)
  ```

- Confirm that the registry is available on port 80:
  ```bash
  curl $IP/v2/_catalog
  ```

]

???

:EN:- Managing application configuration
:EN:- Exposing configuration with the downward API
:EN:- Exposing configuration with Config Maps

:FR:- Gérer la configuration des applications
:FR:- Configuration au travers de la *downward API*
:FR:- Configurer les applications avec des *Config Maps*
.debug[[k8s/configuration.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/configuration.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-managing-secrets
class: title

 Managing secrets

.nav[
[Previous part](#toc-managing-configuration)
|
[Back to table of contents](#toc-part-15)
|
[Next part](#toc-stateful-sets)
]

.debug[(automatically generated title slide)]

---
# Managing secrets

- Sometimes our code needs sensitive information:

  - passwords

  - API tokens

  - TLS keys

  - ...

- *Secrets* can be used for that purpose

- Secrets and ConfigMaps are very similar

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## Similarities between ConfigMap and Secrets

- ConfigMap and Secrets are key-value maps

  (a Secret can contain zero, one, or many key-value pairs)

- They can both be exposed with the downward API or volumes

- They can both be created with YAML or with a CLI command

  (`kubectl create configmap` / `kubectl create secret`)

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## ConfigMap and Secrets are different resources

- They can have different RBAC permissions

  (e.g. the default `view` role can read ConfigMaps but not Secrets)

- They indicate a different *intent*:

  *"You should use secrets for things which are actually secret like API keys, 
  credentials, etc., and use config map for not-secret configuration data."*

  *"In the future there will likely be some differentiators for secrets like rotation or support for backing the secret API w/ HSMs, etc."*

  (Source: [the author of both features](https://stackoverflow.com/a/36925553/580281
))

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## Secrets have an optional *type*

- The type indicates which keys must exist in the secrets, for instance:

  `kubernetes.io/tls` requires `tls.crt` and `tls.key`

  `kubernetes.io/basic-auth` requires `username` and `password`

  `kubernetes.io/ssh-auth` requires `ssh-privatekey`

  `kubernetes.io/dockerconfigjson` requires `.dockerconfigjson`

  `kubernetes.io/service-account-token` requires `token`, `namespace`, `ca.crt`

  (the whole list is in [the documentation](https://kubernetes.io/docs/concepts/configuration/secret/#secret-types))

- This is merely for our (human) convenience:

  “Ah yes, this secret is a ...”

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## Accessing private repositories

- Let's see how to access an image on a private registry!

- These images are protected by a username + password

  (on some registries, it's token + password, but it's the same thing)

- To access a private image, we need to:

  - create a secret

  - reference that secret in a Pod template

  - or reference that secret in a ServiceAccount used by a Pod

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## In practice

- Let's try to access an image on a private registry!

  - image = docker-registry.enix.io/jpetazzo/private:latest
  - user = reader
  - password = VmQvqdtXFwXfyy4Jb5DR

.lab[

- Create a Deployment using that image:
  ```bash
    kubectl create deployment priv \
            --image=docker-registry.enix.io/jpetazzo/private
  ```

- Check that the Pod won't start:
  ```bash
  kubectl get pods --selector=app=priv
  ```

]

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## Creating a secret

- Let's create a secret with the information provided earlier

.lab[

- Create the registry secret:
  ```bash
    kubectl create secret docker-registry enix \
            --docker-server=docker-registry.enix.io \
            --docker-username=reader \
            --docker-password=VmQvqdtXFwXfyy4Jb5DR
  ```

]

Why do we have to specify the registry address?

If we use multiple sets of credentials for different registries, it prevents leaking the credentials of one registry to *another* registry.

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## Using the secret

- The first way to use a secret is to add it to `imagePullSecrets`

  (in the `spec` section of a Pod template)

.lab[

- Patch the `priv` Deployment that we created earlier:
  ```bash
    kubectl patch deploy priv --patch='
    spec:
      template:
        spec:
          imagePullSecrets:
          - name: enix
    '
  ```

]

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## Checking the results

.lab[

- Confirm that our Pod can now start correctly:
  ```bash
  kubectl get pods --selector=app=priv
  ```

]

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## Another way to use the secret

- We can add the secret to the ServiceAccount

- This is convenient to automatically use credentials for *all* pods

  (as long as they're using a specific ServiceAccount, of course)

.lab[

- Add the secret to the ServiceAccount:
  ```bash
    kubectl patch serviceaccount default --patch='
    imagePullSecrets:
    - name: enix
    '
  ```

]

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

## Secrets are displayed with base64 encoding

- When shown with e.g. `kubectl get secrets -o yaml`, secrets are base64-encoded

- Likewise, when defining it with YAML, `data` values are base64-encoded

- Example:
  ```yaml
    kind: Secret
    apiVersion: v1
    metadata:
      name: pin-codes
    data:
      onetwothreefour: MTIzNA==
      zerozerozerozero: MDAwMA==
  ```

- Keep in mind that this is just *encoding*, not *encryption*

- It is very easy to [automatically extract and decode secrets](https://medium.com/@mveritym/decoding-kubernetes-secrets-60deed7a96a3)

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

class: extra-details

## Using `stringData`

- When creating a Secret, it is possible to bypass base64

- Just use `stringData` instead of `data`:
  ```yaml
    kind: Secret
    apiVersion: v1
    metadata:
      name: pin-codes
    stringData:
      onetwothreefour: 1234
      zerozerozerozero: 0000
  ```

- It will show up as base64 if you `kubectl get -o yaml`

- No `type` was specified, so it defaults to `Opaque`

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

class: extra-details

## Encryption at rest

- It is possible to [encrypt secrets at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

- This means that secrets will be safe if someone ...

  - steals our etcd servers

  - steals our backups

  - snoops the e.g. iSCSI link between our etcd servers and SAN

- However, starting the API server will now require human intervention

  (to provide the decryption keys)

- This is only for extremely regulated environments (military, nation states...)

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

class: extra-details

## Immutable ConfigMaps and Secrets

- Since Kubernetes 1.19, it is possible to mark a ConfigMap or Secret as *immutable*

  ```bash
  kubectl patch configmap xyz --patch='{"immutable": true}'
  ```

- This brings performance improvements when using lots of ConfigMaps and Secrets

  (lots = tens of thousands)

- Once a ConfigMap or Secret has been marked as immutable:

  - its content cannot be changed anymore
  - the `immutable` field can't be changed back either
  - the only way to change it is to delete and re-create it
  - Pods using it will have to be re-created as well

???

:EN:- Handling passwords and tokens safely

:FR:- Manipulation de mots de passe, clés API etc.

.debug[[k8s/secrets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/secrets.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-stateful-sets
class: title

 Stateful sets

.nav[
[Previous part](#toc-managing-secrets)
|
[Back to table of contents](#toc-part-15)
|
[Next part](#toc-running-a-consul-cluster)
]

.debug[(automatically generated title slide)]

---
# Stateful sets

- Stateful sets are a type of resource in the Kubernetes API

  (like pods, deployments, services...)

- They offer mechanisms to deploy scaled stateful applications

- At a first glance, they look like Deployments:

  - a stateful set defines a pod spec and a number of replicas *R*

  - it will make sure that *R* copies of the pod are running

  - that number can be changed while the stateful set is running

  - updating the pod spec will cause a rolling update to happen

- But they also have some significant differences

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Stateful sets unique features

- Pods in a stateful set are numbered (from 0 to *R-1*) and ordered

- They are started and updated in order (from 0 to *R-1*)

- A pod is started (or updated) only when the previous one is ready

- They are stopped in reverse order (from *R-1* to 0)

- Each pod knows its identity (i.e. which number it is in the set)

- Each pod can discover the IP address of the others easily

- The pods can persist data on attached volumes

🤔 Wait a minute ... Can't we already attach volumes to pods and deployments?

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Revisiting volumes

- [Volumes](https://kubernetes.io/docs/concepts/storage/volumes/) are used for many purposes:

  - sharing data between containers in a pod

  - exposing configuration information and secrets to containers

  - accessing storage systems

- Let's see examples of the latter usage

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Volumes types

- There are many [types of volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes) available:

  - public cloud storage (GCEPersistentDisk, AWSElasticBlockStore, AzureDisk...)

  - private cloud storage (Cinder, VsphereVolume...)

  - traditional storage systems (NFS, iSCSI, FC...)

  - distributed storage (Ceph, Glusterfs, Portworx...)

- Using a persistent volume requires:

  - creating the volume out-of-band (outside of the Kubernetes API)

  - referencing the volume in the pod description, with all its parameters

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Using a cloud volume

Here is a pod definition using an AWS EBS volume (that has to be created first):

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-using-my-ebs-volume
spec:
  containers:
  - image: ...
    name: container-using-my-ebs-volume
    volumeMounts:
    - mountPath: /my-ebs
      name: my-ebs-volume
  volumes:
  - name: my-ebs-volume
    awsElasticBlockStore:
      volumeID: vol-049df61146c4d7901
      fsType: ext4
```

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Using an NFS volume

Here is another example using a volume on an NFS server:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-using-my-nfs-volume
spec:
  containers:
  - image: ...
    name: container-using-my-nfs-volume
    volumeMounts:
    - mountPath: /my-nfs
      name: my-nfs-volume
  volumes:
  - name: my-nfs-volume
    nfs:
      server: 192.168.0.55
      path: "/exports/assets"
```

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Shortcomings of volumes

- Their lifecycle (creation, deletion...) is managed outside of the Kubernetes API

  (we can't just use `kubectl apply/create/delete/...` to manage them)

- If a Deployment uses a volume, all replicas end up using the same volume

- That volume must then support concurrent access

  - some volumes do (e.g. NFS servers support multiple read/write access)

  - some volumes support concurrent reads

  - some volumes support concurrent access for colocated pods

- What we really need is a way for each replica to have its own volume

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Individual volumes

- The Pods of a Stateful set can have individual volumes

  (i.e. in a Stateful set with 3 replicas, there will be 3 volumes)

- These volumes can be either:

  - allocated from a pool of pre-existing volumes (disks, partitions ...)

  - created dynamically using a storage system

- This introduces a bunch of new Kubernetes resource types:

  Persistent Volumes, Persistent Volume Claims, Storage Classes

  (and also `volumeClaimTemplates`, that appear within Stateful Set manifests!)

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Stateful set recap

- A Stateful sets manages a number of identical pods

  (like a Deployment)

- These pods are numbered, and started/upgraded/stopped in a specific order

- These pods are aware of their number

  (e.g., #0 can decide to be the primary, and #1 can be secondary)

- These pods can find the IP addresses of the other pods in the set

  (through a *headless service*)

- These pods can each have their own persistent storage

.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

## Obtaining per-pod storage

- Stateful Sets can have *persistent volume claim templates*

  (declared in `spec.volumeClaimTemplates` in the Stateful set manifest)

- A claim template will create one Persistent Volume Claim per pod

  (the PVC will be named `<claim-name>.<stateful-set-name>.<pod-index>`)

- Persistent Volume Claims are matched 1-to-1 with Persistent Volumes

- Persistent Volume provisioning can be done:

  - automatically (by leveraging *dynamic provisioning* with a Storage Class)

  - manually (human operator creates the volumes ahead of time, or when needed)

???

:EN:- Deploying apps with Stateful Sets
:EN:- Understanding Persistent Volume Claims and Storage Classes
:FR:- Déployer une application avec un *Stateful Set*
:FR:- Comprendre les *Persistent Volume Claims* et *Storage Classes*


.debug[[k8s/statefulsets.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/statefulsets.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-running-a-consul-cluster
class: title

 Running a Consul cluster

.nav[
[Previous part](#toc-stateful-sets)
|
[Back to table of contents](#toc-part-15)
|
[Next part](#toc-pv-pvc-and-storage-classes)
]

.debug[(automatically generated title slide)]

---
# Running a Consul cluster

- Here is a good use-case for Stateful sets!

- We are going to deploy a Consul cluster with 3 nodes

- Consul is a highly-available key/value store

  (like etcd or Zookeeper)

- One easy way to bootstrap a cluster is to tell each node:

  - the addresses of other nodes

  - how many nodes are expected (to know when quorum is reached)

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Bootstrapping a Consul cluster

*After reading the Consul documentation carefully (and/or asking around),
we figure out the minimal command-line to run our Consul cluster.*

```
consul agent -data-dir=/consul/data -client=0.0.0.0 -server -ui \
       -bootstrap-expect=3 \
       -retry-join=`X.X.X.X` \
       -retry-join=`Y.Y.Y.Y`
```

- Replace X.X.X.X and Y.Y.Y.Y with the addresses of other nodes

- A node can add its own address (it will work fine)

- ... Which means that we can use the same command-line on all nodes (convenient!)

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Cloud Auto-join

- Since version 1.4.0, Consul can use the Kubernetes API to find its peers

- This is called [Cloud Auto-join]

- Instead of passing an IP address, we need to pass a parameter like this:

  ```
  consul agent -retry-join "provider=k8s label_selector=\"app=consul\""
  ```

- Consul needs to be able to talk to the Kubernetes API

- We can provide a `kubeconfig` file

- If Consul runs in a pod, it will use the *service account* of the pod

[Cloud Auto-join]: https://www.consul.io/docs/agent/cloud-auto-join.html#kubernetes-k8s-

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Setting up Cloud auto-join

- We need to create a service account for Consul

- We need to create a role that can `list` and `get` pods

- We need to bind that role to the service account

- And of course, we need to make sure that Consul pods use that service account

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Putting it all together

- The file `k8s/consul-1.yaml` defines the required resources

  (service account, role, role binding, service, stateful set)

- Inspired by this [excellent tutorial](https://github.com/kelseyhightower/consul-on-kubernetes) by Kelsey Hightower

  (many features from the original tutorial were removed for simplicity)

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Running our Consul cluster

- We'll use the provided YAML file

.lab[

- Create the stateful set and associated service:
  ```bash
  kubectl apply -f ~/container.training/k8s/consul-1.yaml
  ```

- Check the logs as the pods come up one after another:
  ```bash
  stern consul
  ```

<!--
```wait Synced node info```
```key ^C```
-->

- Check the health of the cluster:
  ```bash
  kubectl exec consul-0 -- consul members
  ```

]

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Caveats

- The scheduler may place two Consul pods on the same node

  - if that node fails, we lose two Consul pods at the same time
  - this will cause the cluster to fail

- Scaling down the cluster will cause it to fail

  - when a Consul member leaves the cluster, it needs to inform the others
  - otherwise, the last remaining node doesn't have quorum and stops functioning

- This Consul cluster doesn't use real persistence yet

  - data is stored in the containers' ephemeral filesystem
  - if a pod fails, its replacement starts from a blank slate

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Improving pod placement

- We need to tell the scheduler:

  *do not put two of these pods on the same node!*

- This is done with an `affinity` section like the following one:
  ```yaml
    affinity:
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                app: consul
            topologyKey: kubernetes.io/hostname
  ```

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Using a lifecycle hook

- When a Consul member leaves the cluster, it needs to execute:
  ```bash
  consul leave
  ```

- This is done with a `lifecycle` section like the following one:
  ```yaml
    lifecycle:
      preStop:
        exec:
          command: [ "sh", "-c", "consul leave" ]
  ```

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Running a better Consul cluster

- Let's try to add the scheduling constraint and lifecycle hook

- We can do that in the same namespace or another one (as we like)

- If we do that in the same namespace, we will see a rolling update

  (pods will be replaced one by one)

.lab[

- Deploy a better Consul cluster:
  ```bash
  kubectl apply -f ~/container.training/k8s/consul-2.yaml
  ```

]

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Still no persistence, though

- We aren't using actual persistence yet

  (no `volumeClaimTemplate`, Persistent Volume, etc.)

- What happens if we lose a pod?

  - a new pod gets rescheduled (with an empty state)

  - the new pod tries to connect to the two others

  - it will be accepted (after 1-2 minutes of instability)

  - and it will retrieve the data from the other pods

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

## Failure modes

- What happens if we lose two pods?

  - manual repair will be required

  - we will need to instruct the remaining one to act solo

  - then rejoin new pods

- What happens if we lose three pods? (aka all of them)

  - we lose all the data (ouch)

???

:EN:- Scheduling pods together or separately
:EN:- Example: deploying a Consul cluster
:FR:- Lancer des pods ensemble ou séparément
:FR:- Example : lancer un cluster Consul

.debug[[k8s/consul.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/consul.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-pv-pvc-and-storage-classes
class: title

 PV, PVC, and Storage Classes

.nav[
[Previous part](#toc-running-a-consul-cluster)
|
[Back to table of contents](#toc-part-15)
|
[Next part](#toc-openebs-)
]

.debug[(automatically generated title slide)]

---
# PV, PVC, and Storage Classes

- When an application needs storage, it creates a PersistentVolumeClaim

  (either directly, or through a volume claim template in a Stateful Set)

- The PersistentVolumeClaim is initially `Pending`

- Kubernetes then looks for a suitable PersistentVolume

  (maybe one is immediately available; maybe we need to wait for provisioning)

- Once a suitable PersistentVolume is found, the PVC becomes `Bound`

- The PVC can then be used by a Pod

  (as long as the PVC is `Pending`, the Pod cannot run)

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Access modes

- PV and PVC have *access modes*:

  - ReadWriteOnce (only one node can access the volume at a time)

  - ReadWriteMany (multiple nodes can access the volume simultaneously)

  - ReadOnlyMany (multiple nodes can access, but they can't write)

  - ReadWriteOncePod (only one pod can access the volume; new in Kubernetes 1.22)

- A PVC lists the access modes that it requires

- A PV lists the access modes that it supports

⚠️ A PV with only ReadWriteMany won't satisfy a PVC with ReadWriteOnce!

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Capacity

- A PVC must express a storage size request

  (field `spec.resources.requests.storage`, in bytes)

- A PV must express its size

  (field `spec.capacity.storage`, in bytes)

- Kubernetes will only match a PV and PVC if the PV is big enough

- These fields are only used for "matchmaking" purposes:

  - nothing prevents the Pod mounting the PVC from using more space

  - nothing requires the PV to actually be that big

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Storage Class

- What if we have multiple storage systems available?

  (e.g. NFS and iSCSI; or AzureFile and AzureDisk; or Cinder and Ceph...)

- What if we have a storage system with multiple tiers?

  (e.g. SAN with RAID1 and RAID5; general purpose vs. io optimized EBS...)

- Kubernetes lets us define *storage classes* to represent these

  (see if you have any available at the moment with `kubectl get storageclasses`)

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Using storage classes

- Optionally, each PV and each PVC can reference a StorageClass

  (field `spec.storageClassName`)

- When creating a PVC, specifying a StorageClass means

  “use that particular storage system to provision the volume!”

- Storage classes are necessary for [dynamic provisioning](https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/)

  (but we can also ignore them and perform manual provisioning)

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Default storage class

- We can define a *default storage class*

  (by annotating it with `storageclass.kubernetes.io/is-default-class=true`)

- When a PVC is created,

  **IF** it doesn't indicate which storage class to use

  **AND** there is a default storage class

  **THEN** the PVC `storageClassName` is set to the default storage class

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Additional constraints

- A PersistentVolumeClaim can also specify a volume selector

  (referring to labels on the PV)

- A PersistentVolume can also be created with a `claimRef`

  (indicating to which PVC it should be bound)

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

class: extra-details

## Which PV gets associated to a PVC?

- The PV must be `Available`

- The PV must satisfy the PVC constraints

  (access mode, size, optional selector, optional storage class)

- The PVs with the closest access mode are picked

- Then the PVs with the closest size

- It is possible to specify a `claimRef` when creating a PV

  (this will associate it to the specified PVC, but only if the PV satisfies all the requirements of the PVC; otherwise another PV might end up being picked)

- For all the details about the PersistentVolumeClaimBinder, check [this doc](https://github.com/kubernetes/design-proposals-archive/blob/main/storage/persistent-storage.md#matching-and-binding)

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Creating a PVC

- Let's create a standalone PVC and see what happens!

.lab[

- Check if we have a StorageClass:
  ```bash
  kubectl get storageclasses
  ```

- Create the PVC:
  ```bash
  kubectl create -f ~/container.training/k8s/pvc.yaml
  ```

- Check the PVC:
  ```bash
  kubectl get pvc
  ```

]

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Four possibilities

1. If we have a default StorageClass with *immediate* binding:

   *a PV was created and associated to the PVC*

2. If we have a default StorageClass that *waits for first consumer*:

  *the PVC is still `Pending` but has a `STORAGECLASS`* ⚠️

3. If we don't have a default StorageClass:

  *the PVC is still `Pending`, without a `STORAGECLASS`*

4. If we have a StorageClass, but it doesn't work:

  *the PVC is still `Pending` but has a `STORAGECLASS`* ⚠️

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Immediate vs WaitForFirstConsumer

- Immediate = as soon as there is a `Pending` PVC, create a PV

- What if:

  - the PV is only available on a node (e.g. local volume)

  - ...or on a subset of nodes (e.g. SAN HBA, EBS AZ...)

  - the Pod that will use the PVC has scheduling constraints

  - these constraints turn out to be incompatible with the PV

- WaitForFirstConsumer = don't provision the PV until a Pod mounts the PVC

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Using the PVC

- Let's mount the PVC in a Pod

- We will use a stray Pod (no Deployment, StatefulSet, etc.)

- We will use [k8s/mounter.yaml](https://github.com/jpetazzo/container.training/tree/master/k8s/mounter.yaml), shown on the next slide

- We'll need to update the `claimName`! ⚠️

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

```yaml
kind: Pod
apiVersion: v1
metadata:
  generateName: mounter-
  labels:
    container.training/mounter: ""
spec:
  volumes:
  - name: pvc
    persistentVolumeClaim:
      claimName: my-pvc-XYZ45
  containers:
  - name: mounter
    image: alpine
    stdin: true
    tty: true
    volumeMounts:
    - name: pvc
      mountPath: /pvc
    workingDir: /pvc

```

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Running the Pod

.lab[

- Edit the `mounter.yaml` manifest

- Update the `claimName` to put the name of our PVC

- Create the Pod

- Check the status of the PV and PVC

]

Note: this "mounter" Pod can be useful to inspect the content of a PVC.

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Scenario 1 & 2

If we have a default Storage Class that can provision PVC dynamically...

- We should now have a new PV

- The PV and the PVC should be `Bound` together

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Scenario 3

If we don't have a default Storage Class, we must create the PV manually.

```bash
kubectl create -f ~/container.training/k8s/pv.yaml
```

After a few seconds, check that the PV and PVC are bound:

```bash
kubectl get pv,pvc
```

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Scenario 4

If our default Storage Class can't provision a PV, let's do it manually.

The PV must specify the correct `storageClassName`.

```bash
STORAGECLASS=$(kubectl get pvc --selector=container.training/pvc \
               -o jsonpath={..storageClassName})
kubectl patch -f ~/container.training/k8s/pv.yaml --dry-run=client -o yaml \
        --patch '{"spec": {"storageClassName": "'$STORAGECLASS'"}}' \
        | kubectl create -f-
```

Check that the PV and PVC are bound:

```bash
kubectl get pv,pvc
```

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## Checking the Pod

- If the PVC was `Pending`, then the Pod was `Pending` too

- Once the PVC is `Bound`, the Pod can be scheduled and can run

- Once the Pod is `Running`, check it out with `kubectl attach -ti`

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---

## PV and PVC lifecycle

- We can't delete a PV if it's `Bound`

- If we `kubectl delete` it, it goes to `Terminating` state

- We can't delete a PVC if it's in use by a Pod

- Likewise, if we `kubectl delete` it, it goes to `Terminating` state

- Deletion is prevented by *finalizers*

  (=like a post-it note saying “don't delete me!”)

- When the mounting Pods are deleted, their PVCs are freed up

- When PVCs are deleted, their PVs are freed up

???

:EN:- Storage provisioning
:EN:- PV, PVC, StorageClass
:FR:- Création de volumes
:FR:- PV, PVC, et StorageClass

.debug[[k8s/pv-pvc-sc.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/pv-pvc-sc.md)]
---
## Putting it all together

- We want to run that Consul cluster *and* actually persist data

- We'll use a StatefulSet that will leverage PV and PVC

- If we have a dynamic provisioner:

  *the cluster will come up right away*

- If we don't have a dynamic provisioner:

  *we will need to create Persistent Volumes manually*

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Persistent Volume Claims and Stateful sets

- A Stateful set can define one (or more) `volumeClaimTemplate`

- Each `volumeClaimTemplate` will create one Persistent Volume Claim per Pod

- Each Pod will therefore have its own individual volume

- These volumes are numbered (like the Pods)

- Example:

  - a Stateful set is named `consul`
  - it is scaled to replicas
  - it has a `volumeClaimTemplate` named `data`
  - then it will create pods `consul-0`, `consul-1`, `consul-2`
  - these pods will have volumes named `data`, referencing PersistentVolumeClaims
    named `data-consul-0`, `data-consul-1`, `data-consul-2`

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Persistent Volume Claims are sticky

- When updating the stateful set (e.g. image upgrade), each pod keeps its volume

- When pods get rescheduled (e.g. node failure), they keep their volume

  (this requires a storage system that is not node-local)

- These volumes are not automatically deleted

  (when the stateful set is scaled down or deleted)

- If a stateful set is scaled back up later, the pods get their data back

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Deploying Consul

- Let's use a new manifest for our Consul cluster

- The only differences between that file and the previous one are:

  - `volumeClaimTemplate` defined in the Stateful Set spec

  - the corresponding `volumeMounts` in the Pod spec

.lab[

- Apply the persistent Consul YAML file:
  ```bash
  kubectl apply -f ~/container.training/k8s/consul-3.yaml
  ```

]

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## No dynamic provisioner

- If we don't have a dynamic provisioner, we need to create the PVs

- We are going to use local volumes

  (similar conceptually to `hostPath` volumes)

- We can use local volumes without installing extra plugins

- However, they are tied to a node

- If that node goes down, the volume becomes unavailable

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Observing the situation

- Let's look at Persistent Volume Claims and Pods

.lab[

- Check that we now have an unbound Persistent Volume Claim:
  ```bash
  kubectl get pvc
  ```

- We don't have any Persistent Volume:
  ```bash
  kubectl get pv
  ```

- The Pod `consul-0` is not scheduled yet:
  ```bash
  kubectl get pods -o wide
  ```

]

*Hint: leave these commands running with `-w` in different windows.*

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Explanations

- In a Stateful Set, the Pods are started one by one

- `consul-1` won't be created until `consul-0` is running

- `consul-0` has a dependency on an unbound Persistent Volume Claim

- The scheduler won't schedule the Pod until the PVC is bound

  (because the PVC might be bound to a volume that is only available on a subset of nodes; for instance EBS are tied to an availability zone)

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Creating Persistent Volumes

- Let's create 3 local directories (`/mnt/consul`) on node2, node3, node4

- Then create 3 Persistent Volumes corresponding to these directories

.lab[

- Create the local directories:
  ```bash
    for NODE in node2 node3 node4; do
      ssh $NODE sudo mkdir -p /mnt/consul
    done
  ```

- Create the PV objects:
  ```bash
  kubectl apply -f ~/container.training/k8s/volumes-for-consul.yaml
  ```

]

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Check our Consul cluster

- The PVs that we created will be automatically matched with the PVCs

- Once a PVC is bound, its pod can start normally

- Once the pod `consul-0` has started, `consul-1` can be created, etc.

- Eventually, our Consul cluster is up, and backend by "persistent" volumes

.lab[

- Check that our Consul clusters has 3 members indeed:
  ```bash
  kubectl exec consul-0 -- consul members
  ```

]

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Devil is in the details (1/2)

- The size of the Persistent Volumes is bogus

  (it is used when matching PVs and PVCs together, but there is no actual quota or limit)

- The Pod might end up using more than the requested size

- The PV may or may not have the capacity that it's advertising

- It works well with dynamically provisioned block volumes

- ...Less so in other scenarios!

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Devil is in the details (2/2)

- This specific example worked because we had exactly 1 free PV per node:

  - if we had created multiple PVs per node ...

  - we could have ended with two PVCs bound to PVs on the same node ...

  - which would have required two pods to be on the same node ...

  - which is forbidden by the anti-affinity constraints in the StatefulSet

- To avoid that, we need to associated the PVs with a Storage Class that has:
  ```yaml
  volumeBindingMode: WaitForFirstConsumer
  ```
  (this means that a PVC will be bound to a PV only after being used by a Pod)

- See [this blog post](https://kubernetes.io/blog/2018/04/13/local-persistent-volumes-beta/) for more details

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## If we have a dynamic provisioner

These are the steps when dynamic provisioning happens:

1. The Stateful Set creates PVCs according to the `volumeClaimTemplate`.

2. The Stateful Set creates Pods using these PVCs.

3. The PVCs are automatically annotated with our Storage Class.

4. The dynamic provisioner provisions volumes and creates the corresponding PVs.

5. The PersistentVolumeClaimBinder associates the PVs and the PVCs together.

6. PVCs are now bound, the Pods can start.

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Validating persistence (1)

- When the StatefulSet is deleted, the PVC and PV still exist

- And if we recreate an identical StatefulSet, the PVC and PV are reused

- Let's see that!

.lab[

- Put some data in Consul:
  ```bash
  kubectl exec consul-0 -- consul kv put answer 42
  ```

- Delete the Consul cluster:
  ```bash
  kubectl delete -f ~/container.training/k8s/consul-3.yaml
  ```

]

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Validating persistence (2)

.lab[

- Wait until the last Pod is deleted:
  ```bash
  kubectl wait pod consul-0 --for=delete
  ```

- Check that PV and PVC are still here:
  ```bash
  kubectl get pv,pvc
  ```

]

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Validating persistence (3)

.lab[

- Re-create the cluster:
  ```bash
  kubectl apply -f ~/container.training/k8s/consul-3.yaml
  ```

- Wait until it's up

- Then access the key that we set earlier:
  ```bash
  kubectl exec consul-0 -- consul kv get answer
  ```

]

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

## Cleaning up

- PV and PVC don't get deleted automatically

- This is great (less risk of accidental data loss)

- This is not great (storage usage increases)

- Managing PVC lifecycle:

  - remove them manually

  - add their StatefulSet to their `ownerReferences`

  - delete the Namespace that they belong to

???

:EN:- Defining volumeClaimTemplates
:FR:- Définir des volumeClaimTemplates

.debug[[k8s/volume-claim-templates.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/volume-claim-templates.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-openebs-
class: title

 OpenEBS 

.nav[
[Previous part](#toc-pv-pvc-and-storage-classes)
|
[Back to table of contents](#toc-part-15)
|
[Next part](#toc-stateful-failover)
]

.debug[(automatically generated title slide)]

---
# OpenEBS 

 - [OpenEBS] is a popular open-source storage solution for Kubernetes

 - Uses the concept of "Container Attached Storage"

   (1 volume = 1 dedicated controller pod + a set of replica pods)

 - Supports a wide range of storage engines:

   - LocalPV: local volumes (hostpath or device), no replication

   - Jiva: for lighter workloads with basic cloning/snapshotting

   - cStor: more powerful engine that also supports resizing, RAID, disk pools ...

   - [Mayastor]: newer, even more powerful engine with NVMe and vhost-user support

[OpenEBS]: https://openebs.io/

[Mayastor]: https://github.com/openebs/MayaStor#mayastor

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

class: extra-details

## What are all these storage engines?

- LocalPV is great if we want good performance, no replication, easy setup

  (it is similar to the Rancher local path provisioner)

- Jiva is great if we want replication and easy setup

  (data is stored in containers' filesystems)

- cStor is more powerful and flexible, but requires more extensive setup

- Mayastor is designed to achieve extreme performance levels

  (with the right hardware and disks)

- The OpenEBS documentation has a [good comparison of engines] to help us pick

[good comparison of engines]: https://docs.openebs.io/docs/next/casengines.html#cstor-vs-jiva-vs-localpv-features-comparison

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Installing OpenEBS with Helm

- The OpenEBS control plane can be installed with Helm

- It will run as a set of containers on Kubernetes worker nodes

.lab[

  - Install OpenEBS:
  ```bash  
    helm upgrade --install openebs openebs \
         --repo https://openebs.github.io/charts \
         --namespace openebs --create-namespace \
         --version 2.12.9
  ```
]

⚠️ We stick to OpenEBS 2.x because 3.x requires additional configuration.

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Checking what was installed

- Wait a little bit ...

.lab[

- Look at the pods in the `openebs` namespace:
  ```bash  
      kubectl get pods --namespace openebs
  ```

- And the StorageClasses that were created:
  ```bash  
      kubectl get sc
  ```

]

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## The default StorageClasses

- OpenEBS typically creates three default StorageClasses

- `openebs-jiva-default` provisions 3 replicated Jiva pods per volume

  - data is stored in `/openebs` in the replica pods
  - `/openebs` is a localpath volume mapped to `/var/openebs/pvc-...` on the node

- `openebs-hostpath` uses LocalPV with local directories

  - volumes are hostpath volumes created in `/var/openebs/local` on each node

- `openebs-device` uses LocalPV with local block devices

  - requires available disks and/or a bit of extra configuration
  - the default configuration filters out loop, LVM, MD devices

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## When do we need custom StorageClasses?

- To store LocalPV hostpath volumes on a different path on the host

- To change the number of replicated Jiva pods

- To use a different Jiva pool

  (i.e. a different path on the host to store the Jiva volumes)

- To create a cStor pool

- ...

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

class: extra-details

## Defining a custom StorageClass

Example for a LocalPV hostpath class using an extra mount on `/mnt/vol001`:

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: localpv-hostpath-mntvol001
  annotations:
    openebs.io/cas-type: local
    cas.openebs.io/config: |
      - name: BasePath
        value: "/mnt/vol001"
      - name: StorageType
        value: "hostpath"
provisioner: openebs.io/local
```

- `provisioner` needs to be set accordingly
- Storage engine is chosen by specifying the annotation `openebs.io/cas-type`
- Storage engine configuration is set with the annotation `cas.openebs.io/config` 

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Checking the default hostpath StorageClass

- Let's inspect the StorageClass that OpenEBS created for us

.lab[

- Let's look at the OpenEBS LocalPV hostpath StorageClass:
  ```bash
  kubectl get storageclass openebs-hostpath -o yaml
  ``` 
]

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Create a host path PVC

- Let's create a Persistent Volume Claim using an explicit StorageClass

.lab[

```bash
kubectl apply -f - <<EOF
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: local-hostpath-pvc
spec:
  storageClassName: openebs-hostpath
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1G
EOF
```

]

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## `WaitForFirstConsumer`

- Did OpenEBS create a PV for our PVC?

.lab[

- Find out:
  ```bash
  kubectl get pv,pvc
  ```

]

--

- No!

- This is because that class is `WaitForFirstConsumer` instead of `Immediate`

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Create a Pod to consume the PV

.lab[

- Create a Pod using that PVC:
  ```bash
  kubectl apply -f ~/container.training/k8s/openebs-pod.yaml
  ```

- Here are the sections that declare and use the volume:
  ```yaml
    volumes:
    - name: my-storage
      persistentVolumeClaim:
        claimName: local-hostpath-pvc
    containers:
    ...  
      volumeMounts:
      - mountPath: /mnt/storage
        name: my-storage
  ```

]

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Making sure that a PV was created for our PVC

- At that point, the `openebs-hostpath` StorageClass created a PV for our PVC

.lab[

- Look at the PV and PVC:
  ```bash
  kubectl get pv,pvc
  ```

]

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Verify that data is written on the node

- Let's find the file written by the Pod on the node where the Pod is running

.lab[

- Get the worker node where the pod is located
  ```bash
  kubectl get pod openebs-local-hostpath-pod -ojsonpath={.spec.nodeName}
  ```

- SSH into the node

- Check the volume content
  ```bash
  sudo tail /var/openebs/local/pvc-*/greet.txt
  ```

]

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Heads up!

- The following labs and exercises will use the Jiva storage class

- This storage class creates 3 replicas by default

- It uses *anti-affinity* placement constraits to put these replicas on different nodes

- **This requires a cluster with multiple nodes!**

- It also requires the iSCSI client (aka *initiator*) to be installed on the nodes

- On many platforms, the iSCSI client is preinstalled and will start automatically

- If it doesn't, you might want to check [this documentation page] for details

[this documentation page]: https://docs.openebs.io/docs/next/prerequisites.html

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## The default StorageClass

- The PVC that we defined earlier specified an explicit StorageClass

- We can also set a default StorageClass

- It will then be used for all PVC that *don't* specify and explicit StorageClass

- This is done with the annotation `storageclass.kubernetes.io/is-default-class`

.lab[

- Check if we have a default StorageClass:
  ```bash
  kubectl get storageclasses
  ```
]

- The default StorageClass (if there is one) is shown with `(default)`

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## Setting a default StorageClass

- Let's set the default StorageClass to use `openebs-jiva-default`

.lab[

- Remove the annotation (just in case we already have a default class):
  ```bash
  kubectl annotate storageclass storageclass.kubernetes.io/is-default-class- --all
  ```

- Annotate the Jiva StorageClass:
  ```bash
  kubectl annotate storageclasses \
      openebs-jiva-default storageclass.kubernetes.io/is-default-class=true
  ```

- Check the result:
  ```bash
  kuectl get storageclasses
  ```

]

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

## We're ready now!

- We have a StorageClass that can provision PersistentVolumes

- These PersistentVolumes will be replicated across nodes

- They should be able to withstand single-node failures

???

:EN:- Understanding Container Attached Storage (CAS)
:EN:- Deploying stateful apps with OpenEBS

:FR:- Comprendre le "Container Attached Storage" (CAS)
:FR:- Déployer une application "stateful" avec OpenEBS

.debug[[k8s/openebs.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/openebs.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-stateful-failover
class: title

 Stateful failover

.nav[
[Previous part](#toc-openebs-)
|
[Back to table of contents](#toc-part-15)
|
[Next part](#toc-resources)
]

.debug[(automatically generated title slide)]

---
# Stateful failover

- How can we achieve true durability?

- How can we store data that would survive the loss of a node?

--

- We need to use Persistent Volumes backed by highly available storage systems

- There are many ways to achieve that:

  - leveraging our cloud's storage APIs

  - using NAS/SAN systems or file servers

  - distributed storage systems

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Our test scenario

- We will use it to deploy a SQL database (PostgreSQL)

- We will insert some test data in the database

- We will disrupt the node running the database

- We will see how it recovers

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Our Postgres Stateful set

- The next slide shows `k8s/postgres.yaml`

- It defines a Stateful set

- With a `volumeClaimTemplate` requesting a 1 GB volume

- That volume will be mounted to `/var/lib/postgresql/data`

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

.small[.small[
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  selector:
    matchLabels:
      app: postgres
  serviceName: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      #schedulerName: stork
      initContainers:
      - name: rmdir
        image: alpine
        volumeMounts:
        - mountPath: /vol
          name: postgres
        command: ["sh", "-c", "if [ -d /vol/lost+found ]; then rmdir /vol/lost+found; fi"]
      containers:
      - name: postgres
        image: postgres:12
        env:
        - name: POSTGRES_HOST_AUTH_METHOD
          value: trust
        volumeMounts:
        - mountPath: /var/lib/postgresql/data
          name: postgres
  volumeClaimTemplates:
  - metadata:
      name: postgres
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi


```
]]

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Creating the Stateful set

- Before applying the YAML, watch what's going on with `kubectl get events -w`

.lab[

- Apply that YAML:
  ```bash
  kubectl apply -f ~/container.training/k8s/postgres.yaml
  ```

<!-- ```hide kubectl wait pod postgres-0 --for condition=ready``` -->

]

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Testing our PostgreSQL pod

- We will use `kubectl exec` to get a shell in the pod

- Good to know: we need to use the `postgres` user in the pod

.lab[

- Get a shell in the pod, as the `postgres` user:
  ```bash
  kubectl exec -ti postgres-0 -- su postgres
  ```

<!--
autopilot prompt detection expects $ or # at the beginning of the line.
```wait postgres@postgres```
```keys PS1="\u@\h:\w\n\$ "```
```key ^J```
-->

- Check that default databases have been created correctly:
  ```bash
  psql -l
  ```

]

(This should show us 3 lines: postgres, template0, and template1.)

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Inserting data in PostgreSQL

- We will create a database and populate it with `pgbench`

.lab[

- Create a database named `demo`:
  ```bash
  createdb demo
  ```

- Populate it with `pgbench`:
  ```bash
  pgbench -i demo
  ```

]

- The `-i` flag means "create tables"

- If you want more data in the test tables, add e.g. `-s 10` (to get 10x more rows)

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Checking how much data we have now

- The `pgbench` tool inserts rows in table `pgbench_accounts`

.lab[

- Check that the `demo` base exists:
  ```bash
  psql -l
  ```

- Check how many rows we have in `pgbench_accounts`:
  ```bash
  psql demo -c "select count(*) from pgbench_accounts"
  ```

- Check that `pgbench_history` is currently empty:
  ```bash
  psql demo -c "select count(*) from pgbench_history"
  ```

]

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Testing the load generator

- Let's use `pgbench` to generate a few transactions

.lab[

- Run `pgbench` for 10 seconds, reporting progress every second:
  ```bash
  pgbench -P 1 -T 10 demo
  ```

- Check the size of the history table now:
  ```bash
  psql demo -c "select count(*) from pgbench_history"
  ```

]

Note: on small cloud instances, a typical speed is about 100 transactions/second.

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Generating transactions

- Now let's use `pgbench` to generate more transactions

- While it's running, we will disrupt the database server

.lab[

- Run `pgbench` for 10 minutes, reporting progress every second:
  ```bash
  pgbench -P 1 -T 600 demo
  ```

- You can use a longer time period if you need more time to run the next steps

<!-- ```tmux split-pane -h``` -->

]

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Find out which node is hosting the database

- We can find that information with `kubectl get pods -o wide`

.lab[

- Check the node running the database:
  ```bash
  kubectl get pod postgres-0 -o wide
  ```

]

We are going to disrupt that node.

--

By "disrupt" we mean: "disconnect it from the network".

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Node failover

⚠️ This will partially break your cluster!

- We are going to disconnect the node running PostgreSQL from the cluster

- We will see what happens, and how to recover

- We will not reconnect the node to the cluster

- This whole lab will take at least 10-15 minutes (due to various timeouts)

⚠️ Only do this lab at the very end, when you don't want to run anything else after!

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Disconnecting the node from the cluster

.lab[

- Find out where the Pod is running, and SSH into that node:
  ```bash
  kubectl get pod postgres-0 -o jsonpath={.spec.nodeName}
  ssh nodeX
  ```

- Check the name of the network interface:
  ```bash
  sudo ip route ls default
  ```

- The output should look like this:
  ```
  default via 10.10.0.1 `dev ensX` proto dhcp src 10.10.0.13 metric 100 
  ```

- Shutdown the network interface:
  ```bash
  sudo ip link set ensX down
  ```

]

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

class: extra-details

## Another way to disconnect the node

- We can also use `iptables` to block all traffic exiting the node

  (except SSH traffic, so we can repair the node later if needed)

.lab[

- SSH to the node to disrupt:
  ```bash
  ssh `nodeX`
  ```

- Allow SSH traffic leaving the node, but block all other traffic:
  ```bash
  sudo iptables -I OUTPUT -p tcp --sport 22 -j ACCEPT
  sudo iptables -I OUTPUT 2 -j DROP
  ```

]

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Watch what's going on

- Let's look at the status of Nodes, Pods, and Events

.lab[

- In a first pane/tab/window, check Nodes and Pods:
  ```bash
  watch kubectl get nodes,pods -o wide
  ```

- In another pane/tab/window, check Events:
  ```bash
  kubectl get events --watch
  ```

]

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Node Ready → NotReady

- After \~30 seconds, the control plane stops receiving heartbeats from the Node

- The Node is marked NotReady

- It is not *schedulable* anymore

  (the scheduler won't place new pods there, except some special cases)

- All Pods on that Node are also *not ready*

  (they get removed from service Endpoints)

- ... But nothing else happens for now

  (the control plane is waiting: maybe the Node will come back shortly?)

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Pod eviction

- After \~5 minutes, the control plane will evict most Pods from the Node

- These Pods are now `Terminating`

- The Pods controlled by e.g. ReplicaSets are automatically moved

  (or rather: new Pods are created to replace them)

- But nothing happens to the Pods controlled by StatefulSets at this point

  (they remain `Terminating` forever)

- Why? 🤔

--

- This is to avoid *split brain scenarios*

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

class: extra-details

## Split brain 🧠⚡️🧠

- Imagine that we create a replacement pod `postgres-0` on another Node

- And 15 minutes later, the Node is reconnected and the original `postgres-0` comes back

- Which one is the "right" one?

- What if they have conflicting data?

😱

- We *cannot* let that happen!

- Kubernetes won't do it

- ... Unless we tell it to

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## The Node is gone

- One thing we can do, is tell Kubernetes "the Node won't come back"

  (there are other methods; but this one is the simplest one here)

- This is done with a simple `kubectl delete node`

.lab[

- `kubectl delete` the Node that we disconnected

]

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Pod rescheduling

- Kubernetes removes the Node

- After a brief period of time (\~1 minute) the "Terminating" Pods are removed

- A replacement Pod is created on another Node

- ... But it doesn't start yet!

- Why? 🤔

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Multiple attachment

- By default, a disk can only be attached to one Node at a time

  (sometimes it's a hardware or API limitation; sometimes enforced in software)

- In our Events, we should see `FailedAttachVolume` and `FailedMount` messages

- After \~5 more minutes, the disk will be force-detached from the old Node

- ... Which will allow attaching it to the new Node!

🎉

- The Pod will then be able to start

- Failover is complete!

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Check that our data is still available

- We are going to reconnect to the (new) pod and check

.lab[

- Get a shell on the pod:
  ```bash
  kubectl exec -ti postgres-0 -- su postgres
  ```

<!--
```wait postgres@postgres```
```keys PS1="\u@\h:\w\n\$ "```
```key ^J```
-->

- Check how many transactions are now in the `pgbench_history` table:
  ```bash
  psql demo -c "select count(*) from pgbench_history"
  ```

<!-- ```key ^D``` -->

]

If the 10-second test that we ran earlier gave e.g. 80 transactions per second,
and we failed the node after 30 seconds, we should have about 2400 row in that table.

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

## Double-check that the pod has really moved

- Just to make sure the system is not bluffing!

.lab[

- Look at which node the pod is now running on
  ```bash
  kubectl get pod postgres-0 -o wide
  ```

]

???

:EN:- Using highly available persistent volumes
:EN:- Example: deploying a database that can withstand node outages

:FR:- Utilisation de volumes à haute disponibilité
:FR:- Exemple : déployer une base de données survivant à la défaillance d'un nœud

.debug[[k8s/stateful-failover.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/k8s/stateful-failover.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-resources
class: title

 Resources

.nav[
[Previous part](#toc-stateful-failover)
|
[Back to table of contents](#toc-part-16)
|
[Next part](#toc-)
]

.debug[(automatically generated title slide)]

---
# Resources

- Container training by Jérôme Petazzoni

- Burns, B., Beda, J., &amp; Hightower, K. (2019). Kubernetes: Up and Running: Dive into the Future of Infrastructure
(2nd ed.). O&#39;Reilly Media.

- Poulton, N. (2020). The Kubernetes Book: Version 2020 with 40 pages of updates. Independently published.

- Luksa, M. (2018). Kubernetes in Action. Manning Publications.

- Sayfan, G. (2018). Mastering Kubernetes: Master the art of container management by using the power of
Kubernetes (2nd ed.). Packt Publishing.

---
- Hausenblas, M., &amp; Schimanski, S. (2019). Programming Kubernetes: Developing Cloud-Native Applications.
O&#39;Reilly Media.

- Ibryam, B., &amp; Huß, R. (2019). Kubernetes Patterns: Reusable Elements for Designing Cloud-Native
Applications. O&#39;Reilly Media.

- Arundel, J., &amp; Domingus, J. (2019). Cloud Native DevOps with Kubernetes: Building, Deploying, and Scaling
Modern Applications in the Cloud. O&#39;Reilly Media.

- Saha, P. (2018). Kubernetes Security: Implementing Security Best Practices. Packt Publishing.

.debug[[containers/credit.md](https://github.com/jpetazzo/container.training.git/tree/main/slides/containers/credit.md)]</textarea>
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        ratio: '16:9',
        highlightSpans: true,
        slideNumberFormat: '%current%/%total%',
        excludedClasses: ["self-paced"]
      });
    </script>
    
    <!-- 
    These two scripts will be available only when loading the
    content using the pub/sub server. Otherwise, they'll just
    404 and that's OK.
    -->
    <script src="/socket.io/socket.io.js">
    </script>
    <script src="/remote.js">
    </script>

  </body>
</html>
